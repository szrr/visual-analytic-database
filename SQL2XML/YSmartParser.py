# $ANTLR 3.3 Nov 30, 2010 12:45:30 /home/szr/subquery/SQL2XML/YSmart.g 2023-09-01 16:55:04

import sys
from antlr3 import *
from antlr3.compat import set, frozenset

from antlr3.tree import *



# for convenience in actions
HIDDEN = BaseRecognizer.HIDDEN

# token types
EOF=-1
T__91=91
T__92=92
T__93=93
T__94=94
T__95=95
T__96=96
T__97=97
T__98=98
T__99=99
T__100=100
T__101=101
T__102=102
T__103=103
T__104=104
T__105=105
T__106=106
T__107=107
T__108=108
T__109=109
T__110=110
T__111=111
T__112=112
T__113=113
T__114=114
T__115=115
T__116=116
T__117=117
T__118=118
T__119=119
T__120=120
T__121=121
T__122=122
T__123=123
T__124=124
T__125=125
T__126=126
T__127=127
T__128=128
T__129=129
T__130=130
T__131=131
T__132=132
T__133=133
T__134=134
T__135=135
T__136=136
T__137=137
T__138=138
T__139=139
T__140=140
T__141=141
T__142=142
T__143=143
T__144=144
T__145=145
T__146=146
T__147=147
T__148=148
T__149=149
T__150=150
T__151=151
T__152=152
T__153=153
T__154=154
T__155=155
T__156=156
T__157=157
T__158=158
T__159=159
T__160=160
T__161=161
T__162=162
T__163=163
T__164=164
T__165=165
T__166=166
T__167=167
T__168=168
T__169=169
T__170=170
T__171=171
T__172=172
T__173=173
T__174=174
T__175=175
T__176=176
T__177=177
T__178=178
T__179=179
T__180=180
T__181=181
T__182=182
T__183=183
T__184=184
T__185=185
T__186=186
T__187=187
T__188=188
T__189=189
T__190=190
T__191=191
T__192=192
T__193=193
T__194=194
T__195=195
T__196=196
T__197=197
T__198=198
T__199=199
T__200=200
T__201=201
T__202=202
T__203=203
T__204=204
T__205=205
T__206=206
T__207=207
T__208=208
T__209=209
T__210=210
T__211=211
T__212=212
T__213=213
T__214=214
T__215=215
T__216=216
T__217=217
T__218=218
T__219=219
T__220=220
T__221=221
T__222=222
T__223=223
T__224=224
T__225=225
T__226=226
T__227=227
T__228=228
T__229=229
T__230=230
T__231=231
T__232=232
T__233=233
T__234=234
T__235=235
T__236=236
T__237=237
T__238=238
T__239=239
T__240=240
T__241=241
T__242=242
T__243=243
T__244=244
T__245=245
T__246=246
T__247=247
T__248=248
T__249=249
T__250=250
T__251=251
T__252=252
T__253=253
T__254=254
T__255=255
T__256=256
T__257=257
T__258=258
T__259=259
T__260=260
T__261=261
T__262=262
T__263=263
T__264=264
T__265=265
T__266=266
T__267=267
T__268=268
T__269=269
T__270=270
T__271=271
T__272=272
T__273=273
T__274=274
T__275=275
T__276=276
T__277=277
T__278=278
T__279=279
T__280=280
T__281=281
T__282=282
T__283=283
T__284=284
T__285=285
T__286=286
T__287=287
T__288=288
T__289=289
T__290=290
T__291=291
T__292=292
T__293=293
T__294=294
T__295=295
T__296=296
T__297=297
T__298=298
T__299=299
T__300=300
T__301=301
T__302=302
T__303=303
T__304=304
T__305=305
T__306=306
T__307=307
T__308=308
T__309=309
T__310=310
T__311=311
T__312=312
T__313=313
T__314=314
T__315=315
T__316=316
T__317=317
T__318=318
T__319=319
T__320=320
T__321=321
T__322=322
T__323=323
T__324=324
T__325=325
T__326=326
T__327=327
T__328=328
T__329=329
T__330=330
T__331=331
T__332=332
T__333=333
T__334=334
T__335=335
T__336=336
T__337=337
T__338=338
T__339=339
T__340=340
T__341=341
T__342=342
T__343=343
T__344=344
T__345=345
T__346=346
T__347=347
T__348=348
T__349=349
T__350=350
T__351=351
T__352=352
T__353=353
T__354=354
T__355=355
T__356=356
T__357=357
T__358=358
T__359=359
T__360=360
T__361=361
T__362=362
T__363=363
T__364=364
T__365=365
T__366=366
T__367=367
T__368=368
T__369=369
T__370=370
T__371=371
T__372=372
T__373=373
T__374=374
T__375=375
T__376=376
T__377=377
T__378=378
T__379=379
T__380=380
T__381=381
T__382=382
T__383=383
T__384=384
T__385=385
T__386=386
T__387=387
T__388=388
T__389=389
T__390=390
T__391=391
T__392=392
T__393=393
T__394=394
T__395=395
T__396=396
T__397=397
T__398=398
T__399=399
T__400=400
T__401=401
T__402=402
T__403=403
T__404=404
T__405=405
T__406=406
T__407=407
T__408=408
T__409=409
T__410=410
T__411=411
T__412=412
T__413=413
T__414=414
T__415=415
T__416=416
T__417=417
T__418=418
T__419=419
T__420=420
T__421=421
T__422=422
T__423=423
T__424=424
T__425=425
T__426=426
T__427=427
T__428=428
T__429=429
T__430=430
T__431=431
T__432=432
T__433=433
T__434=434
T__435=435
T__436=436
T__437=437
T__438=438
T__439=439
T__440=440
T__441=441
T__442=442
T__443=443
T__444=444
T__445=445
T__446=446
T__447=447
T__448=448
T__449=449
T__450=450
T__451=451
T__452=452
T__453=453
T__454=454
T__455=455
T__456=456
T__457=457
T__458=458
T__459=459
T__460=460
T__461=461
T__462=462
T__463=463
T__464=464
T__465=465
T__466=466
T__467=467
T__468=468
T__469=469
T__470=470
T__471=471
T__472=472
T__473=473
T__474=474
T__475=475
T__476=476
T__477=477
T__478=478
T__479=479
T__480=480
T__481=481
T__482=482
T__483=483
T__484=484
T__485=485
T__486=486
T__487=487
T__488=488
T__489=489
T__490=490
T__491=491
T__492=492
T__493=493
T__494=494
T__495=495
T__496=496
T__497=497
T__498=498
T__499=499
T__500=500
T__501=501
T__502=502
T__503=503
T__504=504
T__505=505
T__506=506
T__507=507
T__508=508
T__509=509
T__510=510
T__511=511
T__512=512
T__513=513
T__514=514
T__515=515
T__516=516
T__517=517
T__518=518
T__519=519
T__520=520
T__521=521
T__522=522
T__523=523
T__524=524
T__525=525
T__526=526
T__527=527
T__528=528
T__529=529
T__530=530
T__531=531
T__532=532
T__533=533
T__534=534
T__535=535
T__536=536
T__537=537
T__538=538
T__539=539
T__540=540
T__541=541
T__542=542
T__543=543
T__544=544
T__545=545
T__546=546
T_RESERVED=4
T_ALIAS=5
T_TABLE_NAME=6
T_WITH=7
T_SELECT=8
T_COLUMN_LIST=9
T_SELECT_COLUMN=10
T_FROM=11
T_SELECTED_TABLE=12
T_WHERE=13
T_HIERARCHICAL=14
T_GROUP_BY=15
T_HAVING=16
T_MODEL=17
T_UNION=18
T_ORDER_BY_CLAUSE=19
T_LIMIT_CLAUSE=20
T_FOR_UPDATE_CLAUSE=21
T_COND_OR=22
T_COND_AND=23
T_COND_NOT=24
T_COND_exists=25
T_COND_is=26
T_COND_comparison=27
T_COND_group_comparison=28
T_COND_in=29
T_COND_is_a_set=30
T_COND_is_any=31
T_COND_is_empty=32
T_COND_is_of_type=33
T_COND_is_present=34
T_COND_like=35
T_COND_memeber=36
T_COND_between=37
T_COND_regexp_like=38
T_COND_submultiset=39
T_COND_equals_path=40
T_COND_under_path=41
T_COND_paren=42
SEMI=43
COMMA=44
ASTERISK=45
DOT=46
PLUS=47
MINUS=48
DOUBLEVERTBAR=49
DIVIDE=50
EXPONENT=51
LPAREN=52
RPAREN=53
ARROW=54
FOUND_ATTR=55
NOTFOUND_ATTR=56
ISOPEN_ATTR=57
ROWCOUNT_ATTR=58
BULK_ROWCOUNT_ATTR=59
NUMBER=60
CHARSET_ATTR=61
VECTOR=62
PATH=63
ID=64
DOUBLEQUOTED_STRING=65
EQ=66
NOT_EQ=67
GTH=68
GEQ=69
LTH=70
LEQ=71
QUOTED_STRING=72
COLON=73
POINT=74
DOUBLEDOT=75
AT_SIGN=76
RBRACK=77
LBRACK=78
PERCENTAGE=79
LLABEL=80
RLABEL=81
ASSIGN=82
VERTBAR=83
NUM=84
QUOTE=85
WS=86
SL_COMMENT=87
ML_COMMENT=88
TYPE_ATTR=89
ROWTYPE_ATTR=90

# token names
tokenNames = [
    "<invalid>", "<EOR>", "<DOWN>", "<UP>", 
    "T_RESERVED", "T_ALIAS", "T_TABLE_NAME", "T_WITH", "T_SELECT", "T_COLUMN_LIST", 
    "T_SELECT_COLUMN", "T_FROM", "T_SELECTED_TABLE", "T_WHERE", "T_HIERARCHICAL", 
    "T_GROUP_BY", "T_HAVING", "T_MODEL", "T_UNION", "T_ORDER_BY_CLAUSE", 
    "T_LIMIT_CLAUSE", "T_FOR_UPDATE_CLAUSE", "T_COND_OR", "T_COND_AND", 
    "T_COND_NOT", "T_COND_exists", "T_COND_is", "T_COND_comparison", "T_COND_group_comparison", 
    "T_COND_in", "T_COND_is_a_set", "T_COND_is_any", "T_COND_is_empty", 
    "T_COND_is_of_type", "T_COND_is_present", "T_COND_like", "T_COND_memeber", 
    "T_COND_between", "T_COND_regexp_like", "T_COND_submultiset", "T_COND_equals_path", 
    "T_COND_under_path", "T_COND_paren", "SEMI", "COMMA", "ASTERISK", "DOT", 
    "PLUS", "MINUS", "DOUBLEVERTBAR", "DIVIDE", "EXPONENT", "LPAREN", "RPAREN", 
    "ARROW", "FOUND_ATTR", "NOTFOUND_ATTR", "ISOPEN_ATTR", "ROWCOUNT_ATTR", 
    "BULK_ROWCOUNT_ATTR", "NUMBER", "CHARSET_ATTR", "VECTOR", "PATH", "ID", 
    "DOUBLEQUOTED_STRING", "EQ", "NOT_EQ", "GTH", "GEQ", "LTH", "LEQ", "QUOTED_STRING", 
    "COLON", "POINT", "DOUBLEDOT", "AT_SIGN", "RBRACK", "LBRACK", "PERCENTAGE", 
    "LLABEL", "RLABEL", "ASSIGN", "VERTBAR", "NUM", "QUOTE", "WS", "SL_COMMENT", 
    "ML_COMMENT", "TYPE_ATTR", "ROWTYPE_ATTR", "'KNN'", "'K='", "'ACCESS'", 
    "'ADD'", "'ALL'", "'ALTER'", "'AND'", "'ANY'", "'ARRAYLEN'", "'AS'", 
    "'ASC'", "'AUDIT'", "'BETWEEN'", "'BY'", "'CASE'", "'CHAR'", "'CHECK'", 
    "'CLUSTER'", "'COLUMN'", "'COMMENT'", "'COMPRESS'", "'CONNECT'", "'CREATE'", 
    "'CURRENT'", "'DATE'", "'DECIMAL'", "'DEFAULT'", "'DELETE'", "'DESC'", 
    "'DISTINCT'", "'DROP'", "'ELSE'", "'EXCLUSIVE'", "'EXISTS'", "'FALSE'", 
    "'FILE'", "'FLOAT'", "'FOR'", "'FROM'", "'GRANT'", "'GROUP'", "'HAVING'", 
    "'IDENTIFIED'", "'IMMEDIATE'", "'IN'", "'INCREMENT'", "'INDEX'", "'INITIAL'", 
    "'INSERT'", "'INTEGER'", "'INTERSECT'", "'INTO'", "'IS'", "'LEVEL'", 
    "'LIKE'", "'LIKE2'", "'LIKE4'", "'LIKEC'", "'LOCK'", "'LONG'", "'MAXEXTENTS'", 
    "'MINUS'", "'MODE'", "'MODIFY'", "'NOAUDIT'", "'NOCOMPRESS'", "'NOT'", 
    "'NOTFOUND'", "'NOWAIT'", "'NULL'", "'NUMBER'", "'OF'", "'OFFLINE'", 
    "'ON'", "'ONLINE'", "'OPTION'", "'OR'", "'ORDER'", "'PCTFREE'", "'PRIOR'", 
    "'PRIVILEGES'", "'PUBLIC'", "'RAW'", "'RENAME'", "'RESOURCE'", "'REVOKE'", 
    "'ROW'", "'ROWID'", "'ROWLABEL'", "'ROWNUM'", "'ROWS'", "'SELECT'", 
    "'SESSION'", "'SET'", "'SHARE'", "'SIZE'", "'SMALLINT'", "'SQLBUF'", 
    "'START'", "'SUCCESSFUL'", "'SYNONYM'", "'SYSDATE'", "'TABLE'", "'THEN'", 
    "'TO'", "'TRIGGER'", "'TRUE'", "'UID'", "'UNION'", "'UNIQUE'", "'UPDATE'", 
    "'USER'", "'VALIDATE'", "'VALUES'", "'VARCHAR'", "'VARCHAR2'", "'VIEW'", 
    "'WHENEVER'", "'WHERE'", "'WITH'", "'A'", "'AT'", "'ADMIN'", "'AFTER'", 
    "'ALLOCATE'", "'ANALYZE'", "'ARCHIVE'", "'ARCHIVELOG'", "'AUTHORIZATION'", 
    "'AVG'", "'BACKUP'", "'BECOME'", "'BEFORE'", "'BEGIN'", "'BLOCK'", "'BODY'", 
    "'CACHE'", "'CANCEL'", "'CASCADE'", "'CHANGE'", "'CHARACTER'", "'CHECKPOINT'", 
    "'CLOSE'", "'COBOL'", "'COMMIT'", "'COMPILE'", "'CONSTRAINT'", "'CONSTRAINTS'", 
    "'CONTENTS'", "'CONTINUE'", "'CONTROLFILE'", "'COUNT'", "'CURSOR'", 
    "'CYCLE'", "'DATABASE'", "'DATAFILE'", "'DAY'", "'DBA'", "'DBTIMEZONE'", 
    "'DEC'", "'DECLARE'", "'DISABLE'", "'DISMOUNT'", "'DOUBLE'", "'DUMP'", 
    "'EACH'", "'ENABLE'", "'END'", "'ESCAPE'", "'EVENTS'", "'EXCEPT'", "'EXCEPTIONS'", 
    "'EXEC'", "'EXECUTE'", "'EXPLAIN'", "'EXTENT'", "'EXTERNALLY'", "'FETCH'", 
    "'FLUSH'", "'FORCE'", "'FOREIGN'", "'FORTRAN'", "'FOUND'", "'FREELIST'", 
    "'FREELISTS'", "'FUNCTION'", "'GO'", "'GOTO'", "'GROUPS'", "'INCLUDING'", 
    "'INDICATOR'", "'INITRANS'", "'INSTANCE'", "'INT'", "'KEY'", "'LANGUAGE'", 
    "'LAYER'", "'LINK'", "'LISTS'", "'LOGFILE'", "'LOCAL'", "'LOCKED'", 
    "'MANAGE'", "'MANUAL'", "'MAX'", "'MAXDATAFILES'", "'MAXINSTANCES'", 
    "'MAXLOGFILES'", "'MAXLOGHISTORY'", "'MAXLOGMEMBERS'", "'MAXTRANS'", 
    "'MAXVALUE'", "'MIN'", "'MINEXTENTS'", "'MINVALUE'", "'MODULE'", "'MONTH'", 
    "'MOUNT'", "'NEW'", "'NEXT'", "'NOARCHIVELOG'", "'NOCACHE'", "'NOCYCLE'", 
    "'NOMAXVALUE'", "'NOMINVALUE'", "'NONE'", "'NOORDER'", "'NORESETLOGS'", 
    "'NORMAL'", "'NOSORT'", "'NUMERIC'", "'OFF'", "'OLD'", "'ONLY'", "'OPEN'", 
    "'OPTIMAL'", "'OWN'", "'PACKAGE'", "'PARALLEL'", "'PCTINCREASE'", "'PCTUSED'", 
    "'PLAN'", "'PLI'", "'PRECISION'", "'PRIMARY'", "'PRIVATE'", "'PROCEDURE'", 
    "'PROFILE'", "'QUOTA'", "'READ'", "'REAL'", "'RECOVER'", "'REFERENCES'", 
    "'REFERENCING'", "'RESETLOGS'", "'RESTRICTED'", "'REUSE'", "'ROLE'", 
    "'ROLES'", "'ROLLBACK'", "'SAVEPOINT'", "'SCHEMA'", "'SCN'", "'SECOND'", 
    "'SECTION'", "'SEGMENT'", "'SEQUENCE'", "'SESSIONTIMEZONE'", "'SHARED'", 
    "'SNAPSHOT'", "'SKIP'", "'SOME'", "'SORT'", "'SQL'", "'SQLCODE'", "'SQLERROR'", 
    "'SQLSTATE'", "'STATEMENT'", "'STATISTICS'", "'STOP'", "'STORAGE'", 
    "'SUM'", "'SWITCH'", "'SYSTEM'", "'TABLES'", "'TABLESPACE'", "'TEMPORARY'", 
    "'THREAD'", "'TIME'", "'TRACING'", "'TRANSACTION'", "'TRIGGERS'", "'TRUNCATE'", 
    "'UNDER'", "'UNLIMITED'", "'UNTIL'", "'USE'", "'USING'", "'WAIT'", "'WHEN'", 
    "'WORK'", "'WRITE'", "'YEAR'", "'ZONE'", "'AUTOMATIC'", "'BFILE'", "'BINARY_DOUBLE'", 
    "'BINARY_FLOAT'", "'BINARY_INTEGER'", "'BLOB'", "'BOOLEAN'", "'BYTE'", 
    "'CAST'", "'CLOB'", "'CLUSTER_SET'", "'COLUMN_VALUE'", "'CONNECT_BY_ISCYCLE'", 
    "'CONNECT_BY_ISLEAF'", "'CONNECT_BY_ROOT'", "'CORR'", "'COVAR_POP'", 
    "'COVAR_SAMP'", "'CROSS'", "'CUBE'", "'CUME_DIST'", "'DECREMENT'", "'DENSE_RANK'", 
    "'DIMENSION'", "'EMPTY'", "'EQUALS_PATH'", "'FIRST_VALUE'", "'FULL'", 
    "'GROUPING'", "'IGNORE'", "'INFINITE'", "'INNER'", "'INTERVAL'", "'ITERATE'", 
    "'JOIN'", "'KEEP'", "'LAG'", "'LAST'", "'LAST_VALUE'", "'LEAD'", "'LEFT'", 
    "'MAIN'", "'MEASURES'", "'MEMBER'", "'MLSLABEL'", "'MODEL'", "'MULTISET'", 
    "'NAN'", "'NATIONAL'", "'NATURAL'", "'NAV'", "'NCHAR'", "'NCLOB'", "'NTILE'", 
    "'NULLS'", "'NVARCHAR'", "'NVARCHAR2'", "'OBJECT_VALUE'", "'ORA_ROWSCN'", 
    "'OUTER'", "'OVER'", "'PARTITION'", "'PERCENTILE_CONT'", "'PERCENTILE_DISC'", 
    "'PERCENT_RANK'", "'PIVOT'", "'PLS_INTEGER'", "'POSITIVE'", "'PRESENT'", 
    "'RANK'", "'RATIO_TO_REPORT'", "'REFERENCE'", "'REGEXP_LIKE'", "'REGR_AVGX'", 
    "'REGR_AVGY'", "'REGR_COUNT'", "'REGR_INTERCEPT'", "'REGR_R2'", "'REGR_SLOPE'", 
    "'REGR_SXX'", "'REGR_SXY'", "'REGR_SYY'", "'RIGHT'", "'ROLLUP'", "'ROW_NUMBER'", 
    "'RULES'", "'SAMPLE'", "'SEARCH'", "'SEQUENTIAL'", "'SETS'", "'SINGLE'", 
    "'STDDEV'", "'STDDEV_POP'", "'STDDEV_SAMP'", "'SUBMULTISET'", "'SUBPARTITION'", 
    "'THE'", "'TIMESTAMP'", "'TYPE'", "'UNBOUNDED'", "'UNDER_PATH'", "'UPDATED'", 
    "'UPSERT'", "'UROWID'", "'VARIANCE'", "'VARYING'", "'VAR_POP'", "'VAR_SAMP'", 
    "'VERSIONS_ENDSCN'", "'VERSIONS_ENDTIME'", "'VERSIONS_OPERATION'", "'VERSIONS_STARSCN'", 
    "'VERSIONS_STARTTIME'", "'VERSIONS_XID'", "'XML'", "'XMLDATA'", "'ERRORS'", 
    "'FIRST'", "'LIMIT'", "'LOG'", "'REJECT'", "'RETURN'", "'RETURNING'", 
    "'MERGE'", "'MATCHED'", "'FOLLOWING'", "'RANGE'", "'SIBLINGS'", "'UNPIVOT'", 
    "'VALUE'", "'BREADTH'", "'DEPTH'", "'EXCLUDE'", "'INCLUDE'", "'MIVALUE'", 
    "'PRECEDING'", "'RESPECT'", "'SEED'", "'VERSIONS'", "'DISTANCE'", "'VIDEO_EXTRACTION'", 
    "'EXTRACTION'", "'VIDEO_FEATURE_EXTRACTION'", "'kNN_AVG_DISTANCE'", 
    "'OUTLIER'", "'FARTHEST'", "'FEATURE_DISTANCE'", "'OUTLIER_LINE'", "'OUTLIER_SCORE'", 
    "'VIDEO_SIMILARITY'", "'KNN_AVG_DISTANCE'", "'STATEMENT_ID'"
]




class YSmartParser(Parser):
    grammarFileName = "/home/szr/subquery/SQL2XML/YSmart.g"
    antlr_version = version_str_to_tuple("3.3 Nov 30, 2010 12:45:30")
    antlr_version_str = "3.3 Nov 30, 2010 12:45:30"
    tokenNames = tokenNames

    def __init__(self, input, state=None, *args, **kwargs):
        if state is None:
            state = RecognizerSharedState()

        super(YSmartParser, self).__init__(input, state, *args, **kwargs)

        self._state.ruleMemo = {}
        self.dfa7 = self.DFA7(
            self, 7,
            eot = self.DFA7_eot,
            eof = self.DFA7_eof,
            min = self.DFA7_min,
            max = self.DFA7_max,
            accept = self.DFA7_accept,
            special = self.DFA7_special,
            transition = self.DFA7_transition
            )

        self.dfa11 = self.DFA11(
            self, 11,
            eot = self.DFA11_eot,
            eof = self.DFA11_eof,
            min = self.DFA11_min,
            max = self.DFA11_max,
            accept = self.DFA11_accept,
            special = self.DFA11_special,
            transition = self.DFA11_transition
            )

        self.dfa13 = self.DFA13(
            self, 13,
            eot = self.DFA13_eot,
            eof = self.DFA13_eof,
            min = self.DFA13_min,
            max = self.DFA13_max,
            accept = self.DFA13_accept,
            special = self.DFA13_special,
            transition = self.DFA13_transition
            )

        self.dfa17 = self.DFA17(
            self, 17,
            eot = self.DFA17_eot,
            eof = self.DFA17_eof,
            min = self.DFA17_min,
            max = self.DFA17_max,
            accept = self.DFA17_accept,
            special = self.DFA17_special,
            transition = self.DFA17_transition
            )

        self.dfa21 = self.DFA21(
            self, 21,
            eot = self.DFA21_eot,
            eof = self.DFA21_eof,
            min = self.DFA21_min,
            max = self.DFA21_max,
            accept = self.DFA21_accept,
            special = self.DFA21_special,
            transition = self.DFA21_transition
            )

        self.dfa23 = self.DFA23(
            self, 23,
            eot = self.DFA23_eot,
            eof = self.DFA23_eof,
            min = self.DFA23_min,
            max = self.DFA23_max,
            accept = self.DFA23_accept,
            special = self.DFA23_special,
            transition = self.DFA23_transition
            )

        self.dfa26 = self.DFA26(
            self, 26,
            eot = self.DFA26_eot,
            eof = self.DFA26_eof,
            min = self.DFA26_min,
            max = self.DFA26_max,
            accept = self.DFA26_accept,
            special = self.DFA26_special,
            transition = self.DFA26_transition
            )

        self.dfa27 = self.DFA27(
            self, 27,
            eot = self.DFA27_eot,
            eof = self.DFA27_eof,
            min = self.DFA27_min,
            max = self.DFA27_max,
            accept = self.DFA27_accept,
            special = self.DFA27_special,
            transition = self.DFA27_transition
            )

        self.dfa34 = self.DFA34(
            self, 34,
            eot = self.DFA34_eot,
            eof = self.DFA34_eof,
            min = self.DFA34_min,
            max = self.DFA34_max,
            accept = self.DFA34_accept,
            special = self.DFA34_special,
            transition = self.DFA34_transition
            )

        self.dfa74 = self.DFA74(
            self, 74,
            eot = self.DFA74_eot,
            eof = self.DFA74_eof,
            min = self.DFA74_min,
            max = self.DFA74_max,
            accept = self.DFA74_accept,
            special = self.DFA74_special,
            transition = self.DFA74_transition
            )

        self.dfa79 = self.DFA79(
            self, 79,
            eot = self.DFA79_eot,
            eof = self.DFA79_eof,
            min = self.DFA79_min,
            max = self.DFA79_max,
            accept = self.DFA79_accept,
            special = self.DFA79_special,
            transition = self.DFA79_transition
            )

        self.dfa81 = self.DFA81(
            self, 81,
            eot = self.DFA81_eot,
            eof = self.DFA81_eof,
            min = self.DFA81_min,
            max = self.DFA81_max,
            accept = self.DFA81_accept,
            special = self.DFA81_special,
            transition = self.DFA81_transition
            )

        self.dfa84 = self.DFA84(
            self, 84,
            eot = self.DFA84_eot,
            eof = self.DFA84_eof,
            min = self.DFA84_min,
            max = self.DFA84_max,
            accept = self.DFA84_accept,
            special = self.DFA84_special,
            transition = self.DFA84_transition
            )

        self.dfa86 = self.DFA86(
            self, 86,
            eot = self.DFA86_eot,
            eof = self.DFA86_eof,
            min = self.DFA86_min,
            max = self.DFA86_max,
            accept = self.DFA86_accept,
            special = self.DFA86_special,
            transition = self.DFA86_transition
            )

        self.dfa89 = self.DFA89(
            self, 89,
            eot = self.DFA89_eot,
            eof = self.DFA89_eof,
            min = self.DFA89_min,
            max = self.DFA89_max,
            accept = self.DFA89_accept,
            special = self.DFA89_special,
            transition = self.DFA89_transition
            )

        self.dfa91 = self.DFA91(
            self, 91,
            eot = self.DFA91_eot,
            eof = self.DFA91_eof,
            min = self.DFA91_min,
            max = self.DFA91_max,
            accept = self.DFA91_accept,
            special = self.DFA91_special,
            transition = self.DFA91_transition
            )

        self.dfa105 = self.DFA105(
            self, 105,
            eot = self.DFA105_eot,
            eof = self.DFA105_eof,
            min = self.DFA105_min,
            max = self.DFA105_max,
            accept = self.DFA105_accept,
            special = self.DFA105_special,
            transition = self.DFA105_transition
            )

        self.dfa108 = self.DFA108(
            self, 108,
            eot = self.DFA108_eot,
            eof = self.DFA108_eof,
            min = self.DFA108_min,
            max = self.DFA108_max,
            accept = self.DFA108_accept,
            special = self.DFA108_special,
            transition = self.DFA108_transition
            )

        self.dfa110 = self.DFA110(
            self, 110,
            eot = self.DFA110_eot,
            eof = self.DFA110_eof,
            min = self.DFA110_min,
            max = self.DFA110_max,
            accept = self.DFA110_accept,
            special = self.DFA110_special,
            transition = self.DFA110_transition
            )

        self.dfa112 = self.DFA112(
            self, 112,
            eot = self.DFA112_eot,
            eof = self.DFA112_eof,
            min = self.DFA112_min,
            max = self.DFA112_max,
            accept = self.DFA112_accept,
            special = self.DFA112_special,
            transition = self.DFA112_transition
            )

        self.dfa114 = self.DFA114(
            self, 114,
            eot = self.DFA114_eot,
            eof = self.DFA114_eof,
            min = self.DFA114_min,
            max = self.DFA114_max,
            accept = self.DFA114_accept,
            special = self.DFA114_special,
            transition = self.DFA114_transition
            )

        self.dfa124 = self.DFA124(
            self, 124,
            eot = self.DFA124_eot,
            eof = self.DFA124_eof,
            min = self.DFA124_min,
            max = self.DFA124_max,
            accept = self.DFA124_accept,
            special = self.DFA124_special,
            transition = self.DFA124_transition
            )

        self.dfa122 = self.DFA122(
            self, 122,
            eot = self.DFA122_eot,
            eof = self.DFA122_eof,
            min = self.DFA122_min,
            max = self.DFA122_max,
            accept = self.DFA122_accept,
            special = self.DFA122_special,
            transition = self.DFA122_transition
            )

        self.dfa129 = self.DFA129(
            self, 129,
            eot = self.DFA129_eot,
            eof = self.DFA129_eof,
            min = self.DFA129_min,
            max = self.DFA129_max,
            accept = self.DFA129_accept,
            special = self.DFA129_special,
            transition = self.DFA129_transition
            )

        self.dfa134 = self.DFA134(
            self, 134,
            eot = self.DFA134_eot,
            eof = self.DFA134_eof,
            min = self.DFA134_min,
            max = self.DFA134_max,
            accept = self.DFA134_accept,
            special = self.DFA134_special,
            transition = self.DFA134_transition
            )

        self.dfa159 = self.DFA159(
            self, 159,
            eot = self.DFA159_eot,
            eof = self.DFA159_eof,
            min = self.DFA159_min,
            max = self.DFA159_max,
            accept = self.DFA159_accept,
            special = self.DFA159_special,
            transition = self.DFA159_transition
            )






        self._adaptor = None
        self.adaptor = CommonTreeAdaptor()
                


        
    def getTreeAdaptor(self):
        return self._adaptor

    def setTreeAdaptor(self, adaptor):
        self._adaptor = adaptor

    adaptor = property(getTreeAdaptor, setTreeAdaptor)


    class start_rule_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.start_rule_return, self).__init__()

            self.tree = None




    # $ANTLR start "start_rule"
    # /home/szr/subquery/SQL2XML/YSmart.g:136:1: start_rule : ( select_statement ) SEMI ;
    def start_rule(self, ):

        retval = self.start_rule_return()
        retval.start = self.input.LT(1)
        start_rule_StartIndex = self.input.index()
        root_0 = None

        SEMI2 = None
        select_statement1 = None


        SEMI2_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 1):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:137:2: ( ( select_statement ) SEMI )
                # /home/szr/subquery/SQL2XML/YSmart.g:137:4: ( select_statement ) SEMI
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:137:4: ( select_statement )
                # /home/szr/subquery/SQL2XML/YSmart.g:138:13: select_statement
                pass 
                self._state.following.append(self.FOLLOW_select_statement_in_start_rule473)
                select_statement1 = self.select_statement()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, select_statement1.tree)



                SEMI2=self.match(self.input, SEMI, self.FOLLOW_SEMI_in_start_rule501)
                if self._state.backtracking == 0:

                    SEMI2_tree = self._adaptor.createWithPayload(SEMI2)
                    self._adaptor.addChild(root_0, SEMI2_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 1, start_rule_StartIndex, success)

            pass
        return retval

    # $ANTLR end "start_rule"

    class select_statement_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.select_statement_return, self).__init__()

            self.tree = None




    # $ANTLR start "select_statement"
    # /home/szr/subquery/SQL2XML/YSmart.g:146:1: select_statement : sel= k_select select_list k_from table_reference_list ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? -> ^( 't_select' $sel select_list ^( 't_from' k_from table_reference_list ) ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? ) ;
    def select_statement(self, ):

        retval = self.select_statement_return()
        retval.start = self.input.LT(1)
        select_statement_StartIndex = self.input.index()
        root_0 = None

        sel = None

        select_list3 = None

        k_from4 = None

        table_reference_list5 = None

        where_clause6 = None

        group_by_clause7 = None

        having_clause8 = None

        order_by_clause9 = None

        limit_clause10 = None


        stream_select_list = RewriteRuleSubtreeStream(self._adaptor, "rule select_list")
        stream_where_clause = RewriteRuleSubtreeStream(self._adaptor, "rule where_clause")
        stream_order_by_clause = RewriteRuleSubtreeStream(self._adaptor, "rule order_by_clause")
        stream_k_select = RewriteRuleSubtreeStream(self._adaptor, "rule k_select")
        stream_group_by_clause = RewriteRuleSubtreeStream(self._adaptor, "rule group_by_clause")
        stream_having_clause = RewriteRuleSubtreeStream(self._adaptor, "rule having_clause")
        stream_limit_clause = RewriteRuleSubtreeStream(self._adaptor, "rule limit_clause")
        stream_k_from = RewriteRuleSubtreeStream(self._adaptor, "rule k_from")
        stream_table_reference_list = RewriteRuleSubtreeStream(self._adaptor, "rule table_reference_list")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 2):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:147:2: (sel= k_select select_list k_from table_reference_list ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? -> ^( 't_select' $sel select_list ^( 't_from' k_from table_reference_list ) ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:148:2: sel= k_select select_list k_from table_reference_list ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )?
                pass 
                self._state.following.append(self.FOLLOW_k_select_in_select_statement528)
                sel = self.k_select()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_select.add(sel.tree)
                self._state.following.append(self.FOLLOW_select_list_in_select_statement530)
                select_list3 = self.select_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_select_list.add(select_list3.tree)
                self._state.following.append(self.FOLLOW_k_from_in_select_statement533)
                k_from4 = self.k_from()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_from.add(k_from4.tree)
                self._state.following.append(self.FOLLOW_table_reference_list_in_select_statement535)
                table_reference_list5 = self.table_reference_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_table_reference_list.add(table_reference_list5.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:150:2: ( where_clause )?
                alt1 = 2
                LA1_0 = self.input.LA(1)

                if (LA1_0 == 209) :
                    alt1 = 1
                if alt1 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:150:4: where_clause
                    pass 
                    self._state.following.append(self.FOLLOW_where_clause_in_select_statement548)
                    where_clause6 = self.where_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_where_clause.add(where_clause6.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:151:2: ( group_by_clause )?
                alt2 = 2
                LA2_0 = self.input.LA(1)

                if (LA2_0 == 131) :
                    alt2 = 1
                if alt2 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:151:4: group_by_clause
                    pass 
                    self._state.following.append(self.FOLLOW_group_by_clause_in_select_statement556)
                    group_by_clause7 = self.group_by_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_group_by_clause.add(group_by_clause7.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:152:2: ( having_clause )?
                alt3 = 2
                LA3_0 = self.input.LA(1)

                if (LA3_0 == 132) :
                    alt3 = 1
                if alt3 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:152:4: having_clause
                    pass 
                    self._state.following.append(self.FOLLOW_having_clause_in_select_statement564)
                    having_clause8 = self.having_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_having_clause.add(having_clause8.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:153:2: ( order_by_clause )?
                alt4 = 2
                LA4_0 = self.input.LA(1)

                if (LA4_0 == 168) :
                    alt4 = 1
                if alt4 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:153:4: order_by_clause
                    pass 
                    self._state.following.append(self.FOLLOW_order_by_clause_in_select_statement572)
                    order_by_clause9 = self.order_by_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_order_by_clause.add(order_by_clause9.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:154:2: ( limit_clause )?
                alt5 = 2
                LA5_0 = self.input.LA(1)

                if (LA5_0 == 513) :
                    alt5 = 1
                if alt5 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:154:4: limit_clause
                    pass 
                    self._state.following.append(self.FOLLOW_limit_clause_in_select_statement580)
                    limit_clause10 = self.limit_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_limit_clause.add(limit_clause10.tree)




                # AST Rewrite
                # elements: sel, limit_clause, select_list, T_FROM, having_clause, T_SELECT, order_by_clause, where_clause, group_by_clause, table_reference_list, k_from
                # token labels: 
                # rule labels: sel, retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if sel is not None:
                        stream_sel = RewriteRuleSubtreeStream(self._adaptor, "rule sel", sel.tree)
                    else:
                        stream_sel = RewriteRuleSubtreeStream(self._adaptor, "token sel", None)


                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 155:2: -> ^( 't_select' $sel select_list ^( 't_from' k_from table_reference_list ) ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? )
                    # /home/szr/subquery/SQL2XML/YSmart.g:155:5: ^( 't_select' $sel select_list ^( 't_from' k_from table_reference_list ) ( where_clause )? ( group_by_clause )? ( having_clause )? ( order_by_clause )? ( limit_clause )? )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_SELECT, "T_SELECT"), root_1)

                    self._adaptor.addChild(root_1, stream_sel.nextTree())
                    self._adaptor.addChild(root_1, stream_select_list.nextTree())
                    # /home/szr/subquery/SQL2XML/YSmart.g:158:3: ^( 't_from' k_from table_reference_list )
                    root_2 = self._adaptor.nil()
                    root_2 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_FROM, "T_FROM"), root_2)

                    self._adaptor.addChild(root_2, stream_k_from.nextTree())
                    self._adaptor.addChild(root_2, stream_table_reference_list.nextTree())

                    self._adaptor.addChild(root_1, root_2)
                    # /home/szr/subquery/SQL2XML/YSmart.g:159:3: ( where_clause )?
                    if stream_where_clause.hasNext():
                        self._adaptor.addChild(root_1, stream_where_clause.nextTree())


                    stream_where_clause.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:160:9: ( group_by_clause )?
                    if stream_group_by_clause.hasNext():
                        self._adaptor.addChild(root_1, stream_group_by_clause.nextTree())


                    stream_group_by_clause.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:161:9: ( having_clause )?
                    if stream_having_clause.hasNext():
                        self._adaptor.addChild(root_1, stream_having_clause.nextTree())


                    stream_having_clause.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:162:3: ( order_by_clause )?
                    if stream_order_by_clause.hasNext():
                        self._adaptor.addChild(root_1, stream_order_by_clause.nextTree())


                    stream_order_by_clause.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:163:3: ( limit_clause )?
                    if stream_limit_clause.hasNext():
                        self._adaptor.addChild(root_1, stream_limit_clause.nextTree())


                    stream_limit_clause.reset();

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 2, select_statement_StartIndex, success)

            pass
        return retval

    # $ANTLR end "select_statement"

    class select_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.select_list_return, self).__init__()

            self.tree = None




    # $ANTLR start "select_list"
    # /home/szr/subquery/SQL2XML/YSmart.g:170:1: select_list : displayed_column_part_first ( displayed_column_part_next )* -> ^( 't_column_list' displayed_column_part_first ( displayed_column_part_next )* ) ;
    def select_list(self, ):

        retval = self.select_list_return()
        retval.start = self.input.LT(1)
        select_list_StartIndex = self.input.index()
        root_0 = None

        displayed_column_part_first11 = None

        displayed_column_part_next12 = None


        stream_displayed_column_part_first = RewriteRuleSubtreeStream(self._adaptor, "rule displayed_column_part_first")
        stream_displayed_column_part_next = RewriteRuleSubtreeStream(self._adaptor, "rule displayed_column_part_next")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 3):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:171:2: ( displayed_column_part_first ( displayed_column_part_next )* -> ^( 't_column_list' displayed_column_part_first ( displayed_column_part_next )* ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:171:4: displayed_column_part_first ( displayed_column_part_next )*
                pass 
                self._state.following.append(self.FOLLOW_displayed_column_part_first_in_select_list661)
                displayed_column_part_first11 = self.displayed_column_part_first()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_displayed_column_part_first.add(displayed_column_part_first11.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:171:32: ( displayed_column_part_next )*
                while True: #loop6
                    alt6 = 2
                    LA6_0 = self.input.LA(1)

                    if (LA6_0 == COMMA) :
                        alt6 = 1


                    if alt6 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: displayed_column_part_next
                        pass 
                        self._state.following.append(self.FOLLOW_displayed_column_part_next_in_select_list663)
                        displayed_column_part_next12 = self.displayed_column_part_next()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            stream_displayed_column_part_next.add(displayed_column_part_next12.tree)


                    else:
                        break #loop6

                # AST Rewrite
                # elements: displayed_column_part_first, T_COLUMN_LIST, displayed_column_part_next
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 172:3: -> ^( 't_column_list' displayed_column_part_first ( displayed_column_part_next )* )
                    # /home/szr/subquery/SQL2XML/YSmart.g:172:6: ^( 't_column_list' displayed_column_part_first ( displayed_column_part_next )* )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COLUMN_LIST, "T_COLUMN_LIST"), root_1)

                    self._adaptor.addChild(root_1, stream_displayed_column_part_first.nextTree())
                    # /home/szr/subquery/SQL2XML/YSmart.g:172:52: ( displayed_column_part_next )*
                    while stream_displayed_column_part_next.hasNext():
                        self._adaptor.addChild(root_1, stream_displayed_column_part_next.nextTree())


                    stream_displayed_column_part_next.reset();

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 3, select_list_StartIndex, success)

            pass
        return retval

    # $ANTLR end "select_list"

    class displayed_column_part_first_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.displayed_column_part_first_return, self).__init__()

            self.tree = None




    # $ANTLR start "displayed_column_part_first"
    # /home/szr/subquery/SQL2XML/YSmart.g:174:1: displayed_column_part_first : displayed_column ;
    def displayed_column_part_first(self, ):

        retval = self.displayed_column_part_first_return()
        retval.start = self.input.LT(1)
        displayed_column_part_first_StartIndex = self.input.index()
        root_0 = None

        displayed_column13 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 4):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:175:2: ( displayed_column )
                # /home/szr/subquery/SQL2XML/YSmart.g:175:4: displayed_column
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_displayed_column_in_displayed_column_part_first687)
                displayed_column13 = self.displayed_column()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, displayed_column13.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 4, displayed_column_part_first_StartIndex, success)

            pass
        return retval

    # $ANTLR end "displayed_column_part_first"

    class displayed_column_part_next_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.displayed_column_part_next_return, self).__init__()

            self.tree = None




    # $ANTLR start "displayed_column_part_next"
    # /home/szr/subquery/SQL2XML/YSmart.g:177:1: displayed_column_part_next options {backtrack=false; } : c= COMMA displayed_column ;
    def displayed_column_part_next(self, ):

        retval = self.displayed_column_part_next_return()
        retval.start = self.input.LT(1)
        displayed_column_part_next_StartIndex = self.input.index()
        root_0 = None

        c = None
        displayed_column14 = None


        c_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 5):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:178:2: (c= COMMA displayed_column )
                # /home/szr/subquery/SQL2XML/YSmart.g:178:4: c= COMMA displayed_column
                pass 
                root_0 = self._adaptor.nil()

                c=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_displayed_column_part_next711)
                if self._state.backtracking == 0:

                    c_tree = self._adaptor.createWithPayload(c)
                    self._adaptor.addChild(root_0, c_tree)

                self._state.following.append(self.FOLLOW_displayed_column_in_displayed_column_part_next713)
                displayed_column14 = self.displayed_column()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, displayed_column14.tree)
                if self._state.backtracking == 0:
                    c.setChannel(30) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 5, displayed_column_part_next_StartIndex, success)

            pass
        return retval

    # $ANTLR end "displayed_column_part_next"

    class displayed_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.displayed_column_return, self).__init__()

            self.tree = None




    # $ANTLR start "displayed_column"
    # /home/szr/subquery/SQL2XML/YSmart.g:180:1: displayed_column : (asterisk1= ASTERISK | schema= sql_identifier DOT asterisk2= ASTERISK | sql_expression ) ( alias | alias_name= sql_identifier )? -> ^( 't_select_column' ( $asterisk1)? ( $schema)? ( DOT )? ( $asterisk2)? ( sql_expression )? ( alias )? ( $alias_name)? ) ;
    def displayed_column(self, ):

        retval = self.displayed_column_return()
        retval.start = self.input.LT(1)
        displayed_column_StartIndex = self.input.index()
        root_0 = None

        asterisk1 = None
        asterisk2 = None
        DOT15 = None
        schema = None

        alias_name = None

        sql_expression16 = None

        alias17 = None


        asterisk1_tree = None
        asterisk2_tree = None
        DOT15_tree = None
        stream_DOT = RewriteRuleTokenStream(self._adaptor, "token DOT")
        stream_ASTERISK = RewriteRuleTokenStream(self._adaptor, "token ASTERISK")
        stream_alias = RewriteRuleSubtreeStream(self._adaptor, "rule alias")
        stream_sql_identifier = RewriteRuleSubtreeStream(self._adaptor, "rule sql_identifier")
        stream_sql_expression = RewriteRuleSubtreeStream(self._adaptor, "rule sql_expression")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 6):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:181:2: ( (asterisk1= ASTERISK | schema= sql_identifier DOT asterisk2= ASTERISK | sql_expression ) ( alias | alias_name= sql_identifier )? -> ^( 't_select_column' ( $asterisk1)? ( $schema)? ( DOT )? ( $asterisk2)? ( sql_expression )? ( alias )? ( $alias_name)? ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:181:4: (asterisk1= ASTERISK | schema= sql_identifier DOT asterisk2= ASTERISK | sql_expression ) ( alias | alias_name= sql_identifier )?
                pass 
                # /home/szr/subquery/SQL2XML/YSmart.g:181:4: (asterisk1= ASTERISK | schema= sql_identifier DOT asterisk2= ASTERISK | sql_expression )
                alt7 = 3
                alt7 = self.dfa7.predict(self.input)
                if alt7 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:182:9: asterisk1= ASTERISK
                    pass 
                    asterisk1=self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_displayed_column748) 
                    if self._state.backtracking == 0:
                        stream_ASTERISK.add(asterisk1)


                elif alt7 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:183:5: schema= sql_identifier DOT asterisk2= ASTERISK
                    pass 
                    self._state.following.append(self.FOLLOW_sql_identifier_in_displayed_column756)
                    schema = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_sql_identifier.add(schema.tree)
                    DOT15=self.match(self.input, DOT, self.FOLLOW_DOT_in_displayed_column758) 
                    if self._state.backtracking == 0:
                        stream_DOT.add(DOT15)
                    asterisk2=self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_displayed_column762) 
                    if self._state.backtracking == 0:
                        stream_ASTERISK.add(asterisk2)


                elif alt7 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:184:5: sql_expression
                    pass 
                    self._state.following.append(self.FOLLOW_sql_expression_in_displayed_column768)
                    sql_expression16 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_sql_expression.add(sql_expression16.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:186:3: ( alias | alias_name= sql_identifier )?
                alt8 = 3
                LA8_0 = self.input.LA(1)

                if (LA8_0 == 100) :
                    alt8 = 1
                elif ((VECTOR <= LA8_0 <= DOUBLEQUOTED_STRING) or LA8_0 == 91 or LA8_0 == 178 or LA8_0 == 180 or (211 <= LA8_0 <= 367) or (369 <= LA8_0 <= 387) or (390 <= LA8_0 <= 428) or (430 <= LA8_0 <= 439) or (442 <= LA8_0 <= 453) or LA8_0 == 455 or (460 <= LA8_0 <= 502) or (508 <= LA8_0 <= 528) or (530 <= LA8_0 <= 537) or (539 <= LA8_0 <= 546)) :
                    alt8 = 2
                if alt8 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:186:4: alias
                    pass 
                    self._state.following.append(self.FOLLOW_alias_in_displayed_column780)
                    alias17 = self.alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_alias.add(alias17.tree)


                elif alt8 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:186:10: alias_name= sql_identifier
                    pass 
                    self._state.following.append(self.FOLLOW_sql_identifier_in_displayed_column784)
                    alias_name = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_sql_identifier.add(alias_name.tree)




                # AST Rewrite
                # elements: sql_expression, schema, alias_name, DOT, T_SELECT_COLUMN, asterisk1, asterisk2, alias
                # token labels: asterisk1, asterisk2
                # rule labels: schema, alias_name, retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0
                    stream_asterisk1 = RewriteRuleTokenStream(self._adaptor, "token asterisk1", asterisk1)
                    stream_asterisk2 = RewriteRuleTokenStream(self._adaptor, "token asterisk2", asterisk2)

                    if schema is not None:
                        stream_schema = RewriteRuleSubtreeStream(self._adaptor, "rule schema", schema.tree)
                    else:
                        stream_schema = RewriteRuleSubtreeStream(self._adaptor, "token schema", None)


                    if alias_name is not None:
                        stream_alias_name = RewriteRuleSubtreeStream(self._adaptor, "rule alias_name", alias_name.tree)
                    else:
                        stream_alias_name = RewriteRuleSubtreeStream(self._adaptor, "token alias_name", None)


                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 187:9: -> ^( 't_select_column' ( $asterisk1)? ( $schema)? ( DOT )? ( $asterisk2)? ( sql_expression )? ( alias )? ( $alias_name)? )
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:12: ^( 't_select_column' ( $asterisk1)? ( $schema)? ( DOT )? ( $asterisk2)? ( sql_expression )? ( alias )? ( $alias_name)? )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_SELECT_COLUMN, "T_SELECT_COLUMN"), root_1)

                    # /home/szr/subquery/SQL2XML/YSmart.g:187:32: ( $asterisk1)?
                    if stream_asterisk1.hasNext():
                        self._adaptor.addChild(root_1, stream_asterisk1.nextNode())


                    stream_asterisk1.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:44: ( $schema)?
                    if stream_schema.hasNext():
                        self._adaptor.addChild(root_1, stream_schema.nextTree())


                    stream_schema.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:53: ( DOT )?
                    if stream_DOT.hasNext():
                        self._adaptor.addChild(root_1, stream_DOT.nextNode())


                    stream_DOT.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:58: ( $asterisk2)?
                    if stream_asterisk2.hasNext():
                        self._adaptor.addChild(root_1, stream_asterisk2.nextNode())


                    stream_asterisk2.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:70: ( sql_expression )?
                    if stream_sql_expression.hasNext():
                        self._adaptor.addChild(root_1, stream_sql_expression.nextTree())


                    stream_sql_expression.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:86: ( alias )?
                    if stream_alias.hasNext():
                        self._adaptor.addChild(root_1, stream_alias.nextTree())


                    stream_alias.reset();
                    # /home/szr/subquery/SQL2XML/YSmart.g:187:93: ( $alias_name)?
                    if stream_alias_name.hasNext():
                        self._adaptor.addChild(root_1, stream_alias_name.nextTree())


                    stream_alias_name.reset();

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 6, displayed_column_StartIndex, success)

            pass
        return retval

    # $ANTLR end "displayed_column"

    class sql_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.sql_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "sql_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:189:1: sql_expression : expr_add ;
    def sql_expression(self, ):

        retval = self.sql_expression_return()
        retval.start = self.input.LT(1)
        sql_expression_StartIndex = self.input.index()
        root_0 = None

        expr_add18 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 7):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:190:2: ( expr_add )
                # /home/szr/subquery/SQL2XML/YSmart.g:190:4: expr_add
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_expr_add_in_sql_expression839)
                expr_add18 = self.expr_add()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_add18.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 7, sql_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "sql_expression"

    class expr_add_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_add_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_add"
    # /home/szr/subquery/SQL2XML/YSmart.g:192:1: expr_add : expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )* ;
    def expr_add(self, ):

        retval = self.expr_add_return()
        retval.start = self.input.LT(1)
        expr_add_StartIndex = self.input.index()
        root_0 = None

        set20 = None
        expr_mul19 = None

        expr_mul21 = None


        set20_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 8):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:193:2: ( expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:193:4: expr_mul ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_expr_mul_in_expr_add849)
                expr_mul19 = self.expr_mul()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_mul19.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:193:13: ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )*
                while True: #loop9
                    alt9 = 2
                    LA9_0 = self.input.LA(1)

                    if ((PLUS <= LA9_0 <= DOUBLEVERTBAR)) :
                        LA9_2 = self.input.LA(2)

                        if (self.synpred13_YSmart()) :
                            alt9 = 1




                    if alt9 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:193:15: ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul
                        pass 
                        set20 = self.input.LT(1)
                        if (PLUS <= self.input.LA(1) <= DOUBLEVERTBAR):
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set20))
                            self._state.errorRecovery = False

                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            mse = MismatchedSetException(None, self.input)
                            raise mse


                        self._state.following.append(self.FOLLOW_expr_mul_in_expr_add867)
                        expr_mul21 = self.expr_mul()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_mul21.tree)


                    else:
                        break #loop9



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 8, expr_add_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_add"

    class expr_mul_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_mul_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_mul"
    # /home/szr/subquery/SQL2XML/YSmart.g:195:1: expr_mul : expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )* ;
    def expr_mul(self, ):

        retval = self.expr_mul_return()
        retval.start = self.input.LT(1)
        expr_mul_StartIndex = self.input.index()
        root_0 = None

        set23 = None
        expr_sign22 = None

        expr_sign24 = None


        set23_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 9):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:196:2: ( expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:196:4: expr_sign ( ( ASTERISK | DIVIDE ) expr_sign )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_expr_sign_in_expr_mul880)
                expr_sign22 = self.expr_sign()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_sign22.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:196:14: ( ( ASTERISK | DIVIDE ) expr_sign )*
                while True: #loop10
                    alt10 = 2
                    LA10_0 = self.input.LA(1)

                    if (LA10_0 == ASTERISK or LA10_0 == DIVIDE) :
                        LA10_2 = self.input.LA(2)

                        if (self.synpred15_YSmart()) :
                            alt10 = 1




                    if alt10 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:196:16: ( ASTERISK | DIVIDE ) expr_sign
                        pass 
                        set23 = self.input.LT(1)
                        if self.input.LA(1) == ASTERISK or self.input.LA(1) == DIVIDE:
                            self.input.consume()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set23))
                            self._state.errorRecovery = False

                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            mse = MismatchedSetException(None, self.input)
                            raise mse


                        self._state.following.append(self.FOLLOW_expr_sign_in_expr_mul894)
                        expr_sign24 = self.expr_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_sign24.tree)


                    else:
                        break #loop10



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 9, expr_mul_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_mul"

    class expr_sign_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_sign_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_sign"
    # /home/szr/subquery/SQL2XML/YSmart.g:198:1: expr_sign : ( PLUS | MINUS | k_prior | k_connect_by_root )? expr_pow ;
    def expr_sign(self, ):

        retval = self.expr_sign_return()
        retval.start = self.input.LT(1)
        expr_sign_StartIndex = self.input.index()
        root_0 = None

        PLUS25 = None
        MINUS26 = None
        k_prior27 = None

        k_connect_by_root28 = None

        expr_pow29 = None


        PLUS25_tree = None
        MINUS26_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 10):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:199:2: ( ( PLUS | MINUS | k_prior | k_connect_by_root )? expr_pow )
                # /home/szr/subquery/SQL2XML/YSmart.g:199:4: ( PLUS | MINUS | k_prior | k_connect_by_root )? expr_pow
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:199:4: ( PLUS | MINUS | k_prior | k_connect_by_root )?
                alt11 = 5
                alt11 = self.dfa11.predict(self.input)
                if alt11 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:199:6: PLUS
                    pass 
                    PLUS25=self.match(self.input, PLUS, self.FOLLOW_PLUS_in_expr_sign910)
                    if self._state.backtracking == 0:

                        PLUS25_tree = self._adaptor.createWithPayload(PLUS25)
                        self._adaptor.addChild(root_0, PLUS25_tree)



                elif alt11 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:199:13: MINUS
                    pass 
                    MINUS26=self.match(self.input, MINUS, self.FOLLOW_MINUS_in_expr_sign914)
                    if self._state.backtracking == 0:

                        MINUS26_tree = self._adaptor.createWithPayload(MINUS26)
                        self._adaptor.addChild(root_0, MINUS26_tree)



                elif alt11 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:199:21: k_prior
                    pass 
                    self._state.following.append(self.FOLLOW_k_prior_in_expr_sign918)
                    k_prior27 = self.k_prior()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_prior27.tree)


                elif alt11 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:199:31: k_connect_by_root
                    pass 
                    self._state.following.append(self.FOLLOW_k_connect_by_root_in_expr_sign922)
                    k_connect_by_root28 = self.k_connect_by_root()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_connect_by_root28.tree)



                self._state.following.append(self.FOLLOW_expr_pow_in_expr_sign927)
                expr_pow29 = self.expr_pow()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_pow29.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 10, expr_sign_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_sign"

    class expr_pow_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_pow_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_pow"
    # /home/szr/subquery/SQL2XML/YSmart.g:201:1: expr_pow : expr_expr ( EXPONENT expr_expr )* ;
    def expr_pow(self, ):

        retval = self.expr_pow_return()
        retval.start = self.input.LT(1)
        expr_pow_StartIndex = self.input.index()
        root_0 = None

        EXPONENT31 = None
        expr_expr30 = None

        expr_expr32 = None


        EXPONENT31_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 11):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:202:2: ( expr_expr ( EXPONENT expr_expr )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:202:4: expr_expr ( EXPONENT expr_expr )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_expr_expr_in_expr_pow937)
                expr_expr30 = self.expr_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expr_expr30.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:202:14: ( EXPONENT expr_expr )*
                while True: #loop12
                    alt12 = 2
                    LA12_0 = self.input.LA(1)

                    if (LA12_0 == EXPONENT) :
                        LA12_2 = self.input.LA(2)

                        if (self.synpred20_YSmart()) :
                            alt12 = 1




                    if alt12 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:202:16: EXPONENT expr_expr
                        pass 
                        EXPONENT31=self.match(self.input, EXPONENT, self.FOLLOW_EXPONENT_in_expr_pow941)
                        if self._state.backtracking == 0:

                            EXPONENT31_tree = self._adaptor.createWithPayload(EXPONENT31)
                            self._adaptor.addChild(root_0, EXPONENT31_tree)

                        self._state.following.append(self.FOLLOW_expr_expr_in_expr_pow943)
                        expr_expr32 = self.expr_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expr_expr32.tree)


                    else:
                        break #loop12



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 11, expr_pow_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_pow"

    class expr_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_expr_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_expr"
    # /home/szr/subquery/SQL2XML/YSmart.g:204:1: expr_expr : ( datetime_expression | interval_expression | ( expr_paren )=> expr_paren | ( cast_expression )=> cast_expression | ( function_expression )=> function_expression | ( case_expression )=> case_expression | ( simple_expression )=> simple_expression | ( subquery )=> subquery );
    def expr_expr(self, ):

        retval = self.expr_expr_return()
        retval.start = self.input.LT(1)
        expr_expr_StartIndex = self.input.index()
        root_0 = None

        datetime_expression33 = None

        interval_expression34 = None

        expr_paren35 = None

        cast_expression36 = None

        function_expression37 = None

        case_expression38 = None

        simple_expression39 = None

        subquery40 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 12):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:205:2: ( datetime_expression | interval_expression | ( expr_paren )=> expr_paren | ( cast_expression )=> cast_expression | ( function_expression )=> function_expression | ( case_expression )=> case_expression | ( simple_expression )=> simple_expression | ( subquery )=> subquery )
                alt13 = 8
                alt13 = self.dfa13.predict(self.input)
                if alt13 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:205:4: datetime_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_datetime_expression_in_expr_expr956)
                    datetime_expression33 = self.datetime_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, datetime_expression33.tree)


                elif alt13 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:206:4: interval_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_interval_expression_in_expr_expr961)
                    interval_expression34 = self.interval_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, interval_expression34.tree)


                elif alt13 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:207:4: ( expr_paren )=> expr_paren
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_expr_paren_in_expr_expr982)
                    expr_paren35 = self.expr_paren()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, expr_paren35.tree)


                elif alt13 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:208:4: ( cast_expression )=> cast_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_cast_expression_in_expr_expr994)
                    cast_expression36 = self.cast_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cast_expression36.tree)


                elif alt13 == 5:
                    # /home/szr/subquery/SQL2XML/YSmart.g:209:4: ( function_expression )=> function_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_function_expression_in_expr_expr1007)
                    function_expression37 = self.function_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_expression37.tree)


                elif alt13 == 6:
                    # /home/szr/subquery/SQL2XML/YSmart.g:210:4: ( case_expression )=> case_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_case_expression_in_expr_expr1020)
                    case_expression38 = self.case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, case_expression38.tree)


                elif alt13 == 7:
                    # /home/szr/subquery/SQL2XML/YSmart.g:211:4: ( simple_expression )=> simple_expression
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_simple_expression_in_expr_expr1033)
                    simple_expression39 = self.simple_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_expression39.tree)


                elif alt13 == 8:
                    # /home/szr/subquery/SQL2XML/YSmart.g:212:4: ( subquery )=> subquery
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_subquery_in_expr_expr1046)
                    subquery40 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery40.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 12, expr_expr_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_expr"

    class expr_paren_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expr_paren_return, self).__init__()

            self.tree = None




    # $ANTLR start "expr_paren"
    # /home/szr/subquery/SQL2XML/YSmart.g:214:1: expr_paren : LPAREN nested_expression RPAREN ;
    def expr_paren(self, ):

        retval = self.expr_paren_return()
        retval.start = self.input.LT(1)
        expr_paren_StartIndex = self.input.index()
        root_0 = None

        LPAREN41 = None
        RPAREN43 = None
        nested_expression42 = None


        LPAREN41_tree = None
        RPAREN43_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 13):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:215:2: ( LPAREN nested_expression RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:215:4: LPAREN nested_expression RPAREN
                pass 
                root_0 = self._adaptor.nil()

                LPAREN41=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_expr_paren1056)
                if self._state.backtracking == 0:

                    LPAREN41_tree = self._adaptor.createWithPayload(LPAREN41)
                    self._adaptor.addChild(root_0, LPAREN41_tree)

                self._state.following.append(self.FOLLOW_nested_expression_in_expr_paren1058)
                nested_expression42 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression42.tree)
                RPAREN43=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_expr_paren1060)
                if self._state.backtracking == 0:

                    RPAREN43_tree = self._adaptor.createWithPayload(RPAREN43)
                    self._adaptor.addChild(root_0, RPAREN43_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 13, expr_paren_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expr_paren"

    class nested_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.nested_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "nested_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:217:1: nested_expression : sql_expression ;
    def nested_expression(self, ):

        retval = self.nested_expression_return()
        retval.start = self.input.LT(1)
        nested_expression_StartIndex = self.input.index()
        root_0 = None

        sql_expression44 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 14):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:218:2: ( sql_expression )
                # /home/szr/subquery/SQL2XML/YSmart.g:218:4: sql_expression
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_nested_expression1070)
                sql_expression44 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression44.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 14, nested_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "nested_expression"

    class function_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.function_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "function_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:220:1: function_expression : ( function_name ) LPAREN call_parameters RPAREN ;
    def function_expression(self, ):

        retval = self.function_expression_return()
        retval.start = self.input.LT(1)
        function_expression_StartIndex = self.input.index()
        root_0 = None

        LPAREN46 = None
        RPAREN48 = None
        function_name45 = None

        call_parameters47 = None


        LPAREN46_tree = None
        RPAREN48_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 15):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:221:3: ( ( function_name ) LPAREN call_parameters RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:221:5: ( function_name ) LPAREN call_parameters RPAREN
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:221:5: ( function_name )
                # /home/szr/subquery/SQL2XML/YSmart.g:221:6: function_name
                pass 
                self._state.following.append(self.FOLLOW_function_name_in_function_expression1082)
                function_name45 = self.function_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, function_name45.tree)



                LPAREN46=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_function_expression1085)
                if self._state.backtracking == 0:

                    LPAREN46_tree = self._adaptor.createWithPayload(LPAREN46)
                    self._adaptor.addChild(root_0, LPAREN46_tree)

                self._state.following.append(self.FOLLOW_call_parameters_in_function_expression1087)
                call_parameters47 = self.call_parameters()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, call_parameters47.tree)
                RPAREN48=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_function_expression1089)
                if self._state.backtracking == 0:

                    RPAREN48_tree = self._adaptor.createWithPayload(RPAREN48)
                    self._adaptor.addChild(root_0, RPAREN48_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 15, function_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "function_expression"

    class call_parameters_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.call_parameters_return, self).__init__()

            self.tree = None




    # $ANTLR start "call_parameters"
    # /home/szr/subquery/SQL2XML/YSmart.g:224:1: call_parameters : ( ASTERISK | call_parameter ( COMMA call_parameter )* );
    def call_parameters(self, ):

        retval = self.call_parameters_return()
        retval.start = self.input.LT(1)
        call_parameters_StartIndex = self.input.index()
        root_0 = None

        ASTERISK49 = None
        COMMA51 = None
        call_parameter50 = None

        call_parameter52 = None


        ASTERISK49_tree = None
        COMMA51_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 16):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:225:2: ( ASTERISK | call_parameter ( COMMA call_parameter )* )
                alt15 = 2
                LA15_0 = self.input.LA(1)

                if (LA15_0 == ASTERISK) :
                    alt15 = 1
                elif ((PLUS <= LA15_0 <= MINUS) or LA15_0 == LPAREN or LA15_0 == NUMBER or (VECTOR <= LA15_0 <= DOUBLEQUOTED_STRING) or LA15_0 == QUOTED_STRING or LA15_0 == 91 or LA15_0 == 105 or LA15_0 == 125 or LA15_0 == 144 or LA15_0 == 160 or LA15_0 == 170 or LA15_0 == 178 or LA15_0 == 180 or LA15_0 == 192 or LA15_0 == 197 or (211 <= LA15_0 <= 367) or (369 <= LA15_0 <= 387) or (390 <= LA15_0 <= 428) or (430 <= LA15_0 <= 439) or (442 <= LA15_0 <= 453) or LA15_0 == 455 or (460 <= LA15_0 <= 528) or (530 <= LA15_0 <= 537) or (539 <= LA15_0 <= 546)) :
                    alt15 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 15, 0, self.input)

                    raise nvae

                if alt15 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:225:4: ASTERISK
                    pass 
                    root_0 = self._adaptor.nil()

                    ASTERISK49=self.match(self.input, ASTERISK, self.FOLLOW_ASTERISK_in_call_parameters1100)
                    if self._state.backtracking == 0:

                        ASTERISK49_tree = self._adaptor.createWithPayload(ASTERISK49)
                        self._adaptor.addChild(root_0, ASTERISK49_tree)



                elif alt15 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:226:4: call_parameter ( COMMA call_parameter )*
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_call_parameter_in_call_parameters1105)
                    call_parameter50 = self.call_parameter()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, call_parameter50.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:226:19: ( COMMA call_parameter )*
                    while True: #loop14
                        alt14 = 2
                        LA14_0 = self.input.LA(1)

                        if (LA14_0 == COMMA) :
                            alt14 = 1


                        if alt14 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:226:21: COMMA call_parameter
                            pass 
                            COMMA51=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_call_parameters1109)
                            if self._state.backtracking == 0:

                                COMMA51_tree = self._adaptor.createWithPayload(COMMA51)
                                self._adaptor.addChild(root_0, COMMA51_tree)

                            self._state.following.append(self.FOLLOW_call_parameter_in_call_parameters1111)
                            call_parameter52 = self.call_parameter()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, call_parameter52.tree)


                        else:
                            break #loop14


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 16, call_parameters_StartIndex, success)

            pass
        return retval

    # $ANTLR end "call_parameters"

    class call_parameter_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.call_parameter_return, self).__init__()

            self.tree = None




    # $ANTLR start "call_parameter"
    # /home/szr/subquery/SQL2XML/YSmart.g:228:1: call_parameter : ( parameter_name ARROW )? nested_expression ;
    def call_parameter(self, ):

        retval = self.call_parameter_return()
        retval.start = self.input.LT(1)
        call_parameter_StartIndex = self.input.index()
        root_0 = None

        ARROW54 = None
        parameter_name53 = None

        nested_expression55 = None


        ARROW54_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 17):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:229:2: ( ( parameter_name ARROW )? nested_expression )
                # /home/szr/subquery/SQL2XML/YSmart.g:229:5: ( parameter_name ARROW )? nested_expression
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:229:5: ( parameter_name ARROW )?
                alt16 = 2
                LA16_0 = self.input.LA(1)

                if ((VECTOR <= LA16_0 <= DOUBLEQUOTED_STRING)) :
                    LA16_1 = self.input.LA(2)

                    if (LA16_1 == ARROW) :
                        alt16 = 1
                if alt16 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:229:7: parameter_name ARROW
                    pass 
                    self._state.following.append(self.FOLLOW_parameter_name_in_call_parameter1127)
                    parameter_name53 = self.parameter_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, parameter_name53.tree)
                    ARROW54=self.match(self.input, ARROW, self.FOLLOW_ARROW_in_call_parameter1129)
                    if self._state.backtracking == 0:

                        ARROW54_tree = self._adaptor.createWithPayload(ARROW54)
                        self._adaptor.addChild(root_0, ARROW54_tree)




                self._state.following.append(self.FOLLOW_nested_expression_in_call_parameter1134)
                nested_expression55 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression55.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 17, call_parameter_StartIndex, success)

            pass
        return retval

    # $ANTLR end "call_parameter"

    class parameter_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.parameter_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "parameter_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:231:1: parameter_name : identifier ;
    def parameter_name(self, ):

        retval = self.parameter_name_return()
        retval.start = self.input.LT(1)
        parameter_name_StartIndex = self.input.index()
        root_0 = None

        identifier56 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 18):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:232:2: ( identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:232:4: identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_identifier_in_parameter_name1144)
                identifier56 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier56.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 18, parameter_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "parameter_name"

    class case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.case_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "case_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:234:1: case_expression : k_case ( simple_case_expression | searched_case_expression ) ( else_case_expression )? k_end ;
    def case_expression(self, ):

        retval = self.case_expression_return()
        retval.start = self.input.LT(1)
        case_expression_StartIndex = self.input.index()
        root_0 = None

        k_case57 = None

        simple_case_expression58 = None

        searched_case_expression59 = None

        else_case_expression60 = None

        k_end61 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 19):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:235:2: ( k_case ( simple_case_expression | searched_case_expression ) ( else_case_expression )? k_end )
                # /home/szr/subquery/SQL2XML/YSmart.g:235:4: k_case ( simple_case_expression | searched_case_expression ) ( else_case_expression )? k_end
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_case_in_case_expression1154)
                k_case57 = self.k_case()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_case57.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:235:11: ( simple_case_expression | searched_case_expression )
                alt17 = 2
                alt17 = self.dfa17.predict(self.input)
                if alt17 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:235:13: simple_case_expression
                    pass 
                    self._state.following.append(self.FOLLOW_simple_case_expression_in_case_expression1158)
                    simple_case_expression58 = self.simple_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_case_expression58.tree)


                elif alt17 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:235:38: searched_case_expression
                    pass 
                    self._state.following.append(self.FOLLOW_searched_case_expression_in_case_expression1162)
                    searched_case_expression59 = self.searched_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, searched_case_expression59.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:235:65: ( else_case_expression )?
                alt18 = 2
                LA18_0 = self.input.LA(1)

                if (LA18_0 == 122) :
                    alt18 = 1
                if alt18 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:235:67: else_case_expression
                    pass 
                    self._state.following.append(self.FOLLOW_else_case_expression_in_case_expression1168)
                    else_case_expression60 = self.else_case_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, else_case_expression60.tree)



                self._state.following.append(self.FOLLOW_k_end_in_case_expression1173)
                k_end61 = self.k_end()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_end61.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 19, case_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "case_expression"

    class simple_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.simple_case_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "simple_case_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:237:1: simple_case_expression : nested_expression ( k_when nested_expression k_then nested_expression )+ ;
    def simple_case_expression(self, ):

        retval = self.simple_case_expression_return()
        retval.start = self.input.LT(1)
        simple_case_expression_StartIndex = self.input.index()
        root_0 = None

        nested_expression62 = None

        k_when63 = None

        nested_expression64 = None

        k_then65 = None

        nested_expression66 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 20):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:238:2: ( nested_expression ( k_when nested_expression k_then nested_expression )+ )
                # /home/szr/subquery/SQL2XML/YSmart.g:238:4: nested_expression ( k_when nested_expression k_then nested_expression )+
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression1183)
                nested_expression62 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression62.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:238:22: ( k_when nested_expression k_then nested_expression )+
                cnt19 = 0
                while True: #loop19
                    alt19 = 2
                    LA19_0 = self.input.LA(1)

                    if (LA19_0 == 390) :
                        alt19 = 1


                    if alt19 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:238:24: k_when nested_expression k_then nested_expression
                        pass 
                        self._state.following.append(self.FOLLOW_k_when_in_simple_case_expression1187)
                        k_when63 = self.k_when()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_when63.tree)
                        self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression1189)
                        nested_expression64 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression64.tree)
                        self._state.following.append(self.FOLLOW_k_then_in_simple_case_expression1191)
                        k_then65 = self.k_then()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_then65.tree)
                        self._state.following.append(self.FOLLOW_nested_expression_in_simple_case_expression1193)
                        nested_expression66 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression66.tree)


                    else:
                        if cnt19 >= 1:
                            break #loop19

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        eee = EarlyExitException(19, self.input)
                        raise eee

                    cnt19 += 1



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 20, simple_case_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "simple_case_expression"

    class searched_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.searched_case_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "searched_case_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:240:1: searched_case_expression : ( k_when sql_condition k_then nested_expression )+ ;
    def searched_case_expression(self, ):

        retval = self.searched_case_expression_return()
        retval.start = self.input.LT(1)
        searched_case_expression_StartIndex = self.input.index()
        root_0 = None

        k_when67 = None

        sql_condition68 = None

        k_then69 = None

        nested_expression70 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 21):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:241:2: ( ( k_when sql_condition k_then nested_expression )+ )
                # /home/szr/subquery/SQL2XML/YSmart.g:241:4: ( k_when sql_condition k_then nested_expression )+
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:241:4: ( k_when sql_condition k_then nested_expression )+
                cnt20 = 0
                while True: #loop20
                    alt20 = 2
                    LA20_0 = self.input.LA(1)

                    if (LA20_0 == 390) :
                        alt20 = 1


                    if alt20 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:241:6: k_when sql_condition k_then nested_expression
                        pass 
                        self._state.following.append(self.FOLLOW_k_when_in_searched_case_expression1208)
                        k_when67 = self.k_when()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_when67.tree)
                        self._state.following.append(self.FOLLOW_sql_condition_in_searched_case_expression1210)
                        sql_condition68 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition68.tree)
                        self._state.following.append(self.FOLLOW_k_then_in_searched_case_expression1212)
                        k_then69 = self.k_then()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_then69.tree)
                        self._state.following.append(self.FOLLOW_nested_expression_in_searched_case_expression1214)
                        nested_expression70 = self.nested_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, nested_expression70.tree)


                    else:
                        if cnt20 >= 1:
                            break #loop20

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        eee = EarlyExitException(20, self.input)
                        raise eee

                    cnt20 += 1



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 21, searched_case_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "searched_case_expression"

    class else_case_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.else_case_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "else_case_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:243:1: else_case_expression : k_else nested_expression ;
    def else_case_expression(self, ):

        retval = self.else_case_expression_return()
        retval.start = self.input.LT(1)
        else_case_expression_StartIndex = self.input.index()
        root_0 = None

        k_else71 = None

        nested_expression72 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 22):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:244:2: ( k_else nested_expression )
                # /home/szr/subquery/SQL2XML/YSmart.g:244:4: k_else nested_expression
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_else_in_else_case_expression1227)
                k_else71 = self.k_else()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_else71.tree)
                self._state.following.append(self.FOLLOW_nested_expression_in_else_case_expression1229)
                nested_expression72 = self.nested_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_expression72.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 22, else_case_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "else_case_expression"

    class simple_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.simple_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "simple_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:247:1: simple_expression : ( boolean_literal | k_sql ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR ) | ( column_spec )=> column_spec | quoted_string | NUMBER );
    def simple_expression(self, ):

        retval = self.simple_expression_return()
        retval.start = self.input.LT(1)
        simple_expression_StartIndex = self.input.index()
        root_0 = None

        set75 = None
        NUMBER78 = None
        boolean_literal73 = None

        k_sql74 = None

        column_spec76 = None

        quoted_string77 = None


        set75_tree = None
        NUMBER78_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 23):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:248:2: ( boolean_literal | k_sql ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR ) | ( column_spec )=> column_spec | quoted_string | NUMBER )
                alt21 = 5
                alt21 = self.dfa21.predict(self.input)
                if alt21 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:248:4: boolean_literal
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_boolean_literal_in_simple_expression1240)
                    boolean_literal73 = self.boolean_literal()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, boolean_literal73.tree)


                elif alt21 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:249:4: k_sql ( FOUND_ATTR | NOTFOUND_ATTR | ISOPEN_ATTR | ROWCOUNT_ATTR | BULK_ROWCOUNT_ATTR )
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_sql_in_simple_expression1245)
                    k_sql74 = self.k_sql()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_sql74.tree)
                    set75 = self.input.LT(1)
                    if (FOUND_ATTR <= self.input.LA(1) <= BULK_ROWCOUNT_ATTR):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set75))
                        self._state.errorRecovery = False

                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        mse = MismatchedSetException(None, self.input)
                        raise mse




                elif alt21 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:250:4: ( column_spec )=> column_spec
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_column_spec_in_simple_expression1280)
                    column_spec76 = self.column_spec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_spec76.tree)


                elif alt21 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:251:4: quoted_string
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_quoted_string_in_simple_expression1285)
                    quoted_string77 = self.quoted_string()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, quoted_string77.tree)


                elif alt21 == 5:
                    # /home/szr/subquery/SQL2XML/YSmart.g:252:4: NUMBER
                    pass 
                    root_0 = self._adaptor.nil()

                    NUMBER78=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_simple_expression1290)
                    if self._state.backtracking == 0:

                        NUMBER78_tree = self._adaptor.createWithPayload(NUMBER78)
                        self._adaptor.addChild(root_0, NUMBER78_tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 23, simple_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "simple_expression"

    class subquery_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.subquery_return, self).__init__()

            self.tree = None




    # $ANTLR start "subquery"
    # /home/szr/subquery/SQL2XML/YSmart.g:256:1: subquery : ( LPAREN select_statement RPAREN | LPAREN subquery RPAREN );
    def subquery(self, ):

        retval = self.subquery_return()
        retval.start = self.input.LT(1)
        subquery_StartIndex = self.input.index()
        root_0 = None

        LPAREN79 = None
        RPAREN81 = None
        LPAREN82 = None
        RPAREN84 = None
        select_statement80 = None

        subquery83 = None


        LPAREN79_tree = None
        RPAREN81_tree = None
        LPAREN82_tree = None
        RPAREN84_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 24):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:257:2: ( LPAREN select_statement RPAREN | LPAREN subquery RPAREN )
                alt22 = 2
                LA22_0 = self.input.LA(1)

                if (LA22_0 == LPAREN) :
                    LA22_1 = self.input.LA(2)

                    if (LA22_1 == 182) :
                        alt22 = 1
                    elif (LA22_1 == LPAREN) :
                        alt22 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 22, 1, self.input)

                        raise nvae

                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 22, 0, self.input)

                    raise nvae

                if alt22 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:257:4: LPAREN select_statement RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN79=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_subquery1310)
                    if self._state.backtracking == 0:

                        LPAREN79_tree = self._adaptor.createWithPayload(LPAREN79)
                        self._adaptor.addChild(root_0, LPAREN79_tree)

                    self._state.following.append(self.FOLLOW_select_statement_in_subquery1312)
                    select_statement80 = self.select_statement()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, select_statement80.tree)
                    RPAREN81=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_subquery1314)
                    if self._state.backtracking == 0:

                        RPAREN81_tree = self._adaptor.createWithPayload(RPAREN81)
                        self._adaptor.addChild(root_0, RPAREN81_tree)



                elif alt22 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:258:4: LPAREN subquery RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN82=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_subquery1319)
                    if self._state.backtracking == 0:

                        LPAREN82_tree = self._adaptor.createWithPayload(LPAREN82)
                        self._adaptor.addChild(root_0, LPAREN82_tree)

                    self._state.following.append(self.FOLLOW_subquery_in_subquery1321)
                    subquery83 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery83.tree)
                    RPAREN84=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_subquery1323)
                    if self._state.backtracking == 0:

                        RPAREN84_tree = self._adaptor.createWithPayload(RPAREN84)
                        self._adaptor.addChild(root_0, RPAREN84_tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 24, subquery_StartIndex, success)

            pass
        return retval

    # $ANTLR end "subquery"

    class datetime_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.datetime_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "datetime_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:261:1: datetime_expression : ( function_expression | cast_expression | simple_expression ) k_at ( k_local | k_time k_zone ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression ) ) ;
    def datetime_expression(self, ):

        retval = self.datetime_expression_return()
        retval.start = self.input.LT(1)
        datetime_expression_StartIndex = self.input.index()
        root_0 = None

        function_expression85 = None

        cast_expression86 = None

        simple_expression87 = None

        k_at88 = None

        k_local89 = None

        k_time90 = None

        k_zone91 = None

        quoted_string92 = None

        k_dbtimezone93 = None

        k_sessiontimezone94 = None

        sql_expression95 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 25):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:262:2: ( ( function_expression | cast_expression | simple_expression ) k_at ( k_local | k_time k_zone ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression ) ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:263:9: ( function_expression | cast_expression | simple_expression ) k_at ( k_local | k_time k_zone ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression ) )
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:263:9: ( function_expression | cast_expression | simple_expression )
                alt23 = 3
                alt23 = self.dfa23.predict(self.input)
                if alt23 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:263:11: function_expression
                    pass 
                    self._state.following.append(self.FOLLOW_function_expression_in_datetime_expression1344)
                    function_expression85 = self.function_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_expression85.tree)


                elif alt23 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:263:33: cast_expression
                    pass 
                    self._state.following.append(self.FOLLOW_cast_expression_in_datetime_expression1348)
                    cast_expression86 = self.cast_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cast_expression86.tree)


                elif alt23 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:263:51: simple_expression
                    pass 
                    self._state.following.append(self.FOLLOW_simple_expression_in_datetime_expression1352)
                    simple_expression87 = self.simple_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_expression87.tree)



                self._state.following.append(self.FOLLOW_k_at_in_datetime_expression1364)
                k_at88 = self.k_at()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_at88.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:264:14: ( k_local | k_time k_zone ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression ) )
                alt25 = 2
                LA25_0 = self.input.LA(1)

                if (LA25_0 == 291) :
                    alt25 = 1
                elif (LA25_0 == 379) :
                    alt25 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 25, 0, self.input)

                    raise nvae

                if alt25 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:264:15: k_local
                    pass 
                    self._state.following.append(self.FOLLOW_k_local_in_datetime_expression1367)
                    k_local89 = self.k_local()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_local89.tree)


                elif alt25 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:264:25: k_time k_zone ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression )
                    pass 
                    self._state.following.append(self.FOLLOW_k_time_in_datetime_expression1371)
                    k_time90 = self.k_time()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_time90.tree)
                    self._state.following.append(self.FOLLOW_k_zone_in_datetime_expression1373)
                    k_zone91 = self.k_zone()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_zone91.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:264:39: ( quoted_string | k_dbtimezone | k_sessiontimezone | sql_expression )
                    alt24 = 4
                    LA24_0 = self.input.LA(1)

                    if (LA24_0 == QUOTED_STRING) :
                        LA24_1 = self.input.LA(2)

                        if (self.synpred48_YSmart()) :
                            alt24 = 1
                        elif (True) :
                            alt24 = 4
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 24, 1, self.input)

                            raise nvae

                    elif (LA24_0 == 249) :
                        LA24_2 = self.input.LA(2)

                        if (self.synpred49_YSmart()) :
                            alt24 = 2
                        elif (True) :
                            alt24 = 4
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 24, 2, self.input)

                            raise nvae

                    elif (LA24_0 == 358) :
                        LA24_3 = self.input.LA(2)

                        if (self.synpred50_YSmart()) :
                            alt24 = 3
                        elif (True) :
                            alt24 = 4
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 24, 3, self.input)

                            raise nvae

                    elif ((PLUS <= LA24_0 <= MINUS) or LA24_0 == LPAREN or LA24_0 == NUMBER or (VECTOR <= LA24_0 <= DOUBLEQUOTED_STRING) or LA24_0 == 91 or LA24_0 == 105 or LA24_0 == 125 or LA24_0 == 144 or LA24_0 == 160 or LA24_0 == 170 or LA24_0 == 178 or LA24_0 == 180 or LA24_0 == 192 or LA24_0 == 197 or (211 <= LA24_0 <= 248) or (250 <= LA24_0 <= 357) or (359 <= LA24_0 <= 367) or (369 <= LA24_0 <= 387) or (390 <= LA24_0 <= 428) or (430 <= LA24_0 <= 439) or (442 <= LA24_0 <= 453) or LA24_0 == 455 or (460 <= LA24_0 <= 528) or (530 <= LA24_0 <= 537) or (539 <= LA24_0 <= 546)) :
                        alt24 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 24, 0, self.input)

                        raise nvae

                    if alt24 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:264:41: quoted_string
                        pass 
                        self._state.following.append(self.FOLLOW_quoted_string_in_datetime_expression1377)
                        quoted_string92 = self.quoted_string()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, quoted_string92.tree)


                    elif alt24 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:264:57: k_dbtimezone
                        pass 
                        self._state.following.append(self.FOLLOW_k_dbtimezone_in_datetime_expression1381)
                        k_dbtimezone93 = self.k_dbtimezone()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_dbtimezone93.tree)


                    elif alt24 == 3:
                        # /home/szr/subquery/SQL2XML/YSmart.g:264:72: k_sessiontimezone
                        pass 
                        self._state.following.append(self.FOLLOW_k_sessiontimezone_in_datetime_expression1385)
                        k_sessiontimezone94 = self.k_sessiontimezone()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_sessiontimezone94.tree)


                    elif alt24 == 4:
                        # /home/szr/subquery/SQL2XML/YSmart.g:264:92: sql_expression
                        pass 
                        self._state.following.append(self.FOLLOW_sql_expression_in_datetime_expression1389)
                        sql_expression95 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression95.tree)









                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 25, datetime_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "datetime_expression"

    class interval_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.interval_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "interval_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:266:1: interval_expression : LPAREN ( function_expression | cast_expression | simple_expression ) MINUS ( function_expression | cast_expression | simple_expression ) RPAREN ( k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_year ( LPAREN NUMBER RPAREN )? k_to k_month ( LPAREN NUMBER RPAREN )? ) ;
    def interval_expression(self, ):

        retval = self.interval_expression_return()
        retval.start = self.input.LT(1)
        interval_expression_StartIndex = self.input.index()
        root_0 = None

        LPAREN96 = None
        MINUS100 = None
        RPAREN104 = None
        LPAREN106 = None
        NUMBER107 = None
        RPAREN108 = None
        LPAREN111 = None
        NUMBER112 = None
        RPAREN113 = None
        LPAREN115 = None
        NUMBER116 = None
        RPAREN117 = None
        LPAREN120 = None
        NUMBER121 = None
        RPAREN122 = None
        function_expression97 = None

        cast_expression98 = None

        simple_expression99 = None

        function_expression101 = None

        cast_expression102 = None

        simple_expression103 = None

        k_day105 = None

        k_to109 = None

        k_second110 = None

        k_year114 = None

        k_to118 = None

        k_month119 = None


        LPAREN96_tree = None
        MINUS100_tree = None
        RPAREN104_tree = None
        LPAREN106_tree = None
        NUMBER107_tree = None
        RPAREN108_tree = None
        LPAREN111_tree = None
        NUMBER112_tree = None
        RPAREN113_tree = None
        LPAREN115_tree = None
        NUMBER116_tree = None
        RPAREN117_tree = None
        LPAREN120_tree = None
        NUMBER121_tree = None
        RPAREN122_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 26):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:267:2: ( LPAREN ( function_expression | cast_expression | simple_expression ) MINUS ( function_expression | cast_expression | simple_expression ) RPAREN ( k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_year ( LPAREN NUMBER RPAREN )? k_to k_month ( LPAREN NUMBER RPAREN )? ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:268:3: LPAREN ( function_expression | cast_expression | simple_expression ) MINUS ( function_expression | cast_expression | simple_expression ) RPAREN ( k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_year ( LPAREN NUMBER RPAREN )? k_to k_month ( LPAREN NUMBER RPAREN )? )
                pass 
                root_0 = self._adaptor.nil()

                LPAREN96=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression1403)
                if self._state.backtracking == 0:

                    LPAREN96_tree = self._adaptor.createWithPayload(LPAREN96)
                    self._adaptor.addChild(root_0, LPAREN96_tree)

                # /home/szr/subquery/SQL2XML/YSmart.g:268:10: ( function_expression | cast_expression | simple_expression )
                alt26 = 3
                alt26 = self.dfa26.predict(self.input)
                if alt26 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:12: function_expression
                    pass 
                    self._state.following.append(self.FOLLOW_function_expression_in_interval_expression1407)
                    function_expression97 = self.function_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_expression97.tree)


                elif alt26 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:34: cast_expression
                    pass 
                    self._state.following.append(self.FOLLOW_cast_expression_in_interval_expression1411)
                    cast_expression98 = self.cast_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cast_expression98.tree)


                elif alt26 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:52: simple_expression
                    pass 
                    self._state.following.append(self.FOLLOW_simple_expression_in_interval_expression1415)
                    simple_expression99 = self.simple_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_expression99.tree)



                MINUS100=self.match(self.input, MINUS, self.FOLLOW_MINUS_in_interval_expression1419)
                if self._state.backtracking == 0:

                    MINUS100_tree = self._adaptor.createWithPayload(MINUS100)
                    self._adaptor.addChild(root_0, MINUS100_tree)

                # /home/szr/subquery/SQL2XML/YSmart.g:268:78: ( function_expression | cast_expression | simple_expression )
                alt27 = 3
                alt27 = self.dfa27.predict(self.input)
                if alt27 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:80: function_expression
                    pass 
                    self._state.following.append(self.FOLLOW_function_expression_in_interval_expression1423)
                    function_expression101 = self.function_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, function_expression101.tree)


                elif alt27 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:102: cast_expression
                    pass 
                    self._state.following.append(self.FOLLOW_cast_expression_in_interval_expression1427)
                    cast_expression102 = self.cast_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, cast_expression102.tree)


                elif alt27 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:268:120: simple_expression
                    pass 
                    self._state.following.append(self.FOLLOW_simple_expression_in_interval_expression1431)
                    simple_expression103 = self.simple_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, simple_expression103.tree)



                RPAREN104=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression1435)
                if self._state.backtracking == 0:

                    RPAREN104_tree = self._adaptor.createWithPayload(RPAREN104)
                    self._adaptor.addChild(root_0, RPAREN104_tree)

                # /home/szr/subquery/SQL2XML/YSmart.g:269:3: ( k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_year ( LPAREN NUMBER RPAREN )? k_to k_month ( LPAREN NUMBER RPAREN )? )
                alt32 = 2
                LA32_0 = self.input.LA(1)

                if (LA32_0 == 247) :
                    alt32 = 1
                elif (LA32_0 == 393) :
                    alt32 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 32, 0, self.input)

                    raise nvae

                if alt32 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:269:5: k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )?
                    pass 
                    self._state.following.append(self.FOLLOW_k_day_in_interval_expression1441)
                    k_day105 = self.k_day()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_day105.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:269:11: ( LPAREN NUMBER RPAREN )?
                    alt28 = 2
                    LA28_0 = self.input.LA(1)

                    if (LA28_0 == LPAREN) :
                        alt28 = 1
                    if alt28 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:269:12: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN106=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression1444)
                        if self._state.backtracking == 0:

                            LPAREN106_tree = self._adaptor.createWithPayload(LPAREN106)
                            self._adaptor.addChild(root_0, LPAREN106_tree)

                        NUMBER107=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_interval_expression1446)
                        if self._state.backtracking == 0:

                            NUMBER107_tree = self._adaptor.createWithPayload(NUMBER107)
                            self._adaptor.addChild(root_0, NUMBER107_tree)

                        RPAREN108=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression1448)
                        if self._state.backtracking == 0:

                            RPAREN108_tree = self._adaptor.createWithPayload(RPAREN108)
                            self._adaptor.addChild(root_0, RPAREN108_tree)




                    self._state.following.append(self.FOLLOW_k_to_in_interval_expression1452)
                    k_to109 = self.k_to()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_to109.tree)
                    self._state.following.append(self.FOLLOW_k_second_in_interval_expression1454)
                    k_second110 = self.k_second()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_second110.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:269:49: ( LPAREN NUMBER RPAREN )?
                    alt29 = 2
                    LA29_0 = self.input.LA(1)

                    if (LA29_0 == LPAREN) :
                        LA29_1 = self.input.LA(2)

                        if (LA29_1 == NUMBER) :
                            alt29 = 1
                    if alt29 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:269:50: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN111=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression1457)
                        if self._state.backtracking == 0:

                            LPAREN111_tree = self._adaptor.createWithPayload(LPAREN111)
                            self._adaptor.addChild(root_0, LPAREN111_tree)

                        NUMBER112=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_interval_expression1459)
                        if self._state.backtracking == 0:

                            NUMBER112_tree = self._adaptor.createWithPayload(NUMBER112)
                            self._adaptor.addChild(root_0, NUMBER112_tree)

                        RPAREN113=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression1461)
                        if self._state.backtracking == 0:

                            RPAREN113_tree = self._adaptor.createWithPayload(RPAREN113)
                            self._adaptor.addChild(root_0, RPAREN113_tree)






                elif alt32 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:270:5: k_year ( LPAREN NUMBER RPAREN )? k_to k_month ( LPAREN NUMBER RPAREN )?
                    pass 
                    self._state.following.append(self.FOLLOW_k_year_in_interval_expression1469)
                    k_year114 = self.k_year()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_year114.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:270:12: ( LPAREN NUMBER RPAREN )?
                    alt30 = 2
                    LA30_0 = self.input.LA(1)

                    if (LA30_0 == LPAREN) :
                        alt30 = 1
                    if alt30 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:270:13: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN115=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression1472)
                        if self._state.backtracking == 0:

                            LPAREN115_tree = self._adaptor.createWithPayload(LPAREN115)
                            self._adaptor.addChild(root_0, LPAREN115_tree)

                        NUMBER116=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_interval_expression1474)
                        if self._state.backtracking == 0:

                            NUMBER116_tree = self._adaptor.createWithPayload(NUMBER116)
                            self._adaptor.addChild(root_0, NUMBER116_tree)

                        RPAREN117=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression1476)
                        if self._state.backtracking == 0:

                            RPAREN117_tree = self._adaptor.createWithPayload(RPAREN117)
                            self._adaptor.addChild(root_0, RPAREN117_tree)




                    self._state.following.append(self.FOLLOW_k_to_in_interval_expression1480)
                    k_to118 = self.k_to()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_to118.tree)
                    self._state.following.append(self.FOLLOW_k_month_in_interval_expression1482)
                    k_month119 = self.k_month()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_month119.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:270:49: ( LPAREN NUMBER RPAREN )?
                    alt31 = 2
                    LA31_0 = self.input.LA(1)

                    if (LA31_0 == LPAREN) :
                        LA31_1 = self.input.LA(2)

                        if (LA31_1 == NUMBER) :
                            alt31 = 1
                    if alt31 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:270:50: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN120=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_interval_expression1485)
                        if self._state.backtracking == 0:

                            LPAREN120_tree = self._adaptor.createWithPayload(LPAREN120)
                            self._adaptor.addChild(root_0, LPAREN120_tree)

                        NUMBER121=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_interval_expression1487)
                        if self._state.backtracking == 0:

                            NUMBER121_tree = self._adaptor.createWithPayload(NUMBER121)
                            self._adaptor.addChild(root_0, NUMBER121_tree)

                        RPAREN122=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_interval_expression1489)
                        if self._state.backtracking == 0:

                            RPAREN122_tree = self._adaptor.createWithPayload(RPAREN122)
                            self._adaptor.addChild(root_0, RPAREN122_tree)










                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 26, interval_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "interval_expression"

    class cast_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.cast_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "cast_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:276:1: cast_expression : k_cast LPAREN ( sql_expression | k_multiset subquery ) k_as ( datatype | sql_identifier ) RPAREN ;
    def cast_expression(self, ):

        retval = self.cast_expression_return()
        retval.start = self.input.LT(1)
        cast_expression_StartIndex = self.input.index()
        root_0 = None

        LPAREN124 = None
        RPAREN131 = None
        k_cast123 = None

        sql_expression125 = None

        k_multiset126 = None

        subquery127 = None

        k_as128 = None

        datatype129 = None

        sql_identifier130 = None


        LPAREN124_tree = None
        RPAREN131_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 27):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:277:2: ( k_cast LPAREN ( sql_expression | k_multiset subquery ) k_as ( datatype | sql_identifier ) RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:277:4: k_cast LPAREN ( sql_expression | k_multiset subquery ) k_as ( datatype | sql_identifier ) RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_cast_in_cast_expression1507)
                k_cast123 = self.k_cast()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_cast123.tree)
                LPAREN124=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_cast_expression1509)
                if self._state.backtracking == 0:

                    LPAREN124_tree = self._adaptor.createWithPayload(LPAREN124)
                    self._adaptor.addChild(root_0, LPAREN124_tree)

                # /home/szr/subquery/SQL2XML/YSmart.g:277:18: ( sql_expression | k_multiset subquery )
                alt33 = 2
                LA33_0 = self.input.LA(1)

                if ((PLUS <= LA33_0 <= MINUS) or LA33_0 == LPAREN or LA33_0 == NUMBER or (VECTOR <= LA33_0 <= DOUBLEQUOTED_STRING) or LA33_0 == QUOTED_STRING or LA33_0 == 91 or LA33_0 == 105 or LA33_0 == 125 or LA33_0 == 144 or LA33_0 == 160 or LA33_0 == 170 or LA33_0 == 178 or LA33_0 == 180 or LA33_0 == 192 or LA33_0 == 197 or (211 <= LA33_0 <= 367) or (369 <= LA33_0 <= 387) or (390 <= LA33_0 <= 428) or (430 <= LA33_0 <= 439) or (442 <= LA33_0 <= 453) or LA33_0 == 455 or (460 <= LA33_0 <= 528) or (530 <= LA33_0 <= 537) or (539 <= LA33_0 <= 546)) :
                    alt33 = 1
                elif (LA33_0 == 441) :
                    alt33 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 33, 0, self.input)

                    raise nvae

                if alt33 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:277:19: sql_expression
                    pass 
                    self._state.following.append(self.FOLLOW_sql_expression_in_cast_expression1512)
                    sql_expression125 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression125.tree)


                elif alt33 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:277:36: k_multiset subquery
                    pass 
                    self._state.following.append(self.FOLLOW_k_multiset_in_cast_expression1516)
                    k_multiset126 = self.k_multiset()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_multiset126.tree)
                    self._state.following.append(self.FOLLOW_subquery_in_cast_expression1518)
                    subquery127 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery127.tree)



                self._state.following.append(self.FOLLOW_k_as_in_cast_expression1521)
                k_as128 = self.k_as()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_as128.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:277:62: ( datatype | sql_identifier )
                alt34 = 2
                alt34 = self.dfa34.predict(self.input)
                if alt34 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:277:63: datatype
                    pass 
                    self._state.following.append(self.FOLLOW_datatype_in_cast_expression1524)
                    datatype129 = self.datatype()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, datatype129.tree)


                elif alt34 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:277:72: sql_identifier
                    pass 
                    self._state.following.append(self.FOLLOW_sql_identifier_in_cast_expression1526)
                    sql_identifier130 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier130.tree)



                RPAREN131=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_cast_expression1529)
                if self._state.backtracking == 0:

                    RPAREN131_tree = self._adaptor.createWithPayload(RPAREN131)
                    self._adaptor.addChild(root_0, RPAREN131_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 27, cast_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "cast_expression"

    class datatype_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.datatype_return, self).__init__()

            self.tree = None




    # $ANTLR start "datatype"
    # /home/szr/subquery/SQL2XML/YSmart.g:279:1: datatype : ( k_binary_integer | k_binary_float | k_binary_double | k_natural | k_positive | ( k_number | k_numeric | k_decimal | k_dec ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )? | k_long ( k_raw )? ( LPAREN NUMBER RPAREN )? | k_raw ( LPAREN NUMBER RPAREN )? | k_boolean | k_date | k_interval k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_interval k_year ( LPAREN NUMBER RPAREN )? k_to k_month | ( k_time | k_timestamp ) ( LPAREN NUMBER RPAREN )? ( k_with ( k_local )? k_time k_zone )? | k_integer | k_int | k_smallint | k_float ( LPAREN NUMBER RPAREN )? | k_real | k_double k_precision | k_char ( k_varying )? ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_varchar ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_varchar2 ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_character ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_nchar ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_nvarchar ( LPAREN NUMBER RPAREN )? | k_nvarchar2 ( LPAREN NUMBER RPAREN )? | k_national ( k_character | k_char ) ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_mlslabel | k_pls_integer | k_blob | k_clob ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_nclob | k_bfile | k_rowid | k_urowid ( LPAREN NUMBER RPAREN )? );
    def datatype(self, ):

        retval = self.datatype_return()
        retval.start = self.input.LT(1)
        datatype_StartIndex = self.input.index()
        root_0 = None

        LPAREN141 = None
        NUMBER142 = None
        COMMA143 = None
        NUMBER144 = None
        RPAREN145 = None
        LPAREN148 = None
        NUMBER149 = None
        RPAREN150 = None
        LPAREN152 = None
        NUMBER153 = None
        RPAREN154 = None
        LPAREN159 = None
        NUMBER160 = None
        RPAREN161 = None
        LPAREN164 = None
        NUMBER165 = None
        RPAREN166 = None
        LPAREN169 = None
        NUMBER170 = None
        RPAREN171 = None
        LPAREN176 = None
        NUMBER177 = None
        RPAREN178 = None
        LPAREN187 = None
        NUMBER188 = None
        RPAREN189 = None
        LPAREN195 = None
        NUMBER196 = None
        RPAREN199 = None
        CHARSET_ATTR204 = None
        LPAREN206 = None
        NUMBER207 = None
        RPAREN210 = None
        CHARSET_ATTR215 = None
        LPAREN217 = None
        NUMBER218 = None
        RPAREN221 = None
        CHARSET_ATTR226 = None
        LPAREN229 = None
        NUMBER230 = None
        RPAREN231 = None
        LPAREN234 = None
        NUMBER235 = None
        RPAREN236 = None
        LPAREN238 = None
        NUMBER239 = None
        RPAREN240 = None
        LPAREN242 = None
        NUMBER243 = None
        RPAREN244 = None
        LPAREN249 = None
        NUMBER250 = None
        RPAREN251 = None
        CHARSET_ATTR260 = None
        LPAREN265 = None
        NUMBER266 = None
        RPAREN267 = None
        k_binary_integer132 = None

        k_binary_float133 = None

        k_binary_double134 = None

        k_natural135 = None

        k_positive136 = None

        k_number137 = None

        k_numeric138 = None

        k_decimal139 = None

        k_dec140 = None

        k_long146 = None

        k_raw147 = None

        k_raw151 = None

        k_boolean155 = None

        k_date156 = None

        k_interval157 = None

        k_day158 = None

        k_to162 = None

        k_second163 = None

        k_interval167 = None

        k_year168 = None

        k_to172 = None

        k_month173 = None

        k_time174 = None

        k_timestamp175 = None

        k_with179 = None

        k_local180 = None

        k_time181 = None

        k_zone182 = None

        k_integer183 = None

        k_int184 = None

        k_smallint185 = None

        k_float186 = None

        k_real190 = None

        k_double191 = None

        k_precision192 = None

        k_char193 = None

        k_varying194 = None

        k_byte197 = None

        k_char198 = None

        k_character200 = None

        k_set201 = None

        identifier202 = None

        column_spec203 = None

        k_varchar205 = None

        k_byte208 = None

        k_char209 = None

        k_character211 = None

        k_set212 = None

        identifier213 = None

        column_spec214 = None

        k_varchar2216 = None

        k_byte219 = None

        k_char220 = None

        k_character222 = None

        k_set223 = None

        identifier224 = None

        column_spec225 = None

        k_character227 = None

        k_varying228 = None

        k_nchar232 = None

        k_varying233 = None

        k_nvarchar237 = None

        k_nvarchar2241 = None

        k_national245 = None

        k_character246 = None

        k_char247 = None

        k_varying248 = None

        k_mlslabel252 = None

        k_pls_integer253 = None

        k_blob254 = None

        k_clob255 = None

        k_character256 = None

        k_set257 = None

        identifier258 = None

        column_spec259 = None

        k_nclob261 = None

        k_bfile262 = None

        k_rowid263 = None

        k_urowid264 = None


        LPAREN141_tree = None
        NUMBER142_tree = None
        COMMA143_tree = None
        NUMBER144_tree = None
        RPAREN145_tree = None
        LPAREN148_tree = None
        NUMBER149_tree = None
        RPAREN150_tree = None
        LPAREN152_tree = None
        NUMBER153_tree = None
        RPAREN154_tree = None
        LPAREN159_tree = None
        NUMBER160_tree = None
        RPAREN161_tree = None
        LPAREN164_tree = None
        NUMBER165_tree = None
        RPAREN166_tree = None
        LPAREN169_tree = None
        NUMBER170_tree = None
        RPAREN171_tree = None
        LPAREN176_tree = None
        NUMBER177_tree = None
        RPAREN178_tree = None
        LPAREN187_tree = None
        NUMBER188_tree = None
        RPAREN189_tree = None
        LPAREN195_tree = None
        NUMBER196_tree = None
        RPAREN199_tree = None
        CHARSET_ATTR204_tree = None
        LPAREN206_tree = None
        NUMBER207_tree = None
        RPAREN210_tree = None
        CHARSET_ATTR215_tree = None
        LPAREN217_tree = None
        NUMBER218_tree = None
        RPAREN221_tree = None
        CHARSET_ATTR226_tree = None
        LPAREN229_tree = None
        NUMBER230_tree = None
        RPAREN231_tree = None
        LPAREN234_tree = None
        NUMBER235_tree = None
        RPAREN236_tree = None
        LPAREN238_tree = None
        NUMBER239_tree = None
        RPAREN240_tree = None
        LPAREN242_tree = None
        NUMBER243_tree = None
        RPAREN244_tree = None
        LPAREN249_tree = None
        NUMBER250_tree = None
        RPAREN251_tree = None
        CHARSET_ATTR260_tree = None
        LPAREN265_tree = None
        NUMBER266_tree = None
        RPAREN267_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 28):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:280:2: ( k_binary_integer | k_binary_float | k_binary_double | k_natural | k_positive | ( k_number | k_numeric | k_decimal | k_dec ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )? | k_long ( k_raw )? ( LPAREN NUMBER RPAREN )? | k_raw ( LPAREN NUMBER RPAREN )? | k_boolean | k_date | k_interval k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )? | k_interval k_year ( LPAREN NUMBER RPAREN )? k_to k_month | ( k_time | k_timestamp ) ( LPAREN NUMBER RPAREN )? ( k_with ( k_local )? k_time k_zone )? | k_integer | k_int | k_smallint | k_float ( LPAREN NUMBER RPAREN )? | k_real | k_double k_precision | k_char ( k_varying )? ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_varchar ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_varchar2 ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_character ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_nchar ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_nvarchar ( LPAREN NUMBER RPAREN )? | k_nvarchar2 ( LPAREN NUMBER RPAREN )? | k_national ( k_character | k_char ) ( k_varying )? ( LPAREN NUMBER RPAREN )? | k_mlslabel | k_pls_integer | k_blob | k_clob ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )? | k_nclob | k_bfile | k_rowid | k_urowid ( LPAREN NUMBER RPAREN )? )
                alt74 = 35
                alt74 = self.dfa74.predict(self.input)
                if alt74 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:280:4: k_binary_integer
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_binary_integer_in_datatype1540)
                    k_binary_integer132 = self.k_binary_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_binary_integer132.tree)


                elif alt74 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:281:4: k_binary_float
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_binary_float_in_datatype1546)
                    k_binary_float133 = self.k_binary_float()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_binary_float133.tree)


                elif alt74 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:282:4: k_binary_double
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_binary_double_in_datatype1551)
                    k_binary_double134 = self.k_binary_double()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_binary_double134.tree)


                elif alt74 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:283:4: k_natural
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_natural_in_datatype1556)
                    k_natural135 = self.k_natural()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_natural135.tree)


                elif alt74 == 5:
                    # /home/szr/subquery/SQL2XML/YSmart.g:284:4: k_positive
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_positive_in_datatype1561)
                    k_positive136 = self.k_positive()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_positive136.tree)


                elif alt74 == 6:
                    # /home/szr/subquery/SQL2XML/YSmart.g:285:4: ( k_number | k_numeric | k_decimal | k_dec ) ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:285:4: ( k_number | k_numeric | k_decimal | k_dec )
                    alt35 = 4
                    LA35 = self.input.LA(1)
                    if LA35 == 161:
                        alt35 = 1
                    elif LA35 == 321:
                        alt35 = 2
                    elif LA35 == 116:
                        alt35 = 3
                    elif LA35 == 250:
                        alt35 = 4
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 35, 0, self.input)

                        raise nvae

                    if alt35 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:285:6: k_number
                        pass 
                        self._state.following.append(self.FOLLOW_k_number_in_datatype1568)
                        k_number137 = self.k_number()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_number137.tree)


                    elif alt35 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:285:17: k_numeric
                        pass 
                        self._state.following.append(self.FOLLOW_k_numeric_in_datatype1572)
                        k_numeric138 = self.k_numeric()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_numeric138.tree)


                    elif alt35 == 3:
                        # /home/szr/subquery/SQL2XML/YSmart.g:285:29: k_decimal
                        pass 
                        self._state.following.append(self.FOLLOW_k_decimal_in_datatype1576)
                        k_decimal139 = self.k_decimal()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_decimal139.tree)


                    elif alt35 == 4:
                        # /home/szr/subquery/SQL2XML/YSmart.g:285:41: k_dec
                        pass 
                        self._state.following.append(self.FOLLOW_k_dec_in_datatype1580)
                        k_dec140 = self.k_dec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_dec140.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:285:49: ( LPAREN NUMBER ( COMMA NUMBER )? RPAREN )?
                    alt37 = 2
                    LA37_0 = self.input.LA(1)

                    if (LA37_0 == LPAREN) :
                        alt37 = 1
                    if alt37 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:285:51: LPAREN NUMBER ( COMMA NUMBER )? RPAREN
                        pass 
                        LPAREN141=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1586)
                        if self._state.backtracking == 0:

                            LPAREN141_tree = self._adaptor.createWithPayload(LPAREN141)
                            self._adaptor.addChild(root_0, LPAREN141_tree)

                        NUMBER142=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1588)
                        if self._state.backtracking == 0:

                            NUMBER142_tree = self._adaptor.createWithPayload(NUMBER142)
                            self._adaptor.addChild(root_0, NUMBER142_tree)

                        # /home/szr/subquery/SQL2XML/YSmart.g:285:65: ( COMMA NUMBER )?
                        alt36 = 2
                        LA36_0 = self.input.LA(1)

                        if (LA36_0 == COMMA) :
                            alt36 = 1
                        if alt36 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:285:67: COMMA NUMBER
                            pass 
                            COMMA143=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_datatype1592)
                            if self._state.backtracking == 0:

                                COMMA143_tree = self._adaptor.createWithPayload(COMMA143)
                                self._adaptor.addChild(root_0, COMMA143_tree)

                            NUMBER144=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1594)
                            if self._state.backtracking == 0:

                                NUMBER144_tree = self._adaptor.createWithPayload(NUMBER144)
                                self._adaptor.addChild(root_0, NUMBER144_tree)




                        RPAREN145=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1599)
                        if self._state.backtracking == 0:

                            RPAREN145_tree = self._adaptor.createWithPayload(RPAREN145)
                            self._adaptor.addChild(root_0, RPAREN145_tree)






                elif alt74 == 7:
                    # /home/szr/subquery/SQL2XML/YSmart.g:286:4: k_long ( k_raw )? ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_long_in_datatype1607)
                    k_long146 = self.k_long()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_long146.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:286:11: ( k_raw )?
                    alt38 = 2
                    LA38_0 = self.input.LA(1)

                    if (LA38_0 == 173) :
                        alt38 = 1
                    if alt38 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:286:13: k_raw
                        pass 
                        self._state.following.append(self.FOLLOW_k_raw_in_datatype1611)
                        k_raw147 = self.k_raw()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_raw147.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:286:21: ( LPAREN NUMBER RPAREN )?
                    alt39 = 2
                    LA39_0 = self.input.LA(1)

                    if (LA39_0 == LPAREN) :
                        alt39 = 1
                    if alt39 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:286:23: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN148=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1617)
                        if self._state.backtracking == 0:

                            LPAREN148_tree = self._adaptor.createWithPayload(LPAREN148)
                            self._adaptor.addChild(root_0, LPAREN148_tree)

                        NUMBER149=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1619)
                        if self._state.backtracking == 0:

                            NUMBER149_tree = self._adaptor.createWithPayload(NUMBER149)
                            self._adaptor.addChild(root_0, NUMBER149_tree)

                        RPAREN150=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1621)
                        if self._state.backtracking == 0:

                            RPAREN150_tree = self._adaptor.createWithPayload(RPAREN150)
                            self._adaptor.addChild(root_0, RPAREN150_tree)






                elif alt74 == 8:
                    # /home/szr/subquery/SQL2XML/YSmart.g:287:4: k_raw ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_raw_in_datatype1629)
                    k_raw151 = self.k_raw()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_raw151.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:287:10: ( LPAREN NUMBER RPAREN )?
                    alt40 = 2
                    LA40_0 = self.input.LA(1)

                    if (LA40_0 == LPAREN) :
                        alt40 = 1
                    if alt40 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:287:12: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN152=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1633)
                        if self._state.backtracking == 0:

                            LPAREN152_tree = self._adaptor.createWithPayload(LPAREN152)
                            self._adaptor.addChild(root_0, LPAREN152_tree)

                        NUMBER153=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1635)
                        if self._state.backtracking == 0:

                            NUMBER153_tree = self._adaptor.createWithPayload(NUMBER153)
                            self._adaptor.addChild(root_0, NUMBER153_tree)

                        RPAREN154=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1637)
                        if self._state.backtracking == 0:

                            RPAREN154_tree = self._adaptor.createWithPayload(RPAREN154)
                            self._adaptor.addChild(root_0, RPAREN154_tree)






                elif alt74 == 9:
                    # /home/szr/subquery/SQL2XML/YSmart.g:288:4: k_boolean
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_boolean_in_datatype1645)
                    k_boolean155 = self.k_boolean()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_boolean155.tree)


                elif alt74 == 10:
                    # /home/szr/subquery/SQL2XML/YSmart.g:289:4: k_date
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_date_in_datatype1650)
                    k_date156 = self.k_date()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_date156.tree)


                elif alt74 == 11:
                    # /home/szr/subquery/SQL2XML/YSmart.g:290:4: k_interval k_day ( LPAREN NUMBER RPAREN )? k_to k_second ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_interval_in_datatype1655)
                    k_interval157 = self.k_interval()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_interval157.tree)
                    self._state.following.append(self.FOLLOW_k_day_in_datatype1657)
                    k_day158 = self.k_day()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_day158.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:290:21: ( LPAREN NUMBER RPAREN )?
                    alt41 = 2
                    LA41_0 = self.input.LA(1)

                    if (LA41_0 == LPAREN) :
                        alt41 = 1
                    if alt41 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:290:23: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN159=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1661)
                        if self._state.backtracking == 0:

                            LPAREN159_tree = self._adaptor.createWithPayload(LPAREN159)
                            self._adaptor.addChild(root_0, LPAREN159_tree)

                        NUMBER160=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1663)
                        if self._state.backtracking == 0:

                            NUMBER160_tree = self._adaptor.createWithPayload(NUMBER160)
                            self._adaptor.addChild(root_0, NUMBER160_tree)

                        RPAREN161=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1665)
                        if self._state.backtracking == 0:

                            RPAREN161_tree = self._adaptor.createWithPayload(RPAREN161)
                            self._adaptor.addChild(root_0, RPAREN161_tree)




                    self._state.following.append(self.FOLLOW_k_to_in_datatype1670)
                    k_to162 = self.k_to()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_to162.tree)
                    self._state.following.append(self.FOLLOW_k_second_in_datatype1672)
                    k_second163 = self.k_second()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_second163.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:290:61: ( LPAREN NUMBER RPAREN )?
                    alt42 = 2
                    LA42_0 = self.input.LA(1)

                    if (LA42_0 == LPAREN) :
                        alt42 = 1
                    if alt42 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:290:63: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN164=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1676)
                        if self._state.backtracking == 0:

                            LPAREN164_tree = self._adaptor.createWithPayload(LPAREN164)
                            self._adaptor.addChild(root_0, LPAREN164_tree)

                        NUMBER165=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1678)
                        if self._state.backtracking == 0:

                            NUMBER165_tree = self._adaptor.createWithPayload(NUMBER165)
                            self._adaptor.addChild(root_0, NUMBER165_tree)

                        RPAREN166=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1680)
                        if self._state.backtracking == 0:

                            RPAREN166_tree = self._adaptor.createWithPayload(RPAREN166)
                            self._adaptor.addChild(root_0, RPAREN166_tree)






                elif alt74 == 12:
                    # /home/szr/subquery/SQL2XML/YSmart.g:291:4: k_interval k_year ( LPAREN NUMBER RPAREN )? k_to k_month
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_interval_in_datatype1688)
                    k_interval167 = self.k_interval()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_interval167.tree)
                    self._state.following.append(self.FOLLOW_k_year_in_datatype1690)
                    k_year168 = self.k_year()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_year168.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:291:22: ( LPAREN NUMBER RPAREN )?
                    alt43 = 2
                    LA43_0 = self.input.LA(1)

                    if (LA43_0 == LPAREN) :
                        alt43 = 1
                    if alt43 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:291:24: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN169=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1694)
                        if self._state.backtracking == 0:

                            LPAREN169_tree = self._adaptor.createWithPayload(LPAREN169)
                            self._adaptor.addChild(root_0, LPAREN169_tree)

                        NUMBER170=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1696)
                        if self._state.backtracking == 0:

                            NUMBER170_tree = self._adaptor.createWithPayload(NUMBER170)
                            self._adaptor.addChild(root_0, NUMBER170_tree)

                        RPAREN171=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1698)
                        if self._state.backtracking == 0:

                            RPAREN171_tree = self._adaptor.createWithPayload(RPAREN171)
                            self._adaptor.addChild(root_0, RPAREN171_tree)




                    self._state.following.append(self.FOLLOW_k_to_in_datatype1703)
                    k_to172 = self.k_to()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_to172.tree)
                    self._state.following.append(self.FOLLOW_k_month_in_datatype1705)
                    k_month173 = self.k_month()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_month173.tree)


                elif alt74 == 13:
                    # /home/szr/subquery/SQL2XML/YSmart.g:292:4: ( k_time | k_timestamp ) ( LPAREN NUMBER RPAREN )? ( k_with ( k_local )? k_time k_zone )?
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:292:4: ( k_time | k_timestamp )
                    alt44 = 2
                    LA44_0 = self.input.LA(1)

                    if (LA44_0 == 379) :
                        alt44 = 1
                    elif (LA44_0 == 492) :
                        alt44 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 44, 0, self.input)

                        raise nvae

                    if alt44 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:292:6: k_time
                        pass 
                        self._state.following.append(self.FOLLOW_k_time_in_datatype1712)
                        k_time174 = self.k_time()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_time174.tree)


                    elif alt44 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:292:15: k_timestamp
                        pass 
                        self._state.following.append(self.FOLLOW_k_timestamp_in_datatype1716)
                        k_timestamp175 = self.k_timestamp()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_timestamp175.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:292:29: ( LPAREN NUMBER RPAREN )?
                    alt45 = 2
                    LA45_0 = self.input.LA(1)

                    if (LA45_0 == LPAREN) :
                        alt45 = 1
                    if alt45 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:292:31: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN176=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1722)
                        if self._state.backtracking == 0:

                            LPAREN176_tree = self._adaptor.createWithPayload(LPAREN176)
                            self._adaptor.addChild(root_0, LPAREN176_tree)

                        NUMBER177=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1724)
                        if self._state.backtracking == 0:

                            NUMBER177_tree = self._adaptor.createWithPayload(NUMBER177)
                            self._adaptor.addChild(root_0, NUMBER177_tree)

                        RPAREN178=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1726)
                        if self._state.backtracking == 0:

                            RPAREN178_tree = self._adaptor.createWithPayload(RPAREN178)
                            self._adaptor.addChild(root_0, RPAREN178_tree)




                    # /home/szr/subquery/SQL2XML/YSmart.g:292:55: ( k_with ( k_local )? k_time k_zone )?
                    alt47 = 2
                    LA47_0 = self.input.LA(1)

                    if (LA47_0 == 210) :
                        alt47 = 1
                    if alt47 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:292:57: k_with ( k_local )? k_time k_zone
                        pass 
                        self._state.following.append(self.FOLLOW_k_with_in_datatype1733)
                        k_with179 = self.k_with()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_with179.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:292:64: ( k_local )?
                        alt46 = 2
                        LA46_0 = self.input.LA(1)

                        if (LA46_0 == 291) :
                            alt46 = 1
                        if alt46 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:292:66: k_local
                            pass 
                            self._state.following.append(self.FOLLOW_k_local_in_datatype1737)
                            k_local180 = self.k_local()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_local180.tree)



                        self._state.following.append(self.FOLLOW_k_time_in_datatype1742)
                        k_time181 = self.k_time()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_time181.tree)
                        self._state.following.append(self.FOLLOW_k_zone_in_datatype1744)
                        k_zone182 = self.k_zone()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_zone182.tree)





                elif alt74 == 14:
                    # /home/szr/subquery/SQL2XML/YSmart.g:293:4: k_integer
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_integer_in_datatype1752)
                    k_integer183 = self.k_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_integer183.tree)


                elif alt74 == 15:
                    # /home/szr/subquery/SQL2XML/YSmart.g:294:4: k_int
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_int_in_datatype1757)
                    k_int184 = self.k_int()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_int184.tree)


                elif alt74 == 16:
                    # /home/szr/subquery/SQL2XML/YSmart.g:295:4: k_smallint
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_smallint_in_datatype1762)
                    k_smallint185 = self.k_smallint()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_smallint185.tree)


                elif alt74 == 17:
                    # /home/szr/subquery/SQL2XML/YSmart.g:296:4: k_float ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_float_in_datatype1767)
                    k_float186 = self.k_float()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_float186.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:296:12: ( LPAREN NUMBER RPAREN )?
                    alt48 = 2
                    LA48_0 = self.input.LA(1)

                    if (LA48_0 == LPAREN) :
                        alt48 = 1
                    if alt48 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:296:14: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN187=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1771)
                        if self._state.backtracking == 0:

                            LPAREN187_tree = self._adaptor.createWithPayload(LPAREN187)
                            self._adaptor.addChild(root_0, LPAREN187_tree)

                        NUMBER188=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1773)
                        if self._state.backtracking == 0:

                            NUMBER188_tree = self._adaptor.createWithPayload(NUMBER188)
                            self._adaptor.addChild(root_0, NUMBER188_tree)

                        RPAREN189=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1775)
                        if self._state.backtracking == 0:

                            RPAREN189_tree = self._adaptor.createWithPayload(RPAREN189)
                            self._adaptor.addChild(root_0, RPAREN189_tree)






                elif alt74 == 18:
                    # /home/szr/subquery/SQL2XML/YSmart.g:297:4: k_real
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_real_in_datatype1783)
                    k_real190 = self.k_real()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_real190.tree)


                elif alt74 == 19:
                    # /home/szr/subquery/SQL2XML/YSmart.g:298:4: k_double k_precision
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_double_in_datatype1788)
                    k_double191 = self.k_double()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_double191.tree)
                    self._state.following.append(self.FOLLOW_k_precision_in_datatype1790)
                    k_precision192 = self.k_precision()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_precision192.tree)


                elif alt74 == 20:
                    # /home/szr/subquery/SQL2XML/YSmart.g:299:4: k_char ( k_varying )? ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_char_in_datatype1795)
                    k_char193 = self.k_char()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_char193.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:299:16: ( k_varying )?
                    alt49 = 2
                    LA49_0 = self.input.LA(1)

                    if (LA49_0 == 500) :
                        alt49 = 1
                    if alt49 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:299:18: k_varying
                        pass 
                        self._state.following.append(self.FOLLOW_k_varying_in_datatype1804)
                        k_varying194 = self.k_varying()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_varying194.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:299:31: ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )?
                    alt51 = 2
                    LA51_0 = self.input.LA(1)

                    if (LA51_0 == LPAREN) :
                        alt51 = 1
                    if alt51 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:299:33: LPAREN NUMBER ( k_byte | k_char )? RPAREN
                        pass 
                        LPAREN195=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1811)
                        if self._state.backtracking == 0:

                            LPAREN195_tree = self._adaptor.createWithPayload(LPAREN195)
                            self._adaptor.addChild(root_0, LPAREN195_tree)

                        NUMBER196=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1813)
                        if self._state.backtracking == 0:

                            NUMBER196_tree = self._adaptor.createWithPayload(NUMBER196)
                            self._adaptor.addChild(root_0, NUMBER196_tree)

                        # /home/szr/subquery/SQL2XML/YSmart.g:299:47: ( k_byte | k_char )?
                        alt50 = 3
                        LA50_0 = self.input.LA(1)

                        if (LA50_0 == 402) :
                            alt50 = 1
                        elif (LA50_0 == 106) :
                            alt50 = 2
                        if alt50 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:299:49: k_byte
                            pass 
                            self._state.following.append(self.FOLLOW_k_byte_in_datatype1817)
                            k_byte197 = self.k_byte()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_byte197.tree)


                        elif alt50 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:299:58: k_char
                            pass 
                            self._state.following.append(self.FOLLOW_k_char_in_datatype1821)
                            k_char198 = self.k_char()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_char198.tree)



                        RPAREN199=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1826)
                        if self._state.backtracking == 0:

                            RPAREN199_tree = self._adaptor.createWithPayload(RPAREN199)
                            self._adaptor.addChild(root_0, RPAREN199_tree)




                    # /home/szr/subquery/SQL2XML/YSmart.g:299:78: ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    alt53 = 2
                    LA53_0 = self.input.LA(1)

                    if (LA53_0 == 231) :
                        alt53 = 1
                    if alt53 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:299:80: k_character k_set ( identifier | column_spec CHARSET_ATTR )
                        pass 
                        self._state.following.append(self.FOLLOW_k_character_in_datatype1833)
                        k_character200 = self.k_character()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_character200.tree)
                        self._state.following.append(self.FOLLOW_k_set_in_datatype1835)
                        k_set201 = self.k_set()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_set201.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:299:98: ( identifier | column_spec CHARSET_ATTR )
                        alt52 = 2
                        LA52_0 = self.input.LA(1)

                        if ((VECTOR <= LA52_0 <= DOUBLEQUOTED_STRING)) :
                            LA52_1 = self.input.LA(2)

                            if (LA52_1 == EOF or LA52_1 == RPAREN) :
                                alt52 = 1
                            elif (LA52_1 == DOT or LA52_1 == CHARSET_ATTR) :
                                alt52 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed

                                nvae = NoViableAltException("", 52, 1, self.input)

                                raise nvae

                        elif (LA52_0 == 91 or LA52_0 == 144 or LA52_0 == 160 or LA52_0 == 178 or LA52_0 == 180 or LA52_0 == 192 or (211 <= LA52_0 <= 367) or (369 <= LA52_0 <= 387) or (390 <= LA52_0 <= 428) or (430 <= LA52_0 <= 439) or (442 <= LA52_0 <= 453) or LA52_0 == 455 or (460 <= LA52_0 <= 528) or (530 <= LA52_0 <= 537) or (539 <= LA52_0 <= 546)) :
                            alt52 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 52, 0, self.input)

                            raise nvae

                        if alt52 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:299:100: identifier
                            pass 
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1839)
                            identifier202 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier202.tree)


                        elif alt52 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:299:113: column_spec CHARSET_ATTR
                            pass 
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1843)
                            column_spec203 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec203.tree)
                            CHARSET_ATTR204=self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1845)
                            if self._state.backtracking == 0:

                                CHARSET_ATTR204_tree = self._adaptor.createWithPayload(CHARSET_ATTR204)
                                self._adaptor.addChild(root_0, CHARSET_ATTR204_tree)









                elif alt74 == 21:
                    # /home/szr/subquery/SQL2XML/YSmart.g:300:4: k_varchar ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_varchar_in_datatype1855)
                    k_varchar205 = self.k_varchar()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_varchar205.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:300:31: ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )?
                    alt55 = 2
                    LA55_0 = self.input.LA(1)

                    if (LA55_0 == LPAREN) :
                        alt55 = 1
                    if alt55 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:300:33: LPAREN NUMBER ( k_byte | k_char )? RPAREN
                        pass 
                        LPAREN206=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1876)
                        if self._state.backtracking == 0:

                            LPAREN206_tree = self._adaptor.createWithPayload(LPAREN206)
                            self._adaptor.addChild(root_0, LPAREN206_tree)

                        NUMBER207=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1878)
                        if self._state.backtracking == 0:

                            NUMBER207_tree = self._adaptor.createWithPayload(NUMBER207)
                            self._adaptor.addChild(root_0, NUMBER207_tree)

                        # /home/szr/subquery/SQL2XML/YSmart.g:300:47: ( k_byte | k_char )?
                        alt54 = 3
                        LA54_0 = self.input.LA(1)

                        if (LA54_0 == 402) :
                            alt54 = 1
                        elif (LA54_0 == 106) :
                            alt54 = 2
                        if alt54 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:300:49: k_byte
                            pass 
                            self._state.following.append(self.FOLLOW_k_byte_in_datatype1882)
                            k_byte208 = self.k_byte()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_byte208.tree)


                        elif alt54 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:300:58: k_char
                            pass 
                            self._state.following.append(self.FOLLOW_k_char_in_datatype1886)
                            k_char209 = self.k_char()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_char209.tree)



                        RPAREN210=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1891)
                        if self._state.backtracking == 0:

                            RPAREN210_tree = self._adaptor.createWithPayload(RPAREN210)
                            self._adaptor.addChild(root_0, RPAREN210_tree)




                    # /home/szr/subquery/SQL2XML/YSmart.g:300:78: ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    alt57 = 2
                    LA57_0 = self.input.LA(1)

                    if (LA57_0 == 231) :
                        alt57 = 1
                    if alt57 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:300:80: k_character k_set ( identifier | column_spec CHARSET_ATTR )
                        pass 
                        self._state.following.append(self.FOLLOW_k_character_in_datatype1898)
                        k_character211 = self.k_character()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_character211.tree)
                        self._state.following.append(self.FOLLOW_k_set_in_datatype1900)
                        k_set212 = self.k_set()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_set212.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:300:98: ( identifier | column_spec CHARSET_ATTR )
                        alt56 = 2
                        LA56_0 = self.input.LA(1)

                        if ((VECTOR <= LA56_0 <= DOUBLEQUOTED_STRING)) :
                            LA56_1 = self.input.LA(2)

                            if (LA56_1 == EOF or LA56_1 == RPAREN) :
                                alt56 = 1
                            elif (LA56_1 == DOT or LA56_1 == CHARSET_ATTR) :
                                alt56 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed

                                nvae = NoViableAltException("", 56, 1, self.input)

                                raise nvae

                        elif (LA56_0 == 91 or LA56_0 == 144 or LA56_0 == 160 or LA56_0 == 178 or LA56_0 == 180 or LA56_0 == 192 or (211 <= LA56_0 <= 367) or (369 <= LA56_0 <= 387) or (390 <= LA56_0 <= 428) or (430 <= LA56_0 <= 439) or (442 <= LA56_0 <= 453) or LA56_0 == 455 or (460 <= LA56_0 <= 528) or (530 <= LA56_0 <= 537) or (539 <= LA56_0 <= 546)) :
                            alt56 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 56, 0, self.input)

                            raise nvae

                        if alt56 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:300:100: identifier
                            pass 
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1904)
                            identifier213 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier213.tree)


                        elif alt56 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:300:113: column_spec CHARSET_ATTR
                            pass 
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1908)
                            column_spec214 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec214.tree)
                            CHARSET_ATTR215=self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1910)
                            if self._state.backtracking == 0:

                                CHARSET_ATTR215_tree = self._adaptor.createWithPayload(CHARSET_ATTR215)
                                self._adaptor.addChild(root_0, CHARSET_ATTR215_tree)









                elif alt74 == 22:
                    # /home/szr/subquery/SQL2XML/YSmart.g:301:4: k_varchar2 ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )? ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_varchar2_in_datatype1920)
                    k_varchar2216 = self.k_varchar2()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_varchar2216.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:301:31: ( LPAREN NUMBER ( k_byte | k_char )? RPAREN )?
                    alt59 = 2
                    LA59_0 = self.input.LA(1)

                    if (LA59_0 == LPAREN) :
                        alt59 = 1
                    if alt59 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:301:33: LPAREN NUMBER ( k_byte | k_char )? RPAREN
                        pass 
                        LPAREN217=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1940)
                        if self._state.backtracking == 0:

                            LPAREN217_tree = self._adaptor.createWithPayload(LPAREN217)
                            self._adaptor.addChild(root_0, LPAREN217_tree)

                        NUMBER218=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1942)
                        if self._state.backtracking == 0:

                            NUMBER218_tree = self._adaptor.createWithPayload(NUMBER218)
                            self._adaptor.addChild(root_0, NUMBER218_tree)

                        # /home/szr/subquery/SQL2XML/YSmart.g:301:47: ( k_byte | k_char )?
                        alt58 = 3
                        LA58_0 = self.input.LA(1)

                        if (LA58_0 == 402) :
                            alt58 = 1
                        elif (LA58_0 == 106) :
                            alt58 = 2
                        if alt58 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:301:49: k_byte
                            pass 
                            self._state.following.append(self.FOLLOW_k_byte_in_datatype1946)
                            k_byte219 = self.k_byte()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_byte219.tree)


                        elif alt58 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:301:58: k_char
                            pass 
                            self._state.following.append(self.FOLLOW_k_char_in_datatype1950)
                            k_char220 = self.k_char()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_char220.tree)



                        RPAREN221=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1955)
                        if self._state.backtracking == 0:

                            RPAREN221_tree = self._adaptor.createWithPayload(RPAREN221)
                            self._adaptor.addChild(root_0, RPAREN221_tree)




                    # /home/szr/subquery/SQL2XML/YSmart.g:301:78: ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    alt61 = 2
                    LA61_0 = self.input.LA(1)

                    if (LA61_0 == 231) :
                        alt61 = 1
                    if alt61 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:301:80: k_character k_set ( identifier | column_spec CHARSET_ATTR )
                        pass 
                        self._state.following.append(self.FOLLOW_k_character_in_datatype1962)
                        k_character222 = self.k_character()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_character222.tree)
                        self._state.following.append(self.FOLLOW_k_set_in_datatype1964)
                        k_set223 = self.k_set()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_set223.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:301:98: ( identifier | column_spec CHARSET_ATTR )
                        alt60 = 2
                        LA60_0 = self.input.LA(1)

                        if ((VECTOR <= LA60_0 <= DOUBLEQUOTED_STRING)) :
                            LA60_1 = self.input.LA(2)

                            if (LA60_1 == EOF or LA60_1 == RPAREN) :
                                alt60 = 1
                            elif (LA60_1 == DOT or LA60_1 == CHARSET_ATTR) :
                                alt60 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed

                                nvae = NoViableAltException("", 60, 1, self.input)

                                raise nvae

                        elif (LA60_0 == 91 or LA60_0 == 144 or LA60_0 == 160 or LA60_0 == 178 or LA60_0 == 180 or LA60_0 == 192 or (211 <= LA60_0 <= 367) or (369 <= LA60_0 <= 387) or (390 <= LA60_0 <= 428) or (430 <= LA60_0 <= 439) or (442 <= LA60_0 <= 453) or LA60_0 == 455 or (460 <= LA60_0 <= 528) or (530 <= LA60_0 <= 537) or (539 <= LA60_0 <= 546)) :
                            alt60 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 60, 0, self.input)

                            raise nvae

                        if alt60 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:301:100: identifier
                            pass 
                            self._state.following.append(self.FOLLOW_identifier_in_datatype1968)
                            identifier224 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier224.tree)


                        elif alt60 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:301:113: column_spec CHARSET_ATTR
                            pass 
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype1972)
                            column_spec225 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec225.tree)
                            CHARSET_ATTR226=self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype1974)
                            if self._state.backtracking == 0:

                                CHARSET_ATTR226_tree = self._adaptor.createWithPayload(CHARSET_ATTR226)
                                self._adaptor.addChild(root_0, CHARSET_ATTR226_tree)









                elif alt74 == 23:
                    # /home/szr/subquery/SQL2XML/YSmart.g:302:4: k_character ( k_varying )? ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_character_in_datatype1984)
                    k_character227 = self.k_character()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_character227.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:302:16: ( k_varying )?
                    alt62 = 2
                    LA62_0 = self.input.LA(1)

                    if (LA62_0 == 500) :
                        alt62 = 1
                    if alt62 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:302:18: k_varying
                        pass 
                        self._state.following.append(self.FOLLOW_k_varying_in_datatype1988)
                        k_varying228 = self.k_varying()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_varying228.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:302:31: ( LPAREN NUMBER RPAREN )?
                    alt63 = 2
                    LA63_0 = self.input.LA(1)

                    if (LA63_0 == LPAREN) :
                        alt63 = 1
                    if alt63 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:302:33: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN229=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype1995)
                        if self._state.backtracking == 0:

                            LPAREN229_tree = self._adaptor.createWithPayload(LPAREN229)
                            self._adaptor.addChild(root_0, LPAREN229_tree)

                        NUMBER230=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype1997)
                        if self._state.backtracking == 0:

                            NUMBER230_tree = self._adaptor.createWithPayload(NUMBER230)
                            self._adaptor.addChild(root_0, NUMBER230_tree)

                        RPAREN231=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype1999)
                        if self._state.backtracking == 0:

                            RPAREN231_tree = self._adaptor.createWithPayload(RPAREN231)
                            self._adaptor.addChild(root_0, RPAREN231_tree)






                elif alt74 == 24:
                    # /home/szr/subquery/SQL2XML/YSmart.g:303:4: k_nchar ( k_varying )? ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_nchar_in_datatype2007)
                    k_nchar232 = self.k_nchar()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nchar232.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:303:16: ( k_varying )?
                    alt64 = 2
                    LA64_0 = self.input.LA(1)

                    if (LA64_0 == 500) :
                        alt64 = 1
                    if alt64 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:303:18: k_varying
                        pass 
                        self._state.following.append(self.FOLLOW_k_varying_in_datatype2015)
                        k_varying233 = self.k_varying()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_varying233.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:303:31: ( LPAREN NUMBER RPAREN )?
                    alt65 = 2
                    LA65_0 = self.input.LA(1)

                    if (LA65_0 == LPAREN) :
                        alt65 = 1
                    if alt65 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:303:33: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN234=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype2022)
                        if self._state.backtracking == 0:

                            LPAREN234_tree = self._adaptor.createWithPayload(LPAREN234)
                            self._adaptor.addChild(root_0, LPAREN234_tree)

                        NUMBER235=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype2024)
                        if self._state.backtracking == 0:

                            NUMBER235_tree = self._adaptor.createWithPayload(NUMBER235)
                            self._adaptor.addChild(root_0, NUMBER235_tree)

                        RPAREN236=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype2026)
                        if self._state.backtracking == 0:

                            RPAREN236_tree = self._adaptor.createWithPayload(RPAREN236)
                            self._adaptor.addChild(root_0, RPAREN236_tree)






                elif alt74 == 25:
                    # /home/szr/subquery/SQL2XML/YSmart.g:304:4: k_nvarchar ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_nvarchar_in_datatype2034)
                    k_nvarchar237 = self.k_nvarchar()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nvarchar237.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:304:16: ( LPAREN NUMBER RPAREN )?
                    alt66 = 2
                    LA66_0 = self.input.LA(1)

                    if (LA66_0 == LPAREN) :
                        alt66 = 1
                    if alt66 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:304:18: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN238=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype2039)
                        if self._state.backtracking == 0:

                            LPAREN238_tree = self._adaptor.createWithPayload(LPAREN238)
                            self._adaptor.addChild(root_0, LPAREN238_tree)

                        NUMBER239=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype2041)
                        if self._state.backtracking == 0:

                            NUMBER239_tree = self._adaptor.createWithPayload(NUMBER239)
                            self._adaptor.addChild(root_0, NUMBER239_tree)

                        RPAREN240=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype2043)
                        if self._state.backtracking == 0:

                            RPAREN240_tree = self._adaptor.createWithPayload(RPAREN240)
                            self._adaptor.addChild(root_0, RPAREN240_tree)






                elif alt74 == 26:
                    # /home/szr/subquery/SQL2XML/YSmart.g:305:4: k_nvarchar2 ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_nvarchar2_in_datatype2051)
                    k_nvarchar2241 = self.k_nvarchar2()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nvarchar2241.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:305:16: ( LPAREN NUMBER RPAREN )?
                    alt67 = 2
                    LA67_0 = self.input.LA(1)

                    if (LA67_0 == LPAREN) :
                        alt67 = 1
                    if alt67 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:305:18: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN242=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype2055)
                        if self._state.backtracking == 0:

                            LPAREN242_tree = self._adaptor.createWithPayload(LPAREN242)
                            self._adaptor.addChild(root_0, LPAREN242_tree)

                        NUMBER243=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype2057)
                        if self._state.backtracking == 0:

                            NUMBER243_tree = self._adaptor.createWithPayload(NUMBER243)
                            self._adaptor.addChild(root_0, NUMBER243_tree)

                        RPAREN244=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype2059)
                        if self._state.backtracking == 0:

                            RPAREN244_tree = self._adaptor.createWithPayload(RPAREN244)
                            self._adaptor.addChild(root_0, RPAREN244_tree)






                elif alt74 == 27:
                    # /home/szr/subquery/SQL2XML/YSmart.g:306:4: k_national ( k_character | k_char ) ( k_varying )? ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_national_in_datatype2067)
                    k_national245 = self.k_national()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_national245.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:306:16: ( k_character | k_char )
                    alt68 = 2
                    LA68_0 = self.input.LA(1)

                    if (LA68_0 == 231) :
                        alt68 = 1
                    elif (LA68_0 == 106) :
                        alt68 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 68, 0, self.input)

                        raise nvae

                    if alt68 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:306:18: k_character
                        pass 
                        self._state.following.append(self.FOLLOW_k_character_in_datatype2072)
                        k_character246 = self.k_character()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_character246.tree)


                    elif alt68 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:306:32: k_char
                        pass 
                        self._state.following.append(self.FOLLOW_k_char_in_datatype2076)
                        k_char247 = self.k_char()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_char247.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:306:41: ( k_varying )?
                    alt69 = 2
                    LA69_0 = self.input.LA(1)

                    if (LA69_0 == 500) :
                        alt69 = 1
                    if alt69 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:306:43: k_varying
                        pass 
                        self._state.following.append(self.FOLLOW_k_varying_in_datatype2082)
                        k_varying248 = self.k_varying()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_varying248.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:306:56: ( LPAREN NUMBER RPAREN )?
                    alt70 = 2
                    LA70_0 = self.input.LA(1)

                    if (LA70_0 == LPAREN) :
                        alt70 = 1
                    if alt70 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:306:58: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN249=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype2089)
                        if self._state.backtracking == 0:

                            LPAREN249_tree = self._adaptor.createWithPayload(LPAREN249)
                            self._adaptor.addChild(root_0, LPAREN249_tree)

                        NUMBER250=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype2091)
                        if self._state.backtracking == 0:

                            NUMBER250_tree = self._adaptor.createWithPayload(NUMBER250)
                            self._adaptor.addChild(root_0, NUMBER250_tree)

                        RPAREN251=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype2093)
                        if self._state.backtracking == 0:

                            RPAREN251_tree = self._adaptor.createWithPayload(RPAREN251)
                            self._adaptor.addChild(root_0, RPAREN251_tree)






                elif alt74 == 28:
                    # /home/szr/subquery/SQL2XML/YSmart.g:307:4: k_mlslabel
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_mlslabel_in_datatype2101)
                    k_mlslabel252 = self.k_mlslabel()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_mlslabel252.tree)


                elif alt74 == 29:
                    # /home/szr/subquery/SQL2XML/YSmart.g:308:4: k_pls_integer
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_pls_integer_in_datatype2106)
                    k_pls_integer253 = self.k_pls_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_pls_integer253.tree)


                elif alt74 == 30:
                    # /home/szr/subquery/SQL2XML/YSmart.g:309:4: k_blob
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_blob_in_datatype2111)
                    k_blob254 = self.k_blob()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_blob254.tree)


                elif alt74 == 31:
                    # /home/szr/subquery/SQL2XML/YSmart.g:310:4: k_clob ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_clob_in_datatype2116)
                    k_clob255 = self.k_clob()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_clob255.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:310:11: ( k_character k_set ( identifier | column_spec CHARSET_ATTR ) )?
                    alt72 = 2
                    LA72_0 = self.input.LA(1)

                    if (LA72_0 == 231) :
                        alt72 = 1
                    if alt72 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:310:13: k_character k_set ( identifier | column_spec CHARSET_ATTR )
                        pass 
                        self._state.following.append(self.FOLLOW_k_character_in_datatype2120)
                        k_character256 = self.k_character()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_character256.tree)
                        self._state.following.append(self.FOLLOW_k_set_in_datatype2122)
                        k_set257 = self.k_set()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_set257.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:310:31: ( identifier | column_spec CHARSET_ATTR )
                        alt71 = 2
                        LA71_0 = self.input.LA(1)

                        if ((VECTOR <= LA71_0 <= DOUBLEQUOTED_STRING)) :
                            LA71_1 = self.input.LA(2)

                            if (LA71_1 == EOF or LA71_1 == RPAREN) :
                                alt71 = 1
                            elif (LA71_1 == DOT or LA71_1 == CHARSET_ATTR) :
                                alt71 = 2
                            else:
                                if self._state.backtracking > 0:
                                    raise BacktrackingFailed

                                nvae = NoViableAltException("", 71, 1, self.input)

                                raise nvae

                        elif (LA71_0 == 91 or LA71_0 == 144 or LA71_0 == 160 or LA71_0 == 178 or LA71_0 == 180 or LA71_0 == 192 or (211 <= LA71_0 <= 367) or (369 <= LA71_0 <= 387) or (390 <= LA71_0 <= 428) or (430 <= LA71_0 <= 439) or (442 <= LA71_0 <= 453) or LA71_0 == 455 or (460 <= LA71_0 <= 528) or (530 <= LA71_0 <= 537) or (539 <= LA71_0 <= 546)) :
                            alt71 = 2
                        else:
                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            nvae = NoViableAltException("", 71, 0, self.input)

                            raise nvae

                        if alt71 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:310:33: identifier
                            pass 
                            self._state.following.append(self.FOLLOW_identifier_in_datatype2126)
                            identifier258 = self.identifier()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, identifier258.tree)


                        elif alt71 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:310:46: column_spec CHARSET_ATTR
                            pass 
                            self._state.following.append(self.FOLLOW_column_spec_in_datatype2130)
                            column_spec259 = self.column_spec()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, column_spec259.tree)
                            CHARSET_ATTR260=self.match(self.input, CHARSET_ATTR, self.FOLLOW_CHARSET_ATTR_in_datatype2132)
                            if self._state.backtracking == 0:

                                CHARSET_ATTR260_tree = self._adaptor.createWithPayload(CHARSET_ATTR260)
                                self._adaptor.addChild(root_0, CHARSET_ATTR260_tree)









                elif alt74 == 32:
                    # /home/szr/subquery/SQL2XML/YSmart.g:311:4: k_nclob
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_nclob_in_datatype2142)
                    k_nclob261 = self.k_nclob()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nclob261.tree)


                elif alt74 == 33:
                    # /home/szr/subquery/SQL2XML/YSmart.g:312:4: k_bfile
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_bfile_in_datatype2147)
                    k_bfile262 = self.k_bfile()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_bfile262.tree)


                elif alt74 == 34:
                    # /home/szr/subquery/SQL2XML/YSmart.g:313:4: k_rowid
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_rowid_in_datatype2152)
                    k_rowid263 = self.k_rowid()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rowid263.tree)


                elif alt74 == 35:
                    # /home/szr/subquery/SQL2XML/YSmart.g:314:4: k_urowid ( LPAREN NUMBER RPAREN )?
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_urowid_in_datatype2158)
                    k_urowid264 = self.k_urowid()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_urowid264.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:314:13: ( LPAREN NUMBER RPAREN )?
                    alt73 = 2
                    LA73_0 = self.input.LA(1)

                    if (LA73_0 == LPAREN) :
                        alt73 = 1
                    if alt73 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:314:15: LPAREN NUMBER RPAREN
                        pass 
                        LPAREN265=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_datatype2162)
                        if self._state.backtracking == 0:

                            LPAREN265_tree = self._adaptor.createWithPayload(LPAREN265)
                            self._adaptor.addChild(root_0, LPAREN265_tree)

                        NUMBER266=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_datatype2164)
                        if self._state.backtracking == 0:

                            NUMBER266_tree = self._adaptor.createWithPayload(NUMBER266)
                            self._adaptor.addChild(root_0, NUMBER266_tree)

                        RPAREN267=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_datatype2166)
                        if self._state.backtracking == 0:

                            RPAREN267_tree = self._adaptor.createWithPayload(RPAREN267)
                            self._adaptor.addChild(root_0, RPAREN267_tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 28, datatype_StartIndex, success)

            pass
        return retval

    # $ANTLR end "datatype"

    class boolean_literal_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.boolean_literal_return, self).__init__()

            self.tree = None




    # $ANTLR start "boolean_literal"
    # /home/szr/subquery/SQL2XML/YSmart.g:317:1: boolean_literal : ( k_true | k_false );
    def boolean_literal(self, ):

        retval = self.boolean_literal_return()
        retval.start = self.input.LT(1)
        boolean_literal_StartIndex = self.input.index()
        root_0 = None

        k_true268 = None

        k_false269 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 29):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:318:2: ( k_true | k_false )
                alt75 = 2
                LA75_0 = self.input.LA(1)

                if (LA75_0 == 197) :
                    alt75 = 1
                elif (LA75_0 == 125) :
                    alt75 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 75, 0, self.input)

                    raise nvae

                if alt75 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:318:4: k_true
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_true_in_boolean_literal2180)
                    k_true268 = self.k_true()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_true268.tree)


                elif alt75 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:318:13: k_false
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_false_in_boolean_literal2184)
                    k_false269 = self.k_false()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_false269.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 29, boolean_literal_StartIndex, success)

            pass
        return retval

    # $ANTLR end "boolean_literal"

    class t_alias_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.t_alias_return, self).__init__()

            self.tree = None




    # $ANTLR start "t_alias"
    # /home/szr/subquery/SQL2XML/YSmart.g:321:1: t_alias : alias_name= sql_identifier ;
    def t_alias(self, ):

        retval = self.t_alias_return()
        retval.start = self.input.LT(1)
        t_alias_StartIndex = self.input.index()
        root_0 = None

        alias_name = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 30):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:322:2: (alias_name= sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:322:4: alias_name= sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_t_alias2197)
                alias_name = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, alias_name.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 30, t_alias_StartIndex, success)

            pass
        return retval

    # $ANTLR end "t_alias"

    class c_alias_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.c_alias_return, self).__init__()

            self.tree = None




    # $ANTLR start "c_alias"
    # /home/szr/subquery/SQL2XML/YSmart.g:325:1: c_alias : ( ( ( k_as )? sql_identifier ) | k_as );
    def c_alias(self, ):

        retval = self.c_alias_return()
        retval.start = self.input.LT(1)
        c_alias_StartIndex = self.input.index()
        root_0 = None

        k_as270 = None

        sql_identifier271 = None

        k_as272 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 31):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:326:2: ( ( ( k_as )? sql_identifier ) | k_as )
                alt77 = 2
                LA77_0 = self.input.LA(1)

                if (LA77_0 == 100) :
                    LA77_1 = self.input.LA(2)

                    if ((VECTOR <= LA77_1 <= DOUBLEQUOTED_STRING) or LA77_1 == 91 or LA77_1 == 178 or LA77_1 == 180 or (211 <= LA77_1 <= 367) or (369 <= LA77_1 <= 387) or (390 <= LA77_1 <= 428) or (430 <= LA77_1 <= 439) or (442 <= LA77_1 <= 453) or LA77_1 == 455 or (460 <= LA77_1 <= 502) or (508 <= LA77_1 <= 528) or (530 <= LA77_1 <= 537) or (539 <= LA77_1 <= 546)) :
                        alt77 = 1
                    elif (LA77_1 == EOF) :
                        alt77 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 77, 1, self.input)

                        raise nvae

                elif ((VECTOR <= LA77_0 <= DOUBLEQUOTED_STRING) or LA77_0 == 91 or LA77_0 == 178 or LA77_0 == 180 or (211 <= LA77_0 <= 367) or (369 <= LA77_0 <= 387) or (390 <= LA77_0 <= 428) or (430 <= LA77_0 <= 439) or (442 <= LA77_0 <= 453) or LA77_0 == 455 or (460 <= LA77_0 <= 502) or (508 <= LA77_0 <= 528) or (530 <= LA77_0 <= 537) or (539 <= LA77_0 <= 546)) :
                    alt77 = 1
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 77, 0, self.input)

                    raise nvae

                if alt77 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:326:4: ( ( k_as )? sql_identifier )
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:326:4: ( ( k_as )? sql_identifier )
                    # /home/szr/subquery/SQL2XML/YSmart.g:326:5: ( k_as )? sql_identifier
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:326:5: ( k_as )?
                    alt76 = 2
                    LA76_0 = self.input.LA(1)

                    if (LA76_0 == 100) :
                        alt76 = 1
                    if alt76 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_as
                        pass 
                        self._state.following.append(self.FOLLOW_k_as_in_c_alias2210)
                        k_as270 = self.k_as()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_as270.tree)



                    self._state.following.append(self.FOLLOW_sql_identifier_in_c_alias2213)
                    sql_identifier271 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier271.tree)





                elif alt77 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:327:4: k_as
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_as_in_c_alias2220)
                    k_as272 = self.k_as()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_as272.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 31, c_alias_StartIndex, success)

            pass
        return retval

    # $ANTLR end "c_alias"

    class alias_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.alias_return, self).__init__()

            self.tree = None




    # $ANTLR start "alias"
    # /home/szr/subquery/SQL2XML/YSmart.g:330:1: alias : k_as ( sql_identifier )? ;
    def alias(self, ):

        retval = self.alias_return()
        retval.start = self.input.LT(1)
        alias_StartIndex = self.input.index()
        root_0 = None

        k_as273 = None

        sql_identifier274 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 32):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:331:2: ( k_as ( sql_identifier )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:331:4: k_as ( sql_identifier )?
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_as_in_alias2231)
                k_as273 = self.k_as()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_as273.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:331:9: ( sql_identifier )?
                alt78 = 2
                LA78_0 = self.input.LA(1)

                if ((VECTOR <= LA78_0 <= DOUBLEQUOTED_STRING) or LA78_0 == 91 or LA78_0 == 178 or LA78_0 == 180 or (211 <= LA78_0 <= 367) or (369 <= LA78_0 <= 387) or (390 <= LA78_0 <= 428) or (430 <= LA78_0 <= 439) or (442 <= LA78_0 <= 453) or LA78_0 == 455 or (460 <= LA78_0 <= 502) or (508 <= LA78_0 <= 528) or (530 <= LA78_0 <= 537) or (539 <= LA78_0 <= 546)) :
                    alt78 = 1
                if alt78 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: sql_identifier
                    pass 
                    self._state.following.append(self.FOLLOW_sql_identifier_in_alias2233)
                    sql_identifier274 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier274.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 32, alias_StartIndex, success)

            pass
        return retval

    # $ANTLR end "alias"

    class column_spec_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.column_spec_return, self).__init__()

            self.tree = None




    # $ANTLR start "column_spec"
    # /home/szr/subquery/SQL2XML/YSmart.g:334:1: column_spec : ( sql_identifier DOT sql_identifier DOT sql_identifier | sql_identifier DOT sql_identifier | sql_identifier | pseudo_column );
    def column_spec(self, ):

        retval = self.column_spec_return()
        retval.start = self.input.LT(1)
        column_spec_StartIndex = self.input.index()
        root_0 = None

        DOT276 = None
        DOT278 = None
        DOT281 = None
        sql_identifier275 = None

        sql_identifier277 = None

        sql_identifier279 = None

        sql_identifier280 = None

        sql_identifier282 = None

        sql_identifier283 = None

        pseudo_column284 = None


        DOT276_tree = None
        DOT278_tree = None
        DOT281_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 33):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:335:2: ( sql_identifier DOT sql_identifier DOT sql_identifier | sql_identifier DOT sql_identifier | sql_identifier | pseudo_column )
                alt79 = 4
                alt79 = self.dfa79.predict(self.input)
                if alt79 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:335:4: sql_identifier DOT sql_identifier DOT sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2245)
                    sql_identifier275 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier275.tree)
                    DOT276=self.match(self.input, DOT, self.FOLLOW_DOT_in_column_spec2247)
                    if self._state.backtracking == 0:

                        DOT276_tree = self._adaptor.createWithPayload(DOT276)
                        self._adaptor.addChild(root_0, DOT276_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2249)
                    sql_identifier277 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier277.tree)
                    DOT278=self.match(self.input, DOT, self.FOLLOW_DOT_in_column_spec2251)
                    if self._state.backtracking == 0:

                        DOT278_tree = self._adaptor.createWithPayload(DOT278)
                        self._adaptor.addChild(root_0, DOT278_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2253)
                    sql_identifier279 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier279.tree)


                elif alt79 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:336:4: sql_identifier DOT sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2258)
                    sql_identifier280 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier280.tree)
                    DOT281=self.match(self.input, DOT, self.FOLLOW_DOT_in_column_spec2260)
                    if self._state.backtracking == 0:

                        DOT281_tree = self._adaptor.createWithPayload(DOT281)
                        self._adaptor.addChild(root_0, DOT281_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2262)
                    sql_identifier282 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier282.tree)


                elif alt79 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:337:4: sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_column_spec2267)
                    sql_identifier283 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier283.tree)


                elif alt79 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:338:4: pseudo_column
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_pseudo_column_in_column_spec2272)
                    pseudo_column284 = self.pseudo_column()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, pseudo_column284.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 33, column_spec_StartIndex, success)

            pass
        return retval

    # $ANTLR end "column_spec"

    class pseudo_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.pseudo_column_return, self).__init__()

            self.tree = None




    # $ANTLR start "pseudo_column"
    # /home/szr/subquery/SQL2XML/YSmart.g:341:1: pseudo_column : ( k_null | k_sysdate | k_rowid | k_rownum | k_level | k_connect_by_isleaf | k_connect_by_iscycle | k_versions_starttime | k_versions_starscn | k_versions_endtime | k_versions_endscn | k_versions_xid | k_versions_operation | k_column_value | k_object_value | k_ora_rowscn | k_xmldata );
    def pseudo_column(self, ):

        retval = self.pseudo_column_return()
        retval.start = self.input.LT(1)
        pseudo_column_StartIndex = self.input.index()
        root_0 = None

        k_null285 = None

        k_sysdate286 = None

        k_rowid287 = None

        k_rownum288 = None

        k_level289 = None

        k_connect_by_isleaf290 = None

        k_connect_by_iscycle291 = None

        k_versions_starttime292 = None

        k_versions_starscn293 = None

        k_versions_endtime294 = None

        k_versions_endscn295 = None

        k_versions_xid296 = None

        k_versions_operation297 = None

        k_column_value298 = None

        k_object_value299 = None

        k_ora_rowscn300 = None

        k_xmldata301 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 34):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:342:2: ( k_null | k_sysdate | k_rowid | k_rownum | k_level | k_connect_by_isleaf | k_connect_by_iscycle | k_versions_starttime | k_versions_starscn | k_versions_endtime | k_versions_endscn | k_versions_xid | k_versions_operation | k_column_value | k_object_value | k_ora_rowscn | k_xmldata )
                alt80 = 17
                LA80 = self.input.LA(1)
                if LA80 == 160:
                    alt80 = 1
                elif LA80 == 192:
                    alt80 = 2
                elif LA80 == 178:
                    alt80 = 3
                elif LA80 == 180:
                    alt80 = 4
                elif LA80 == 144:
                    alt80 = 5
                elif LA80 == 408:
                    alt80 = 6
                elif LA80 == 407:
                    alt80 = 7
                elif LA80 == 507:
                    alt80 = 8
                elif LA80 == 506:
                    alt80 = 9
                elif LA80 == 504:
                    alt80 = 10
                elif LA80 == 503:
                    alt80 = 11
                elif LA80 == 508:
                    alt80 = 12
                elif LA80 == 505:
                    alt80 = 13
                elif LA80 == 406:
                    alt80 = 14
                elif LA80 == 452:
                    alt80 = 15
                elif LA80 == 453:
                    alt80 = 16
                elif LA80 == 510:
                    alt80 = 17
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 80, 0, self.input)

                    raise nvae

                if alt80 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:342:4: k_null
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_null_in_pseudo_column2283)
                    k_null285 = self.k_null()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_null285.tree)


                elif alt80 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:343:7: k_sysdate
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_sysdate_in_pseudo_column2291)
                    k_sysdate286 = self.k_sysdate()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_sysdate286.tree)


                elif alt80 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:344:4: k_rowid
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_rowid_in_pseudo_column2296)
                    k_rowid287 = self.k_rowid()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rowid287.tree)


                elif alt80 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:345:4: k_rownum
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_rownum_in_pseudo_column2301)
                    k_rownum288 = self.k_rownum()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rownum288.tree)


                elif alt80 == 5:
                    # /home/szr/subquery/SQL2XML/YSmart.g:346:4: k_level
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_level_in_pseudo_column2306)
                    k_level289 = self.k_level()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_level289.tree)


                elif alt80 == 6:
                    # /home/szr/subquery/SQL2XML/YSmart.g:347:4: k_connect_by_isleaf
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_connect_by_isleaf_in_pseudo_column2315)
                    k_connect_by_isleaf290 = self.k_connect_by_isleaf()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_connect_by_isleaf290.tree)


                elif alt80 == 7:
                    # /home/szr/subquery/SQL2XML/YSmart.g:348:4: k_connect_by_iscycle
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_connect_by_iscycle_in_pseudo_column2320)
                    k_connect_by_iscycle291 = self.k_connect_by_iscycle()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_connect_by_iscycle291.tree)


                elif alt80 == 8:
                    # /home/szr/subquery/SQL2XML/YSmart.g:349:4: k_versions_starttime
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_starttime_in_pseudo_column2325)
                    k_versions_starttime292 = self.k_versions_starttime()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_starttime292.tree)


                elif alt80 == 9:
                    # /home/szr/subquery/SQL2XML/YSmart.g:350:4: k_versions_starscn
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_starscn_in_pseudo_column2331)
                    k_versions_starscn293 = self.k_versions_starscn()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_starscn293.tree)


                elif alt80 == 10:
                    # /home/szr/subquery/SQL2XML/YSmart.g:351:4: k_versions_endtime
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_endtime_in_pseudo_column2336)
                    k_versions_endtime294 = self.k_versions_endtime()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_endtime294.tree)


                elif alt80 == 11:
                    # /home/szr/subquery/SQL2XML/YSmart.g:352:4: k_versions_endscn
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_endscn_in_pseudo_column2341)
                    k_versions_endscn295 = self.k_versions_endscn()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_endscn295.tree)


                elif alt80 == 12:
                    # /home/szr/subquery/SQL2XML/YSmart.g:353:4: k_versions_xid
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_xid_in_pseudo_column2347)
                    k_versions_xid296 = self.k_versions_xid()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_xid296.tree)


                elif alt80 == 13:
                    # /home/szr/subquery/SQL2XML/YSmart.g:354:4: k_versions_operation
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_versions_operation_in_pseudo_column2353)
                    k_versions_operation297 = self.k_versions_operation()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_versions_operation297.tree)


                elif alt80 == 14:
                    # /home/szr/subquery/SQL2XML/YSmart.g:355:4: k_column_value
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_column_value_in_pseudo_column2358)
                    k_column_value298 = self.k_column_value()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_column_value298.tree)


                elif alt80 == 15:
                    # /home/szr/subquery/SQL2XML/YSmart.g:356:4: k_object_value
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_object_value_in_pseudo_column2364)
                    k_object_value299 = self.k_object_value()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_object_value299.tree)


                elif alt80 == 16:
                    # /home/szr/subquery/SQL2XML/YSmart.g:357:4: k_ora_rowscn
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_ora_rowscn_in_pseudo_column2370)
                    k_ora_rowscn300 = self.k_ora_rowscn()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_ora_rowscn300.tree)


                elif alt80 == 17:
                    # /home/szr/subquery/SQL2XML/YSmart.g:358:4: k_xmldata
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_xmldata_in_pseudo_column2377)
                    k_xmldata301 = self.k_xmldata()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_xmldata301.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 34, pseudo_column_StartIndex, success)

            pass
        return retval

    # $ANTLR end "pseudo_column"

    class function_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.function_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "function_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:361:1: function_name : ( sql_identifier DOT sql_identifier DOT sql_identifier | sql_identifier DOT sql_identifier | sql_identifier );
    def function_name(self, ):

        retval = self.function_name_return()
        retval.start = self.input.LT(1)
        function_name_StartIndex = self.input.index()
        root_0 = None

        DOT303 = None
        DOT305 = None
        DOT308 = None
        sql_identifier302 = None

        sql_identifier304 = None

        sql_identifier306 = None

        sql_identifier307 = None

        sql_identifier309 = None

        sql_identifier310 = None


        DOT303_tree = None
        DOT305_tree = None
        DOT308_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 35):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:362:2: ( sql_identifier DOT sql_identifier DOT sql_identifier | sql_identifier DOT sql_identifier | sql_identifier )
                alt81 = 3
                alt81 = self.dfa81.predict(self.input)
                if alt81 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:362:4: sql_identifier DOT sql_identifier DOT sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2388)
                    sql_identifier302 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier302.tree)
                    DOT303=self.match(self.input, DOT, self.FOLLOW_DOT_in_function_name2390)
                    if self._state.backtracking == 0:

                        DOT303_tree = self._adaptor.createWithPayload(DOT303)
                        self._adaptor.addChild(root_0, DOT303_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2392)
                    sql_identifier304 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier304.tree)
                    DOT305=self.match(self.input, DOT, self.FOLLOW_DOT_in_function_name2394)
                    if self._state.backtracking == 0:

                        DOT305_tree = self._adaptor.createWithPayload(DOT305)
                        self._adaptor.addChild(root_0, DOT305_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2396)
                    sql_identifier306 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier306.tree)


                elif alt81 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:363:4: sql_identifier DOT sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2401)
                    sql_identifier307 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier307.tree)
                    DOT308=self.match(self.input, DOT, self.FOLLOW_DOT_in_function_name2403)
                    if self._state.backtracking == 0:

                        DOT308_tree = self._adaptor.createWithPayload(DOT308)
                        self._adaptor.addChild(root_0, DOT308_tree)

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2405)
                    sql_identifier309 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier309.tree)


                elif alt81 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:364:4: sql_identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_identifier_in_function_name2410)
                    sql_identifier310 = self.sql_identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_identifier310.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 35, function_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "function_name"

    class identifier_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.identifier_return, self).__init__()

            self.tree = None




    # $ANTLR start "identifier"
    # /home/szr/subquery/SQL2XML/YSmart.g:367:1: identifier : ( VECTOR | PATH | ID | DOUBLEQUOTED_STRING );
    def identifier(self, ):

        retval = self.identifier_return()
        retval.start = self.input.LT(1)
        identifier_StartIndex = self.input.index()
        root_0 = None

        set311 = None

        set311_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 36):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:368:2: ( VECTOR | PATH | ID | DOUBLEQUOTED_STRING )
                # /home/szr/subquery/SQL2XML/YSmart.g:
                pass 
                root_0 = self._adaptor.nil()

                set311 = self.input.LT(1)
                if (VECTOR <= self.input.LA(1) <= DOUBLEQUOTED_STRING):
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set311))
                    self._state.errorRecovery = False

                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 36, identifier_StartIndex, success)

            pass
        return retval

    # $ANTLR end "identifier"

    class sql_identifier_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.sql_identifier_return, self).__init__()

            self.tree = None




    # $ANTLR start "sql_identifier"
    # /home/szr/subquery/SQL2XML/YSmart.g:375:1: sql_identifier : ( identifier | keyword | k_rowid | k_rownum );
    def sql_identifier(self, ):

        retval = self.sql_identifier_return()
        retval.start = self.input.LT(1)
        sql_identifier_StartIndex = self.input.index()
        root_0 = None

        identifier312 = None

        keyword313 = None

        k_rowid314 = None

        k_rownum315 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 37):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:376:2: ( identifier | keyword | k_rowid | k_rownum )
                alt82 = 4
                LA82_0 = self.input.LA(1)

                if ((VECTOR <= LA82_0 <= DOUBLEQUOTED_STRING)) :
                    alt82 = 1
                elif (LA82_0 == 91 or (211 <= LA82_0 <= 367) or (369 <= LA82_0 <= 387) or (390 <= LA82_0 <= 428) or (430 <= LA82_0 <= 439) or (442 <= LA82_0 <= 453) or LA82_0 == 455 or (460 <= LA82_0 <= 502) or (508 <= LA82_0 <= 528) or (530 <= LA82_0 <= 537) or (539 <= LA82_0 <= 546)) :
                    alt82 = 2
                elif (LA82_0 == 178) :
                    alt82 = 3
                elif (LA82_0 == 180) :
                    alt82 = 4
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 82, 0, self.input)

                    raise nvae

                if alt82 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:376:4: identifier
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_identifier_in_sql_identifier2459)
                    identifier312 = self.identifier()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, identifier312.tree)


                elif alt82 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:377:7: keyword
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_keyword_in_sql_identifier2467)
                    keyword313 = self.keyword()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, keyword313.tree)


                elif alt82 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:378:4: k_rowid
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_rowid_in_sql_identifier2472)
                    k_rowid314 = self.k_rowid()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rowid314.tree)


                elif alt82 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:379:4: k_rownum
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_k_rownum_in_sql_identifier2477)
                    k_rownum315 = self.k_rownum()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rownum315.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 37, sql_identifier_StartIndex, success)

            pass
        return retval

    # $ANTLR end "sql_identifier"

    class table_reference_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.table_reference_list_return, self).__init__()

            self.tree = None




    # $ANTLR start "table_reference_list"
    # /home/szr/subquery/SQL2XML/YSmart.g:385:1: table_reference_list : ( ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )* ) ;
    def table_reference_list(self, ):

        retval = self.table_reference_list_return()
        retval.start = self.input.LT(1)
        table_reference_list_StartIndex = self.input.index()
        root_0 = None

        LPAREN320 = None
        RPAREN322 = None
        COMMA324 = None
        LPAREN329 = None
        RPAREN331 = None
        table_name316 = None

        t_alias317 = None

        kNN_join_clause318 = None

        join_clause319 = None

        join_clause321 = None

        table_reference323 = None

        table_name325 = None

        t_alias326 = None

        kNN_join_clause327 = None

        join_clause328 = None

        join_clause330 = None

        table_reference332 = None


        LPAREN320_tree = None
        RPAREN322_tree = None
        COMMA324_tree = None
        LPAREN329_tree = None
        RPAREN331_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 38):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:386:2: ( ( ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )* ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:386:4: ( ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )* )
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:386:4: ( ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:387:4: ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )*
                pass 
                # /home/szr/subquery/SQL2XML/YSmart.g:387:4: ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference )
                alt84 = 4
                alt84 = self.dfa84.predict(self.input)
                if alt84 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:5: ( table_name ( t_alias )? kNN_join_clause )
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:5: ( table_name ( t_alias )? kNN_join_clause )
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:6: table_name ( t_alias )? kNN_join_clause
                    pass 
                    self._state.following.append(self.FOLLOW_table_name_in_table_reference_list2497)
                    table_name316 = self.table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_name316.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:17: ( t_alias )?
                    alt83 = 2
                    LA83_0 = self.input.LA(1)

                    if ((VECTOR <= LA83_0 <= DOUBLEQUOTED_STRING) or LA83_0 == 178 or LA83_0 == 180 or (211 <= LA83_0 <= 367) or (369 <= LA83_0 <= 387) or (390 <= LA83_0 <= 428) or (430 <= LA83_0 <= 439) or (442 <= LA83_0 <= 453) or LA83_0 == 455 or (460 <= LA83_0 <= 502) or (508 <= LA83_0 <= 528) or (530 <= LA83_0 <= 537) or (539 <= LA83_0 <= 546)) :
                        alt83 = 1
                    elif (LA83_0 == 91) :
                        LA83_2 = self.input.LA(2)

                        if (LA83_2 == 91) :
                            alt83 = 1
                    if alt83 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: t_alias
                        pass 
                        self._state.following.append(self.FOLLOW_t_alias_in_table_reference_list2499)
                        t_alias317 = self.t_alias()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, t_alias317.tree)



                    self._state.following.append(self.FOLLOW_kNN_join_clause_in_table_reference_list2502)
                    kNN_join_clause318 = self.kNN_join_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, kNN_join_clause318.tree)





                elif alt84 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:43: join_clause
                    pass 
                    self._state.following.append(self.FOLLOW_join_clause_in_table_reference_list2505)
                    join_clause319 = self.join_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, join_clause319.tree)


                elif alt84 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:55: ( LPAREN join_clause RPAREN )
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:55: ( LPAREN join_clause RPAREN )
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:56: LPAREN join_clause RPAREN
                    pass 
                    LPAREN320=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_table_reference_list2508)
                    if self._state.backtracking == 0:

                        LPAREN320_tree = self._adaptor.createWithPayload(LPAREN320)
                        self._adaptor.addChild(root_0, LPAREN320_tree)

                    self._state.following.append(self.FOLLOW_join_clause_in_table_reference_list2510)
                    join_clause321 = self.join_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, join_clause321.tree)
                    RPAREN322=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_table_reference_list2512)
                    if self._state.backtracking == 0:

                        RPAREN322_tree = self._adaptor.createWithPayload(RPAREN322)
                        self._adaptor.addChild(root_0, RPAREN322_tree)






                elif alt84 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:387:83: table_reference
                    pass 
                    self._state.following.append(self.FOLLOW_table_reference_in_table_reference_list2515)
                    table_reference323 = self.table_reference()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_reference323.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:388:4: ( COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference ) )*
                while True: #loop87
                    alt87 = 2
                    LA87_0 = self.input.LA(1)

                    if (LA87_0 == COMMA) :
                        alt87 = 1


                    if alt87 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:388:5: COMMA ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference )
                        pass 
                        COMMA324=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_table_reference_list2522)
                        if self._state.backtracking == 0:

                            COMMA324_tree = self._adaptor.createWithPayload(COMMA324)
                            self._adaptor.addChild(root_0, COMMA324_tree)

                        # /home/szr/subquery/SQL2XML/YSmart.g:388:11: ( ( table_name ( t_alias )? kNN_join_clause ) | join_clause | ( LPAREN join_clause RPAREN ) | table_reference )
                        alt86 = 4
                        alt86 = self.dfa86.predict(self.input)
                        if alt86 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:12: ( table_name ( t_alias )? kNN_join_clause )
                            pass 
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:12: ( table_name ( t_alias )? kNN_join_clause )
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:13: table_name ( t_alias )? kNN_join_clause
                            pass 
                            self._state.following.append(self.FOLLOW_table_name_in_table_reference_list2526)
                            table_name325 = self.table_name()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, table_name325.tree)
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:24: ( t_alias )?
                            alt85 = 2
                            LA85_0 = self.input.LA(1)

                            if ((VECTOR <= LA85_0 <= DOUBLEQUOTED_STRING) or LA85_0 == 178 or LA85_0 == 180 or (211 <= LA85_0 <= 367) or (369 <= LA85_0 <= 387) or (390 <= LA85_0 <= 428) or (430 <= LA85_0 <= 439) or (442 <= LA85_0 <= 453) or LA85_0 == 455 or (460 <= LA85_0 <= 502) or (508 <= LA85_0 <= 528) or (530 <= LA85_0 <= 537) or (539 <= LA85_0 <= 546)) :
                                alt85 = 1
                            elif (LA85_0 == 91) :
                                LA85_2 = self.input.LA(2)

                                if (LA85_2 == 91) :
                                    alt85 = 1
                            if alt85 == 1:
                                # /home/szr/subquery/SQL2XML/YSmart.g:0:0: t_alias
                                pass 
                                self._state.following.append(self.FOLLOW_t_alias_in_table_reference_list2528)
                                t_alias326 = self.t_alias()

                                self._state.following.pop()
                                if self._state.backtracking == 0:
                                    self._adaptor.addChild(root_0, t_alias326.tree)



                            self._state.following.append(self.FOLLOW_kNN_join_clause_in_table_reference_list2531)
                            kNN_join_clause327 = self.kNN_join_clause()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, kNN_join_clause327.tree)





                        elif alt86 == 2:
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:50: join_clause
                            pass 
                            self._state.following.append(self.FOLLOW_join_clause_in_table_reference_list2534)
                            join_clause328 = self.join_clause()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, join_clause328.tree)


                        elif alt86 == 3:
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:62: ( LPAREN join_clause RPAREN )
                            pass 
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:62: ( LPAREN join_clause RPAREN )
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:63: LPAREN join_clause RPAREN
                            pass 
                            LPAREN329=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_table_reference_list2537)
                            if self._state.backtracking == 0:

                                LPAREN329_tree = self._adaptor.createWithPayload(LPAREN329)
                                self._adaptor.addChild(root_0, LPAREN329_tree)

                            self._state.following.append(self.FOLLOW_join_clause_in_table_reference_list2539)
                            join_clause330 = self.join_clause()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, join_clause330.tree)
                            RPAREN331=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_table_reference_list2541)
                            if self._state.backtracking == 0:

                                RPAREN331_tree = self._adaptor.createWithPayload(RPAREN331)
                                self._adaptor.addChild(root_0, RPAREN331_tree)






                        elif alt86 == 4:
                            # /home/szr/subquery/SQL2XML/YSmart.g:388:90: table_reference
                            pass 
                            self._state.following.append(self.FOLLOW_table_reference_in_table_reference_list2544)
                            table_reference332 = self.table_reference()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, table_reference332.tree)





                    else:
                        break #loop87






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 38, table_reference_list_StartIndex, success)

            pass
        return retval

    # $ANTLR end "table_reference_list"

    class table_reference_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.table_reference_return, self).__init__()

            self.tree = None




    # $ANTLR start "table_reference"
    # /home/szr/subquery/SQL2XML/YSmart.g:391:1: table_reference : query_table_expression ;
    def table_reference(self, ):

        retval = self.table_reference_return()
        retval.start = self.input.LT(1)
        table_reference_StartIndex = self.input.index()
        root_0 = None

        query_table_expression333 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 39):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:392:2: ( query_table_expression )
                # /home/szr/subquery/SQL2XML/YSmart.g:392:4: query_table_expression
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_query_table_expression_in_table_reference2573)
                query_table_expression333 = self.query_table_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, query_table_expression333.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 39, table_reference_StartIndex, success)

            pass
        return retval

    # $ANTLR end "table_reference"

    class query_table_expression_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.query_table_expression_return, self).__init__()

            self.tree = None




    # $ANTLR start "query_table_expression"
    # /home/szr/subquery/SQL2XML/YSmart.g:394:1: query_table_expression : ( ( schema_name DOT )? table_name ( t_alias )? | subquery t_alias | LPAREN subquery RPAREN t_alias );
    def query_table_expression(self, ):

        retval = self.query_table_expression_return()
        retval.start = self.input.LT(1)
        query_table_expression_StartIndex = self.input.index()
        root_0 = None

        DOT335 = None
        LPAREN340 = None
        RPAREN342 = None
        schema_name334 = None

        table_name336 = None

        t_alias337 = None

        subquery338 = None

        t_alias339 = None

        subquery341 = None

        t_alias343 = None


        DOT335_tree = None
        LPAREN340_tree = None
        RPAREN342_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 40):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:395:2: ( ( schema_name DOT )? table_name ( t_alias )? | subquery t_alias | LPAREN subquery RPAREN t_alias )
                alt90 = 3
                LA90_0 = self.input.LA(1)

                if ((VECTOR <= LA90_0 <= DOUBLEQUOTED_STRING) or LA90_0 == 91 or LA90_0 == 178 or LA90_0 == 180 or (211 <= LA90_0 <= 367) or (369 <= LA90_0 <= 387) or (390 <= LA90_0 <= 428) or (430 <= LA90_0 <= 439) or (442 <= LA90_0 <= 453) or LA90_0 == 455 or (460 <= LA90_0 <= 502) or (508 <= LA90_0 <= 528) or (530 <= LA90_0 <= 537) or (539 <= LA90_0 <= 546)) :
                    alt90 = 1
                elif (LA90_0 == LPAREN) :
                    LA90_5 = self.input.LA(2)

                    if (self.synpred183_YSmart()) :
                        alt90 = 2
                    elif (True) :
                        alt90 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 90, 5, self.input)

                        raise nvae

                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 90, 0, self.input)

                    raise nvae

                if alt90 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:396:3: ( schema_name DOT )? table_name ( t_alias )?
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:396:3: ( schema_name DOT )?
                    alt88 = 2
                    LA88_0 = self.input.LA(1)

                    if ((VECTOR <= LA88_0 <= DOUBLEQUOTED_STRING)) :
                        LA88_1 = self.input.LA(2)

                        if (LA88_1 == DOT) :
                            alt88 = 1
                    elif (LA88_0 == 91 or (211 <= LA88_0 <= 367) or (369 <= LA88_0 <= 387) or (390 <= LA88_0 <= 428) or (430 <= LA88_0 <= 439) or (442 <= LA88_0 <= 453) or LA88_0 == 455 or (460 <= LA88_0 <= 502) or (508 <= LA88_0 <= 528) or (530 <= LA88_0 <= 537) or (539 <= LA88_0 <= 546)) :
                        LA88_2 = self.input.LA(2)

                        if (LA88_2 == DOT) :
                            alt88 = 1
                    elif (LA88_0 == 178) :
                        LA88_3 = self.input.LA(2)

                        if (LA88_3 == DOT) :
                            alt88 = 1
                    elif (LA88_0 == 180) :
                        LA88_4 = self.input.LA(2)

                        if (LA88_4 == DOT) :
                            alt88 = 1
                    if alt88 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:396:5: schema_name DOT
                        pass 
                        self._state.following.append(self.FOLLOW_schema_name_in_query_table_expression2589)
                        schema_name334 = self.schema_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, schema_name334.tree)
                        DOT335=self.match(self.input, DOT, self.FOLLOW_DOT_in_query_table_expression2591)
                        if self._state.backtracking == 0:

                            DOT335_tree = self._adaptor.createWithPayload(DOT335)
                            self._adaptor.addChild(root_0, DOT335_tree)




                    self._state.following.append(self.FOLLOW_table_name_in_query_table_expression2595)
                    table_name336 = self.table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_name336.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:396:34: ( t_alias )?
                    alt89 = 2
                    alt89 = self.dfa89.predict(self.input)
                    if alt89 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: t_alias
                        pass 
                        self._state.following.append(self.FOLLOW_t_alias_in_query_table_expression2597)
                        t_alias337 = self.t_alias()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, t_alias337.tree)





                elif alt90 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:397:4: subquery t_alias
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_subquery_in_query_table_expression2603)
                    subquery338 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery338.tree)
                    self._state.following.append(self.FOLLOW_t_alias_in_query_table_expression2605)
                    t_alias339 = self.t_alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, t_alias339.tree)


                elif alt90 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:398:10: LPAREN subquery RPAREN t_alias
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN340=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_query_table_expression2616)
                    if self._state.backtracking == 0:

                        LPAREN340_tree = self._adaptor.createWithPayload(LPAREN340)
                        self._adaptor.addChild(root_0, LPAREN340_tree)

                    self._state.following.append(self.FOLLOW_subquery_in_query_table_expression2618)
                    subquery341 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery341.tree)
                    RPAREN342=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_query_table_expression2620)
                    if self._state.backtracking == 0:

                        RPAREN342_tree = self._adaptor.createWithPayload(RPAREN342)
                        self._adaptor.addChild(root_0, RPAREN342_tree)

                    self._state.following.append(self.FOLLOW_t_alias_in_query_table_expression2622)
                    t_alias343 = self.t_alias()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, t_alias343.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 40, query_table_expression_StartIndex, success)

            pass
        return retval

    # $ANTLR end "query_table_expression"

    class join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.join_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "join_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:400:1: join_clause : table_reference ( inner_cross_join_clause | outer_join_clause )+ ;
    def join_clause(self, ):

        retval = self.join_clause_return()
        retval.start = self.input.LT(1)
        join_clause_StartIndex = self.input.index()
        root_0 = None

        table_reference344 = None

        inner_cross_join_clause345 = None

        outer_join_clause346 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 41):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:401:2: ( table_reference ( inner_cross_join_clause | outer_join_clause )+ )
                # /home/szr/subquery/SQL2XML/YSmart.g:401:4: table_reference ( inner_cross_join_clause | outer_join_clause )+
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_table_reference_in_join_clause2632)
                table_reference344 = self.table_reference()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference344.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:401:20: ( inner_cross_join_clause | outer_join_clause )+
                cnt91 = 0
                while True: #loop91
                    alt91 = 3
                    alt91 = self.dfa91.predict(self.input)
                    if alt91 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:401:21: inner_cross_join_clause
                        pass 
                        self._state.following.append(self.FOLLOW_inner_cross_join_clause_in_join_clause2635)
                        inner_cross_join_clause345 = self.inner_cross_join_clause()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, inner_cross_join_clause345.tree)


                    elif alt91 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:401:45: outer_join_clause
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_clause_in_join_clause2637)
                        outer_join_clause346 = self.outer_join_clause()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_clause346.tree)


                    else:
                        if cnt91 >= 1:
                            break #loop91

                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        eee = EarlyExitException(91, self.input)
                        raise eee

                    cnt91 += 1



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 41, join_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "join_clause"

    class inner_cross_join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.inner_cross_join_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "inner_cross_join_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:403:1: inner_cross_join_clause : ( ( k_inner )? k_join table_reference ( ( k_on sql_condition ) | ( k_using LPAREN column_specs RPAREN ) ) | ( k_cross | k_natural ( k_inner )? ) ( k_join table_reference ) );
    def inner_cross_join_clause(self, ):

        retval = self.inner_cross_join_clause_return()
        retval.start = self.input.LT(1)
        inner_cross_join_clause_StartIndex = self.input.index()
        root_0 = None

        LPAREN353 = None
        RPAREN355 = None
        k_inner347 = None

        k_join348 = None

        table_reference349 = None

        k_on350 = None

        sql_condition351 = None

        k_using352 = None

        column_specs354 = None

        k_cross356 = None

        k_natural357 = None

        k_inner358 = None

        k_join359 = None

        table_reference360 = None


        LPAREN353_tree = None
        RPAREN355_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 42):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:404:2: ( ( k_inner )? k_join table_reference ( ( k_on sql_condition ) | ( k_using LPAREN column_specs RPAREN ) ) | ( k_cross | k_natural ( k_inner )? ) ( k_join table_reference ) )
                alt96 = 2
                LA96_0 = self.input.LA(1)

                if (LA96_0 == 426 or LA96_0 == 429) :
                    alt96 = 1
                elif (LA96_0 == 413 or LA96_0 == 444) :
                    alt96 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 96, 0, self.input)

                    raise nvae

                if alt96 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:404:4: ( k_inner )? k_join table_reference ( ( k_on sql_condition ) | ( k_using LPAREN column_specs RPAREN ) )
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:404:4: ( k_inner )?
                    alt92 = 2
                    LA92_0 = self.input.LA(1)

                    if (LA92_0 == 426) :
                        alt92 = 1
                    if alt92 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_inner
                        pass 
                        self._state.following.append(self.FOLLOW_k_inner_in_inner_cross_join_clause2649)
                        k_inner347 = self.k_inner()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_inner347.tree)



                    self._state.following.append(self.FOLLOW_k_join_in_inner_cross_join_clause2652)
                    k_join348 = self.k_join()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_join348.tree)
                    self._state.following.append(self.FOLLOW_table_reference_in_inner_cross_join_clause2654)
                    table_reference349 = self.table_reference()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_reference349.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:404:36: ( ( k_on sql_condition ) | ( k_using LPAREN column_specs RPAREN ) )
                    alt93 = 2
                    LA93_0 = self.input.LA(1)

                    if (LA93_0 == 164) :
                        alt93 = 1
                    elif (LA93_0 == 388) :
                        alt93 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 93, 0, self.input)

                        raise nvae

                    if alt93 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:37: ( k_on sql_condition )
                        pass 
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:37: ( k_on sql_condition )
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:38: k_on sql_condition
                        pass 
                        self._state.following.append(self.FOLLOW_k_on_in_inner_cross_join_clause2658)
                        k_on350 = self.k_on()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_on350.tree)
                        self._state.following.append(self.FOLLOW_sql_condition_in_inner_cross_join_clause2660)
                        sql_condition351 = self.sql_condition()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_condition351.tree)





                    elif alt93 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:58: ( k_using LPAREN column_specs RPAREN )
                        pass 
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:58: ( k_using LPAREN column_specs RPAREN )
                        # /home/szr/subquery/SQL2XML/YSmart.g:404:59: k_using LPAREN column_specs RPAREN
                        pass 
                        self._state.following.append(self.FOLLOW_k_using_in_inner_cross_join_clause2664)
                        k_using352 = self.k_using()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_using352.tree)
                        LPAREN353=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_inner_cross_join_clause2666)
                        if self._state.backtracking == 0:

                            LPAREN353_tree = self._adaptor.createWithPayload(LPAREN353)
                            self._adaptor.addChild(root_0, LPAREN353_tree)

                        self._state.following.append(self.FOLLOW_column_specs_in_inner_cross_join_clause2668)
                        column_specs354 = self.column_specs()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, column_specs354.tree)
                        RPAREN355=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_inner_cross_join_clause2670)
                        if self._state.backtracking == 0:

                            RPAREN355_tree = self._adaptor.createWithPayload(RPAREN355)
                            self._adaptor.addChild(root_0, RPAREN355_tree)









                elif alt96 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:405:7: ( k_cross | k_natural ( k_inner )? ) ( k_join table_reference )
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:405:7: ( k_cross | k_natural ( k_inner )? )
                    alt95 = 2
                    LA95_0 = self.input.LA(1)

                    if (LA95_0 == 413) :
                        alt95 = 1
                    elif (LA95_0 == 444) :
                        alt95 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 95, 0, self.input)

                        raise nvae

                    if alt95 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:405:8: k_cross
                        pass 
                        self._state.following.append(self.FOLLOW_k_cross_in_inner_cross_join_clause2681)
                        k_cross356 = self.k_cross()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_cross356.tree)


                    elif alt95 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:405:18: k_natural ( k_inner )?
                        pass 
                        self._state.following.append(self.FOLLOW_k_natural_in_inner_cross_join_clause2685)
                        k_natural357 = self.k_natural()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_natural357.tree)
                        # /home/szr/subquery/SQL2XML/YSmart.g:405:28: ( k_inner )?
                        alt94 = 2
                        LA94_0 = self.input.LA(1)

                        if (LA94_0 == 426) :
                            alt94 = 1
                        if alt94 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_inner
                            pass 
                            self._state.following.append(self.FOLLOW_k_inner_in_inner_cross_join_clause2687)
                            k_inner358 = self.k_inner()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                self._adaptor.addChild(root_0, k_inner358.tree)






                    # /home/szr/subquery/SQL2XML/YSmart.g:405:38: ( k_join table_reference )
                    # /home/szr/subquery/SQL2XML/YSmart.g:405:39: k_join table_reference
                    pass 
                    self._state.following.append(self.FOLLOW_k_join_in_inner_cross_join_clause2692)
                    k_join359 = self.k_join()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_join359.tree)
                    self._state.following.append(self.FOLLOW_table_reference_in_inner_cross_join_clause2694)
                    table_reference360 = self.table_reference()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_reference360.tree)





                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 42, inner_cross_join_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "inner_cross_join_clause"

    class outer_join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.outer_join_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "outer_join_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:407:1: outer_join_clause : ( outer_join_type k_join | k_natural ( outer_join_type )? k_join ) table_reference ( k_on sql_condition | k_using LPAREN column_specs RPAREN )? ;
    def outer_join_clause(self, ):

        retval = self.outer_join_clause_return()
        retval.start = self.input.LT(1)
        outer_join_clause_StartIndex = self.input.index()
        root_0 = None

        LPAREN370 = None
        RPAREN372 = None
        outer_join_type361 = None

        k_join362 = None

        k_natural363 = None

        outer_join_type364 = None

        k_join365 = None

        table_reference366 = None

        k_on367 = None

        sql_condition368 = None

        k_using369 = None

        column_specs371 = None


        LPAREN370_tree = None
        RPAREN372_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 43):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:408:2: ( ( outer_join_type k_join | k_natural ( outer_join_type )? k_join ) table_reference ( k_on sql_condition | k_using LPAREN column_specs RPAREN )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:408:4: ( outer_join_type k_join | k_natural ( outer_join_type )? k_join ) table_reference ( k_on sql_condition | k_using LPAREN column_specs RPAREN )?
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:408:4: ( outer_join_type k_join | k_natural ( outer_join_type )? k_join )
                alt98 = 2
                LA98_0 = self.input.LA(1)

                if (LA98_0 == 422 or LA98_0 == 435 or LA98_0 == 477) :
                    alt98 = 1
                elif (LA98_0 == 444) :
                    alt98 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 98, 0, self.input)

                    raise nvae

                if alt98 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:408:6: outer_join_type k_join
                    pass 
                    self._state.following.append(self.FOLLOW_outer_join_type_in_outer_join_clause2715)
                    outer_join_type361 = self.outer_join_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, outer_join_type361.tree)
                    self._state.following.append(self.FOLLOW_k_join_in_outer_join_clause2717)
                    k_join362 = self.k_join()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_join362.tree)


                elif alt98 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:409:5: k_natural ( outer_join_type )? k_join
                    pass 
                    self._state.following.append(self.FOLLOW_k_natural_in_outer_join_clause2723)
                    k_natural363 = self.k_natural()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_natural363.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:409:15: ( outer_join_type )?
                    alt97 = 2
                    LA97_0 = self.input.LA(1)

                    if (LA97_0 == 422 or LA97_0 == 435 or LA97_0 == 477) :
                        alt97 = 1
                    if alt97 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:409:17: outer_join_type
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_type_in_outer_join_clause2727)
                        outer_join_type364 = self.outer_join_type()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_type364.tree)



                    self._state.following.append(self.FOLLOW_k_join_in_outer_join_clause2732)
                    k_join365 = self.k_join()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_join365.tree)



                self._state.following.append(self.FOLLOW_table_reference_in_outer_join_clause2740)
                table_reference366 = self.table_reference()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference366.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:411:19: ( k_on sql_condition | k_using LPAREN column_specs RPAREN )?
                alt99 = 3
                LA99_0 = self.input.LA(1)

                if (LA99_0 == 164) :
                    alt99 = 1
                elif (LA99_0 == 388) :
                    alt99 = 2
                if alt99 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:411:21: k_on sql_condition
                    pass 
                    self._state.following.append(self.FOLLOW_k_on_in_outer_join_clause2744)
                    k_on367 = self.k_on()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_on367.tree)
                    self._state.following.append(self.FOLLOW_sql_condition_in_outer_join_clause2746)
                    sql_condition368 = self.sql_condition()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_condition368.tree)


                elif alt99 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:411:42: k_using LPAREN column_specs RPAREN
                    pass 
                    self._state.following.append(self.FOLLOW_k_using_in_outer_join_clause2750)
                    k_using369 = self.k_using()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_using369.tree)
                    LPAREN370=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_outer_join_clause2752)
                    if self._state.backtracking == 0:

                        LPAREN370_tree = self._adaptor.createWithPayload(LPAREN370)
                        self._adaptor.addChild(root_0, LPAREN370_tree)

                    self._state.following.append(self.FOLLOW_column_specs_in_outer_join_clause2754)
                    column_specs371 = self.column_specs()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_specs371.tree)
                    RPAREN372=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_outer_join_clause2756)
                    if self._state.backtracking == 0:

                        RPAREN372_tree = self._adaptor.createWithPayload(RPAREN372)
                        self._adaptor.addChild(root_0, RPAREN372_tree)







                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 43, outer_join_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "outer_join_clause"

    class outer_join_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.outer_join_type_return, self).__init__()

            self.tree = None




    # $ANTLR start "outer_join_type"
    # /home/szr/subquery/SQL2XML/YSmart.g:413:1: outer_join_type : ( k_full | k_left | k_right ) ( k_outer )? ;
    def outer_join_type(self, ):

        retval = self.outer_join_type_return()
        retval.start = self.input.LT(1)
        outer_join_type_StartIndex = self.input.index()
        root_0 = None

        k_full373 = None

        k_left374 = None

        k_right375 = None

        k_outer376 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 44):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:414:3: ( ( k_full | k_left | k_right ) ( k_outer )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:414:5: ( k_full | k_left | k_right ) ( k_outer )?
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:414:5: ( k_full | k_left | k_right )
                alt100 = 3
                LA100 = self.input.LA(1)
                if LA100 == 422:
                    alt100 = 1
                elif LA100 == 435:
                    alt100 = 2
                elif LA100 == 477:
                    alt100 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 100, 0, self.input)

                    raise nvae

                if alt100 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:414:7: k_full
                    pass 
                    self._state.following.append(self.FOLLOW_k_full_in_outer_join_type2772)
                    k_full373 = self.k_full()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_full373.tree)


                elif alt100 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:414:16: k_left
                    pass 
                    self._state.following.append(self.FOLLOW_k_left_in_outer_join_type2776)
                    k_left374 = self.k_left()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_left374.tree)


                elif alt100 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:414:25: k_right
                    pass 
                    self._state.following.append(self.FOLLOW_k_right_in_outer_join_type2780)
                    k_right375 = self.k_right()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_right375.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:414:35: ( k_outer )?
                alt101 = 2
                LA101_0 = self.input.LA(1)

                if (LA101_0 == 454) :
                    alt101 = 1
                if alt101 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:414:37: k_outer
                    pass 
                    self._state.following.append(self.FOLLOW_k_outer_in_outer_join_type2786)
                    k_outer376 = self.k_outer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_outer376.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 44, outer_join_type_StartIndex, success)

            pass
        return retval

    # $ANTLR end "outer_join_type"

    class outer_join_sign_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.outer_join_sign_return, self).__init__()

            self.tree = None




    # $ANTLR start "outer_join_sign"
    # /home/szr/subquery/SQL2XML/YSmart.g:417:1: outer_join_sign : LPAREN PLUS RPAREN ;
    def outer_join_sign(self, ):

        retval = self.outer_join_sign_return()
        retval.start = self.input.LT(1)
        outer_join_sign_StartIndex = self.input.index()
        root_0 = None

        LPAREN377 = None
        PLUS378 = None
        RPAREN379 = None

        LPAREN377_tree = None
        PLUS378_tree = None
        RPAREN379_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 45):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:418:2: ( LPAREN PLUS RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:418:4: LPAREN PLUS RPAREN
                pass 
                root_0 = self._adaptor.nil()

                LPAREN377=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_outer_join_sign2808)
                if self._state.backtracking == 0:

                    LPAREN377_tree = self._adaptor.createWithPayload(LPAREN377)
                    self._adaptor.addChild(root_0, LPAREN377_tree)

                PLUS378=self.match(self.input, PLUS, self.FOLLOW_PLUS_in_outer_join_sign2810)
                if self._state.backtracking == 0:

                    PLUS378_tree = self._adaptor.createWithPayload(PLUS378)
                    self._adaptor.addChild(root_0, PLUS378_tree)

                RPAREN379=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_outer_join_sign2812)
                if self._state.backtracking == 0:

                    RPAREN379_tree = self._adaptor.createWithPayload(RPAREN379)
                    self._adaptor.addChild(root_0, RPAREN379_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 45, outer_join_sign_StartIndex, success)

            pass
        return retval

    # $ANTLR end "outer_join_sign"

    class kNN_join_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.kNN_join_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "kNN_join_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:420:1: kNN_join_clause : kNN_join_type k_join table_reference ( k_on ID EQ ID )? ;
    def kNN_join_clause(self, ):

        retval = self.kNN_join_clause_return()
        retval.start = self.input.LT(1)
        kNN_join_clause_StartIndex = self.input.index()
        root_0 = None

        ID384 = None
        EQ385 = None
        ID386 = None
        kNN_join_type380 = None

        k_join381 = None

        table_reference382 = None

        k_on383 = None


        ID384_tree = None
        EQ385_tree = None
        ID386_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 46):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:421:2: ( kNN_join_type k_join table_reference ( k_on ID EQ ID )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:421:4: kNN_join_type k_join table_reference ( k_on ID EQ ID )?
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_kNN_join_type_in_kNN_join_clause2822)
                kNN_join_type380 = self.kNN_join_type()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, kNN_join_type380.tree)
                self._state.following.append(self.FOLLOW_k_join_in_kNN_join_clause2824)
                k_join381 = self.k_join()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_join381.tree)
                self._state.following.append(self.FOLLOW_table_reference_in_kNN_join_clause2826)
                table_reference382 = self.table_reference()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, table_reference382.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:421:41: ( k_on ID EQ ID )?
                alt102 = 2
                LA102_0 = self.input.LA(1)

                if (LA102_0 == 164) :
                    alt102 = 1
                if alt102 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:421:43: k_on ID EQ ID
                    pass 
                    self._state.following.append(self.FOLLOW_k_on_in_kNN_join_clause2830)
                    k_on383 = self.k_on()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_on383.tree)
                    ID384=self.match(self.input, ID, self.FOLLOW_ID_in_kNN_join_clause2832)
                    if self._state.backtracking == 0:

                        ID384_tree = self._adaptor.createWithPayload(ID384)
                        self._adaptor.addChild(root_0, ID384_tree)

                    EQ385=self.match(self.input, EQ, self.FOLLOW_EQ_in_kNN_join_clause2834)
                    if self._state.backtracking == 0:

                        EQ385_tree = self._adaptor.createWithPayload(EQ385)
                        self._adaptor.addChild(root_0, EQ385_tree)

                    ID386=self.match(self.input, ID, self.FOLLOW_ID_in_kNN_join_clause2836)
                    if self._state.backtracking == 0:

                        ID386_tree = self._adaptor.createWithPayload(ID386)
                        self._adaptor.addChild(root_0, ID386_tree)







                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 46, kNN_join_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "kNN_join_clause"

    class kNN_join_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.kNN_join_type_return, self).__init__()

            self.tree = None




    # $ANTLR start "kNN_join_type"
    # /home/szr/subquery/SQL2XML/YSmart.g:423:1: kNN_join_type : 'KNN' LPAREN 'K=' NUMBER RPAREN ;
    def kNN_join_type(self, ):

        retval = self.kNN_join_type_return()
        retval.start = self.input.LT(1)
        kNN_join_type_StartIndex = self.input.index()
        root_0 = None

        string_literal387 = None
        LPAREN388 = None
        string_literal389 = None
        NUMBER390 = None
        RPAREN391 = None

        string_literal387_tree = None
        LPAREN388_tree = None
        string_literal389_tree = None
        NUMBER390_tree = None
        RPAREN391_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 47):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:424:2: ( 'KNN' LPAREN 'K=' NUMBER RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:424:4: 'KNN' LPAREN 'K=' NUMBER RPAREN
                pass 
                root_0 = self._adaptor.nil()

                string_literal387=self.match(self.input, 91, self.FOLLOW_91_in_kNN_join_type2849)
                if self._state.backtracking == 0:

                    string_literal387_tree = self._adaptor.createWithPayload(string_literal387)
                    self._adaptor.addChild(root_0, string_literal387_tree)

                LPAREN388=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_kNN_join_type2851)
                if self._state.backtracking == 0:

                    LPAREN388_tree = self._adaptor.createWithPayload(LPAREN388)
                    self._adaptor.addChild(root_0, LPAREN388_tree)

                string_literal389=self.match(self.input, 92, self.FOLLOW_92_in_kNN_join_type2853)
                if self._state.backtracking == 0:

                    string_literal389_tree = self._adaptor.createWithPayload(string_literal389)
                    self._adaptor.addChild(root_0, string_literal389_tree)

                NUMBER390=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_kNN_join_type2855)
                if self._state.backtracking == 0:

                    NUMBER390_tree = self._adaptor.createWithPayload(NUMBER390)
                    self._adaptor.addChild(root_0, NUMBER390_tree)

                RPAREN391=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_kNN_join_type2857)
                if self._state.backtracking == 0:

                    RPAREN391_tree = self._adaptor.createWithPayload(RPAREN391)
                    self._adaptor.addChild(root_0, RPAREN391_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 47, kNN_join_type_StartIndex, success)

            pass
        return retval

    # $ANTLR end "kNN_join_type"

    class table_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.table_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "table_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:426:1: table_name : sql_identifier ;
    def table_name(self, ):

        retval = self.table_name_return()
        retval.start = self.input.LT(1)
        table_name_StartIndex = self.input.index()
        root_0 = None

        sql_identifier392 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 48):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:427:2: ( sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:427:4: sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_table_name2867)
                sql_identifier392 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier392.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 48, table_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "table_name"

    class schema_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.schema_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "schema_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:429:1: schema_name : sql_identifier ;
    def schema_name(self, ):

        retval = self.schema_name_return()
        retval.start = self.input.LT(1)
        schema_name_StartIndex = self.input.index()
        root_0 = None

        sql_identifier393 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 49):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:430:2: ( sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:430:4: sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_schema_name2877)
                sql_identifier393 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier393.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 49, schema_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "schema_name"

    class column_specs_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.column_specs_return, self).__init__()

            self.tree = None




    # $ANTLR start "column_specs"
    # /home/szr/subquery/SQL2XML/YSmart.g:432:1: column_specs : column_spec ( COMMA column_spec )* ;
    def column_specs(self, ):

        retval = self.column_specs_return()
        retval.start = self.input.LT(1)
        column_specs_StartIndex = self.input.index()
        root_0 = None

        COMMA395 = None
        column_spec394 = None

        column_spec396 = None


        COMMA395_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 50):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:433:2: ( column_spec ( COMMA column_spec )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:433:4: column_spec ( COMMA column_spec )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_column_spec_in_column_specs2887)
                column_spec394 = self.column_spec()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_spec394.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:433:16: ( COMMA column_spec )*
                while True: #loop103
                    alt103 = 2
                    LA103_0 = self.input.LA(1)

                    if (LA103_0 == COMMA) :
                        alt103 = 1


                    if alt103 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:433:18: COMMA column_spec
                        pass 
                        COMMA395=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_column_specs2891)
                        if self._state.backtracking == 0:

                            COMMA395_tree = self._adaptor.createWithPayload(COMMA395)
                            self._adaptor.addChild(root_0, COMMA395_tree)

                        self._state.following.append(self.FOLLOW_column_spec_in_column_specs2893)
                        column_spec396 = self.column_spec()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, column_spec396.tree)


                    else:
                        break #loop103



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 50, column_specs_StartIndex, success)

            pass
        return retval

    # $ANTLR end "column_specs"

    class where_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.where_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "where_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:439:1: where_clause : k_where sql_condition -> ^( 't_where' k_where sql_condition ) ;
    def where_clause(self, ):

        retval = self.where_clause_return()
        retval.start = self.input.LT(1)
        where_clause_StartIndex = self.input.index()
        root_0 = None

        k_where397 = None

        sql_condition398 = None


        stream_sql_condition = RewriteRuleSubtreeStream(self._adaptor, "rule sql_condition")
        stream_k_where = RewriteRuleSubtreeStream(self._adaptor, "rule k_where")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 51):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:440:2: ( k_where sql_condition -> ^( 't_where' k_where sql_condition ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:440:4: k_where sql_condition
                pass 
                self._state.following.append(self.FOLLOW_k_where_in_where_clause2909)
                k_where397 = self.k_where()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_where.add(k_where397.tree)
                self._state.following.append(self.FOLLOW_sql_condition_in_where_clause2911)
                sql_condition398 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_sql_condition.add(sql_condition398.tree)

                # AST Rewrite
                # elements: k_where, T_WHERE, sql_condition
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 441:9: -> ^( 't_where' k_where sql_condition )
                    # /home/szr/subquery/SQL2XML/YSmart.g:441:12: ^( 't_where' k_where sql_condition )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_WHERE, "T_WHERE"), root_1)

                    self._adaptor.addChild(root_1, stream_k_where.nextTree())
                    self._adaptor.addChild(root_1, stream_sql_condition.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 51, where_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "where_clause"

    class having_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.having_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "having_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:447:1: having_clause : k_having sql_condition -> ^( 't_having' k_having sql_condition ) ;
    def having_clause(self, ):

        retval = self.having_clause_return()
        retval.start = self.input.LT(1)
        having_clause_StartIndex = self.input.index()
        root_0 = None

        k_having399 = None

        sql_condition400 = None


        stream_sql_condition = RewriteRuleSubtreeStream(self._adaptor, "rule sql_condition")
        stream_k_having = RewriteRuleSubtreeStream(self._adaptor, "rule k_having")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 52):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:448:2: ( k_having sql_condition -> ^( 't_having' k_having sql_condition ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:448:4: k_having sql_condition
                pass 
                self._state.following.append(self.FOLLOW_k_having_in_having_clause2943)
                k_having399 = self.k_having()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_having.add(k_having399.tree)
                self._state.following.append(self.FOLLOW_sql_condition_in_having_clause2945)
                sql_condition400 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_sql_condition.add(sql_condition400.tree)

                # AST Rewrite
                # elements: T_HAVING, sql_condition, k_having
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 449:9: -> ^( 't_having' k_having sql_condition )
                    # /home/szr/subquery/SQL2XML/YSmart.g:449:12: ^( 't_having' k_having sql_condition )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_HAVING, "T_HAVING"), root_1)

                    self._adaptor.addChild(root_1, stream_k_having.nextTree())
                    self._adaptor.addChild(root_1, stream_sql_condition.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 52, having_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "having_clause"

    class group_by_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.group_by_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "group_by_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:455:1: group_by_clause : k_group k_by group_by_exprs -> ^( 't_group_by' k_group k_by group_by_exprs ) ;
    def group_by_clause(self, ):

        retval = self.group_by_clause_return()
        retval.start = self.input.LT(1)
        group_by_clause_StartIndex = self.input.index()
        root_0 = None

        k_group401 = None

        k_by402 = None

        group_by_exprs403 = None


        stream_k_group = RewriteRuleSubtreeStream(self._adaptor, "rule k_group")
        stream_group_by_exprs = RewriteRuleSubtreeStream(self._adaptor, "rule group_by_exprs")
        stream_k_by = RewriteRuleSubtreeStream(self._adaptor, "rule k_by")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 53):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:456:2: ( k_group k_by group_by_exprs -> ^( 't_group_by' k_group k_by group_by_exprs ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:456:4: k_group k_by group_by_exprs
                pass 
                self._state.following.append(self.FOLLOW_k_group_in_group_by_clause2977)
                k_group401 = self.k_group()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_group.add(k_group401.tree)
                self._state.following.append(self.FOLLOW_k_by_in_group_by_clause2979)
                k_by402 = self.k_by()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_by.add(k_by402.tree)
                self._state.following.append(self.FOLLOW_group_by_exprs_in_group_by_clause2981)
                group_by_exprs403 = self.group_by_exprs()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_group_by_exprs.add(group_by_exprs403.tree)

                # AST Rewrite
                # elements: T_GROUP_BY, k_group, group_by_exprs, k_by
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 457:2: -> ^( 't_group_by' k_group k_by group_by_exprs )
                    # /home/szr/subquery/SQL2XML/YSmart.g:457:5: ^( 't_group_by' k_group k_by group_by_exprs )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_GROUP_BY, "T_GROUP_BY"), root_1)

                    self._adaptor.addChild(root_1, stream_k_group.nextTree())
                    self._adaptor.addChild(root_1, stream_k_by.nextTree())
                    self._adaptor.addChild(root_1, stream_group_by_exprs.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 53, group_by_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "group_by_clause"

    class group_by_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.group_by_exprs_return, self).__init__()

            self.tree = None




    # $ANTLR start "group_by_exprs"
    # /home/szr/subquery/SQL2XML/YSmart.g:459:1: group_by_exprs : group_by_expr ( COMMA group_by_expr )* ;
    def group_by_exprs(self, ):

        retval = self.group_by_exprs_return()
        retval.start = self.input.LT(1)
        group_by_exprs_StartIndex = self.input.index()
        root_0 = None

        COMMA405 = None
        group_by_expr404 = None

        group_by_expr406 = None


        COMMA405_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 54):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:460:2: ( group_by_expr ( COMMA group_by_expr )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:460:4: group_by_expr ( COMMA group_by_expr )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_group_by_expr_in_group_by_exprs3004)
                group_by_expr404 = self.group_by_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, group_by_expr404.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:460:18: ( COMMA group_by_expr )*
                while True: #loop104
                    alt104 = 2
                    LA104_0 = self.input.LA(1)

                    if (LA104_0 == COMMA) :
                        alt104 = 1


                    if alt104 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:460:20: COMMA group_by_expr
                        pass 
                        COMMA405=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_group_by_exprs3008)
                        if self._state.backtracking == 0:

                            COMMA405_tree = self._adaptor.createWithPayload(COMMA405)
                            self._adaptor.addChild(root_0, COMMA405_tree)

                        self._state.following.append(self.FOLLOW_group_by_expr_in_group_by_exprs3010)
                        group_by_expr406 = self.group_by_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, group_by_expr406.tree)


                    else:
                        break #loop104



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 54, group_by_exprs_StartIndex, success)

            pass
        return retval

    # $ANTLR end "group_by_exprs"

    class group_by_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.group_by_expr_return, self).__init__()

            self.tree = None




    # $ANTLR start "group_by_expr"
    # /home/szr/subquery/SQL2XML/YSmart.g:462:1: group_by_expr : ( rollup_cube_clause | grouping_sets_clause | grouping_expression_list );
    def group_by_expr(self, ):

        retval = self.group_by_expr_return()
        retval.start = self.input.LT(1)
        group_by_expr_StartIndex = self.input.index()
        root_0 = None

        rollup_cube_clause407 = None

        grouping_sets_clause408 = None

        grouping_expression_list409 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 55):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:463:2: ( rollup_cube_clause | grouping_sets_clause | grouping_expression_list )
                alt105 = 3
                alt105 = self.dfa105.predict(self.input)
                if alt105 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:463:4: rollup_cube_clause
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_rollup_cube_clause_in_group_by_expr3023)
                    rollup_cube_clause407 = self.rollup_cube_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, rollup_cube_clause407.tree)


                elif alt105 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:464:4: grouping_sets_clause
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_grouping_sets_clause_in_group_by_expr3028)
                    grouping_sets_clause408 = self.grouping_sets_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_sets_clause408.tree)


                elif alt105 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:465:4: grouping_expression_list
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_grouping_expression_list_in_group_by_expr3033)
                    grouping_expression_list409 = self.grouping_expression_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_expression_list409.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 55, group_by_expr_StartIndex, success)

            pass
        return retval

    # $ANTLR end "group_by_expr"

    class rollup_cube_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.rollup_cube_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "rollup_cube_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:467:1: rollup_cube_clause : ( k_rollup | k_cube ) LPAREN grouping_expression_list RPAREN ;
    def rollup_cube_clause(self, ):

        retval = self.rollup_cube_clause_return()
        retval.start = self.input.LT(1)
        rollup_cube_clause_StartIndex = self.input.index()
        root_0 = None

        LPAREN412 = None
        RPAREN414 = None
        k_rollup410 = None

        k_cube411 = None

        grouping_expression_list413 = None


        LPAREN412_tree = None
        RPAREN414_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 56):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:468:2: ( ( k_rollup | k_cube ) LPAREN grouping_expression_list RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:468:4: ( k_rollup | k_cube ) LPAREN grouping_expression_list RPAREN
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:468:4: ( k_rollup | k_cube )
                alt106 = 2
                LA106_0 = self.input.LA(1)

                if (LA106_0 == 478) :
                    alt106 = 1
                elif (LA106_0 == 414) :
                    alt106 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 106, 0, self.input)

                    raise nvae

                if alt106 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:468:6: k_rollup
                    pass 
                    self._state.following.append(self.FOLLOW_k_rollup_in_rollup_cube_clause3045)
                    k_rollup410 = self.k_rollup()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_rollup410.tree)


                elif alt106 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:468:17: k_cube
                    pass 
                    self._state.following.append(self.FOLLOW_k_cube_in_rollup_cube_clause3049)
                    k_cube411 = self.k_cube()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_cube411.tree)



                LPAREN412=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_rollup_cube_clause3053)
                if self._state.backtracking == 0:

                    LPAREN412_tree = self._adaptor.createWithPayload(LPAREN412)
                    self._adaptor.addChild(root_0, LPAREN412_tree)

                self._state.following.append(self.FOLLOW_grouping_expression_list_in_rollup_cube_clause3055)
                grouping_expression_list413 = self.grouping_expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_expression_list413.tree)
                RPAREN414=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_rollup_cube_clause3057)
                if self._state.backtracking == 0:

                    RPAREN414_tree = self._adaptor.createWithPayload(RPAREN414)
                    self._adaptor.addChild(root_0, RPAREN414_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 56, rollup_cube_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "rollup_cube_clause"

    class grouping_sets_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.grouping_sets_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "grouping_sets_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:470:1: grouping_sets_clause : k_grouping k_sets LPAREN grouping_expression_list RPAREN ;
    def grouping_sets_clause(self, ):

        retval = self.grouping_sets_clause_return()
        retval.start = self.input.LT(1)
        grouping_sets_clause_StartIndex = self.input.index()
        root_0 = None

        LPAREN417 = None
        RPAREN419 = None
        k_grouping415 = None

        k_sets416 = None

        grouping_expression_list418 = None


        LPAREN417_tree = None
        RPAREN419_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 57):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:471:2: ( k_grouping k_sets LPAREN grouping_expression_list RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:471:4: k_grouping k_sets LPAREN grouping_expression_list RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_grouping_in_grouping_sets_clause3067)
                k_grouping415 = self.k_grouping()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_grouping415.tree)
                self._state.following.append(self.FOLLOW_k_sets_in_grouping_sets_clause3069)
                k_sets416 = self.k_sets()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_sets416.tree)
                LPAREN417=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_grouping_sets_clause3071)
                if self._state.backtracking == 0:

                    LPAREN417_tree = self._adaptor.createWithPayload(LPAREN417)
                    self._adaptor.addChild(root_0, LPAREN417_tree)

                self._state.following.append(self.FOLLOW_grouping_expression_list_in_grouping_sets_clause3073)
                grouping_expression_list418 = self.grouping_expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_expression_list418.tree)
                RPAREN419=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_grouping_sets_clause3075)
                if self._state.backtracking == 0:

                    RPAREN419_tree = self._adaptor.createWithPayload(RPAREN419)
                    self._adaptor.addChild(root_0, RPAREN419_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 57, grouping_sets_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "grouping_sets_clause"

    class grouping_sets_exprs_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.grouping_sets_exprs_return, self).__init__()

            self.tree = None




    # $ANTLR start "grouping_sets_exprs"
    # /home/szr/subquery/SQL2XML/YSmart.g:473:1: grouping_sets_exprs : grouping_sets_expr ( COMMA grouping_sets_expr )* ;
    def grouping_sets_exprs(self, ):

        retval = self.grouping_sets_exprs_return()
        retval.start = self.input.LT(1)
        grouping_sets_exprs_StartIndex = self.input.index()
        root_0 = None

        COMMA421 = None
        grouping_sets_expr420 = None

        grouping_sets_expr422 = None


        COMMA421_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 58):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:474:2: ( grouping_sets_expr ( COMMA grouping_sets_expr )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:474:4: grouping_sets_expr ( COMMA grouping_sets_expr )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_grouping_sets_expr_in_grouping_sets_exprs3085)
                grouping_sets_expr420 = self.grouping_sets_expr()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, grouping_sets_expr420.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:474:23: ( COMMA grouping_sets_expr )*
                while True: #loop107
                    alt107 = 2
                    LA107_0 = self.input.LA(1)

                    if (LA107_0 == COMMA) :
                        alt107 = 1


                    if alt107 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:474:25: COMMA grouping_sets_expr
                        pass 
                        COMMA421=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_grouping_sets_exprs3089)
                        if self._state.backtracking == 0:

                            COMMA421_tree = self._adaptor.createWithPayload(COMMA421)
                            self._adaptor.addChild(root_0, COMMA421_tree)

                        self._state.following.append(self.FOLLOW_grouping_sets_expr_in_grouping_sets_exprs3091)
                        grouping_sets_expr422 = self.grouping_sets_expr()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_sets_expr422.tree)


                    else:
                        break #loop107



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 58, grouping_sets_exprs_StartIndex, success)

            pass
        return retval

    # $ANTLR end "grouping_sets_exprs"

    class grouping_sets_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.grouping_sets_expr_return, self).__init__()

            self.tree = None




    # $ANTLR start "grouping_sets_expr"
    # /home/szr/subquery/SQL2XML/YSmart.g:476:1: grouping_sets_expr : ( rollup_cube_clause | grouping_expression_list );
    def grouping_sets_expr(self, ):

        retval = self.grouping_sets_expr_return()
        retval.start = self.input.LT(1)
        grouping_sets_expr_StartIndex = self.input.index()
        root_0 = None

        rollup_cube_clause423 = None

        grouping_expression_list424 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 59):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:477:2: ( rollup_cube_clause | grouping_expression_list )
                alt108 = 2
                alt108 = self.dfa108.predict(self.input)
                if alt108 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:477:4: rollup_cube_clause
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_rollup_cube_clause_in_grouping_sets_expr3104)
                    rollup_cube_clause423 = self.rollup_cube_clause()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, rollup_cube_clause423.tree)


                elif alt108 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:477:25: grouping_expression_list
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_grouping_expression_list_in_grouping_sets_expr3108)
                    grouping_expression_list424 = self.grouping_expression_list()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, grouping_expression_list424.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 59, grouping_sets_expr_StartIndex, success)

            pass
        return retval

    # $ANTLR end "grouping_sets_expr"

    class sql_condition_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.sql_condition_return, self).__init__()

            self.tree = None




    # $ANTLR start "sql_condition"
    # /home/szr/subquery/SQL2XML/YSmart.g:479:1: sql_condition : condition_or ;
    def sql_condition(self, ):

        retval = self.sql_condition_return()
        retval.start = self.input.LT(1)
        sql_condition_StartIndex = self.input.index()
        root_0 = None

        condition_or425 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 60):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:480:2: ( condition_or )
                # /home/szr/subquery/SQL2XML/YSmart.g:480:4: condition_or
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_condition_or_in_sql_condition3118)
                condition_or425 = self.condition_or()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_or425.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 60, sql_condition_StartIndex, success)

            pass
        return retval

    # $ANTLR end "sql_condition"

    class condition_or_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_or_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_or"
    # /home/szr/subquery/SQL2XML/YSmart.g:482:1: condition_or : ( ( condition_or_part_first ( condition_or_part_next )+ -> ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* ) ) | condition_or_part_first );
    def condition_or(self, ):

        retval = self.condition_or_return()
        retval.start = self.input.LT(1)
        condition_or_StartIndex = self.input.index()
        root_0 = None

        condition_or_part_first426 = None

        condition_or_part_next427 = None

        condition_or_part_first428 = None


        stream_condition_or_part_first = RewriteRuleSubtreeStream(self._adaptor, "rule condition_or_part_first")
        stream_condition_or_part_next = RewriteRuleSubtreeStream(self._adaptor, "rule condition_or_part_next")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 61):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:483:2: ( ( condition_or_part_first ( condition_or_part_next )+ -> ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* ) ) | condition_or_part_first )
                alt110 = 2
                alt110 = self.dfa110.predict(self.input)
                if alt110 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:483:4: ( condition_or_part_first ( condition_or_part_next )+ -> ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* ) )
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:483:4: ( condition_or_part_first ( condition_or_part_next )+ -> ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* ) )
                    # /home/szr/subquery/SQL2XML/YSmart.g:483:5: condition_or_part_first ( condition_or_part_next )+
                    pass 
                    self._state.following.append(self.FOLLOW_condition_or_part_first_in_condition_or3129)
                    condition_or_part_first426 = self.condition_or_part_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_condition_or_part_first.add(condition_or_part_first426.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:483:29: ( condition_or_part_next )+
                    cnt109 = 0
                    while True: #loop109
                        alt109 = 2
                        LA109_0 = self.input.LA(1)

                        if (LA109_0 == 167) :
                            alt109 = 1


                        if alt109 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:0:0: condition_or_part_next
                            pass 
                            self._state.following.append(self.FOLLOW_condition_or_part_next_in_condition_or3131)
                            condition_or_part_next427 = self.condition_or_part_next()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                stream_condition_or_part_next.add(condition_or_part_next427.tree)


                        else:
                            if cnt109 >= 1:
                                break #loop109

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            eee = EarlyExitException(109, self.input)
                            raise eee

                        cnt109 += 1

                    # AST Rewrite
                    # elements: condition_or_part_first, condition_or_part_next
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 
                    if self._state.backtracking == 0:

                        retval.tree = root_0

                        if retval is not None:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                        else:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                        root_0 = self._adaptor.nil()
                        # 483:53: -> ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* )
                        # /home/szr/subquery/SQL2XML/YSmart.g:483:56: ^( T_COND_OR ^( T_COND_OR condition_or_part_first ) ( condition_or_part_next )* )
                        root_1 = self._adaptor.nil()
                        root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_OR, "T_COND_OR"), root_1)

                        # /home/szr/subquery/SQL2XML/YSmart.g:483:68: ^( T_COND_OR condition_or_part_first )
                        root_2 = self._adaptor.nil()
                        root_2 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_OR, "T_COND_OR"), root_2)

                        self._adaptor.addChild(root_2, stream_condition_or_part_first.nextTree())

                        self._adaptor.addChild(root_1, root_2)
                        # /home/szr/subquery/SQL2XML/YSmart.g:483:105: ( condition_or_part_next )*
                        while stream_condition_or_part_next.hasNext():
                            self._adaptor.addChild(root_1, stream_condition_or_part_next.nextTree())


                        stream_condition_or_part_next.reset();

                        self._adaptor.addChild(root_0, root_1)



                        retval.tree = root_0





                elif alt110 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:484:4: condition_or_part_first
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_or_part_first_in_condition_or3153)
                    condition_or_part_first428 = self.condition_or_part_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_or_part_first428.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 61, condition_or_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_or"

    class condition_or_part_first_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_or_part_first_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_or_part_first"
    # /home/szr/subquery/SQL2XML/YSmart.g:486:1: condition_or_part_first : condition_and ;
    def condition_or_part_first(self, ):

        retval = self.condition_or_part_first_return()
        retval.start = self.input.LT(1)
        condition_or_part_first_StartIndex = self.input.index()
        root_0 = None

        condition_and429 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 62):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:487:2: ( condition_and )
                # /home/szr/subquery/SQL2XML/YSmart.g:487:4: condition_and
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_condition_and_in_condition_or_part_first3163)
                condition_and429 = self.condition_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_and429.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 62, condition_or_part_first_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_or_part_first"

    class condition_or_part_next_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_or_part_next_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_or_part_next"
    # /home/szr/subquery/SQL2XML/YSmart.g:489:1: condition_or_part_next : k_or condition_and -> ^( T_COND_OR k_or condition_and ) ;
    def condition_or_part_next(self, ):

        retval = self.condition_or_part_next_return()
        retval.start = self.input.LT(1)
        condition_or_part_next_StartIndex = self.input.index()
        root_0 = None

        k_or430 = None

        condition_and431 = None


        stream_k_or = RewriteRuleSubtreeStream(self._adaptor, "rule k_or")
        stream_condition_and = RewriteRuleSubtreeStream(self._adaptor, "rule condition_and")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 63):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:490:2: ( k_or condition_and -> ^( T_COND_OR k_or condition_and ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:490:4: k_or condition_and
                pass 
                self._state.following.append(self.FOLLOW_k_or_in_condition_or_part_next3176)
                k_or430 = self.k_or()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_or.add(k_or430.tree)
                self._state.following.append(self.FOLLOW_condition_and_in_condition_or_part_next3178)
                condition_and431 = self.condition_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_condition_and.add(condition_and431.tree)

                # AST Rewrite
                # elements: condition_and, k_or
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 490:23: -> ^( T_COND_OR k_or condition_and )
                    # /home/szr/subquery/SQL2XML/YSmart.g:490:26: ^( T_COND_OR k_or condition_and )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_OR, "T_COND_OR"), root_1)

                    self._adaptor.addChild(root_1, stream_k_or.nextTree())
                    self._adaptor.addChild(root_1, stream_condition_and.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 63, condition_or_part_next_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_or_part_next"

    class condition_and_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_and_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_and"
    # /home/szr/subquery/SQL2XML/YSmart.g:492:1: condition_and : ( ( condition_and_part_first ( condition_and_part_next )+ -> ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* ) ) | condition_and_part_first );
    def condition_and(self, ):

        retval = self.condition_and_return()
        retval.start = self.input.LT(1)
        condition_and_StartIndex = self.input.index()
        root_0 = None

        condition_and_part_first432 = None

        condition_and_part_next433 = None

        condition_and_part_first434 = None


        stream_condition_and_part_next = RewriteRuleSubtreeStream(self._adaptor, "rule condition_and_part_next")
        stream_condition_and_part_first = RewriteRuleSubtreeStream(self._adaptor, "rule condition_and_part_first")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 64):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:493:5: ( ( condition_and_part_first ( condition_and_part_next )+ -> ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* ) ) | condition_and_part_first )
                alt112 = 2
                alt112 = self.dfa112.predict(self.input)
                if alt112 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:493:7: ( condition_and_part_first ( condition_and_part_next )+ -> ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* ) )
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:493:7: ( condition_and_part_first ( condition_and_part_next )+ -> ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* ) )
                    # /home/szr/subquery/SQL2XML/YSmart.g:493:8: condition_and_part_first ( condition_and_part_next )+
                    pass 
                    self._state.following.append(self.FOLLOW_condition_and_part_first_in_condition_and3205)
                    condition_and_part_first432 = self.condition_and_part_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_condition_and_part_first.add(condition_and_part_first432.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:493:33: ( condition_and_part_next )+
                    cnt111 = 0
                    while True: #loop111
                        alt111 = 2
                        LA111_0 = self.input.LA(1)

                        if (LA111_0 == 97) :
                            alt111 = 1


                        if alt111 == 1:
                            # /home/szr/subquery/SQL2XML/YSmart.g:0:0: condition_and_part_next
                            pass 
                            self._state.following.append(self.FOLLOW_condition_and_part_next_in_condition_and3207)
                            condition_and_part_next433 = self.condition_and_part_next()

                            self._state.following.pop()
                            if self._state.backtracking == 0:
                                stream_condition_and_part_next.add(condition_and_part_next433.tree)


                        else:
                            if cnt111 >= 1:
                                break #loop111

                            if self._state.backtracking > 0:
                                raise BacktrackingFailed

                            eee = EarlyExitException(111, self.input)
                            raise eee

                        cnt111 += 1

                    # AST Rewrite
                    # elements: condition_and_part_first, condition_and_part_next
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 
                    if self._state.backtracking == 0:

                        retval.tree = root_0

                        if retval is not None:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                        else:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                        root_0 = self._adaptor.nil()
                        # 493:58: -> ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* )
                        # /home/szr/subquery/SQL2XML/YSmart.g:493:61: ^( T_COND_AND ^( T_COND_AND condition_and_part_first ) ( condition_and_part_next )* )
                        root_1 = self._adaptor.nil()
                        root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_AND, "T_COND_AND"), root_1)

                        # /home/szr/subquery/SQL2XML/YSmart.g:493:74: ^( T_COND_AND condition_and_part_first )
                        root_2 = self._adaptor.nil()
                        root_2 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_AND, "T_COND_AND"), root_2)

                        self._adaptor.addChild(root_2, stream_condition_and_part_first.nextTree())

                        self._adaptor.addChild(root_1, root_2)
                        # /home/szr/subquery/SQL2XML/YSmart.g:493:113: ( condition_and_part_next )*
                        while stream_condition_and_part_next.hasNext():
                            self._adaptor.addChild(root_1, stream_condition_and_part_next.nextTree())


                        stream_condition_and_part_next.reset();

                        self._adaptor.addChild(root_0, root_1)



                        retval.tree = root_0





                elif alt112 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:494:4: condition_and_part_first
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_and_part_first_in_condition_and3229)
                    condition_and_part_first434 = self.condition_and_part_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_and_part_first434.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 64, condition_and_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_and"

    class condition_and_part_first_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_and_part_first_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_and_part_first"
    # /home/szr/subquery/SQL2XML/YSmart.g:496:1: condition_and_part_first : condition_not ;
    def condition_and_part_first(self, ):

        retval = self.condition_and_part_first_return()
        retval.start = self.input.LT(1)
        condition_and_part_first_StartIndex = self.input.index()
        root_0 = None

        condition_not435 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 65):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:497:2: ( condition_not )
                # /home/szr/subquery/SQL2XML/YSmart.g:497:4: condition_not
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_condition_not_in_condition_and_part_first3240)
                condition_not435 = self.condition_not()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_not435.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 65, condition_and_part_first_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_and_part_first"

    class condition_and_part_next_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_and_part_next_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_and_part_next"
    # /home/szr/subquery/SQL2XML/YSmart.g:499:1: condition_and_part_next : k_and condition_not -> ^( T_COND_AND k_and condition_not ) ;
    def condition_and_part_next(self, ):

        retval = self.condition_and_part_next_return()
        retval.start = self.input.LT(1)
        condition_and_part_next_StartIndex = self.input.index()
        root_0 = None

        k_and436 = None

        condition_not437 = None


        stream_k_and = RewriteRuleSubtreeStream(self._adaptor, "rule k_and")
        stream_condition_not = RewriteRuleSubtreeStream(self._adaptor, "rule condition_not")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 66):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:500:2: ( k_and condition_not -> ^( T_COND_AND k_and condition_not ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:500:4: k_and condition_not
                pass 
                self._state.following.append(self.FOLLOW_k_and_in_condition_and_part_next3253)
                k_and436 = self.k_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_and.add(k_and436.tree)
                self._state.following.append(self.FOLLOW_condition_not_in_condition_and_part_next3255)
                condition_not437 = self.condition_not()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_condition_not.add(condition_not437.tree)

                # AST Rewrite
                # elements: k_and, condition_not
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 500:24: -> ^( T_COND_AND k_and condition_not )
                    # /home/szr/subquery/SQL2XML/YSmart.g:500:27: ^( T_COND_AND k_and condition_not )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_AND, "T_COND_AND"), root_1)

                    self._adaptor.addChild(root_1, stream_k_and.nextTree())
                    self._adaptor.addChild(root_1, stream_condition_not.nextTree())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 66, condition_and_part_next_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_and_part_next"

    class condition_not_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_not_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_not"
    # /home/szr/subquery/SQL2XML/YSmart.g:502:1: condition_not : ( ( k_not condition_expr -> ^( T_COND_NOT k_not condition_expr ) ) | condition_expr );
    def condition_not(self, ):

        retval = self.condition_not_return()
        retval.start = self.input.LT(1)
        condition_not_StartIndex = self.input.index()
        root_0 = None

        k_not438 = None

        condition_expr439 = None

        condition_expr440 = None


        stream_condition_expr = RewriteRuleSubtreeStream(self._adaptor, "rule condition_expr")
        stream_k_not = RewriteRuleSubtreeStream(self._adaptor, "rule k_not")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 67):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:503:2: ( ( k_not condition_expr -> ^( T_COND_NOT k_not condition_expr ) ) | condition_expr )
                alt113 = 2
                LA113_0 = self.input.LA(1)

                if (LA113_0 == 157) :
                    alt113 = 1
                elif ((PLUS <= LA113_0 <= MINUS) or LA113_0 == LPAREN or LA113_0 == NUMBER or (VECTOR <= LA113_0 <= DOUBLEQUOTED_STRING) or LA113_0 == QUOTED_STRING or LA113_0 == 91 or LA113_0 == 98 or LA113_0 == 105 or (124 <= LA113_0 <= 125) or LA113_0 == 144 or LA113_0 == 160 or LA113_0 == 170 or LA113_0 == 178 or LA113_0 == 180 or LA113_0 == 192 or LA113_0 == 197 or (211 <= LA113_0 <= 367) or (369 <= LA113_0 <= 387) or (390 <= LA113_0 <= 428) or (430 <= LA113_0 <= 439) or (442 <= LA113_0 <= 453) or LA113_0 == 455 or (460 <= LA113_0 <= 528) or (530 <= LA113_0 <= 537) or (539 <= LA113_0 <= 546)) :
                    alt113 = 2
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 113, 0, self.input)

                    raise nvae

                if alt113 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:503:4: ( k_not condition_expr -> ^( T_COND_NOT k_not condition_expr ) )
                    pass 
                    # /home/szr/subquery/SQL2XML/YSmart.g:503:4: ( k_not condition_expr -> ^( T_COND_NOT k_not condition_expr ) )
                    # /home/szr/subquery/SQL2XML/YSmart.g:503:5: k_not condition_expr
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_not3279)
                    k_not438 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_k_not.add(k_not438.tree)
                    self._state.following.append(self.FOLLOW_condition_expr_in_condition_not3281)
                    condition_expr439 = self.condition_expr()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_condition_expr.add(condition_expr439.tree)

                    # AST Rewrite
                    # elements: condition_expr, k_not
                    # token labels: 
                    # rule labels: retval
                    # token list labels: 
                    # rule list labels: 
                    # wildcard labels: 
                    if self._state.backtracking == 0:

                        retval.tree = root_0

                        if retval is not None:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                        else:
                            stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                        root_0 = self._adaptor.nil()
                        # 503:26: -> ^( T_COND_NOT k_not condition_expr )
                        # /home/szr/subquery/SQL2XML/YSmart.g:503:29: ^( T_COND_NOT k_not condition_expr )
                        root_1 = self._adaptor.nil()
                        root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_COND_NOT, "T_COND_NOT"), root_1)

                        self._adaptor.addChild(root_1, stream_k_not.nextTree())
                        self._adaptor.addChild(root_1, stream_condition_expr.nextTree())

                        self._adaptor.addChild(root_0, root_1)



                        retval.tree = root_0





                elif alt113 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:504:4: condition_expr
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_expr_in_condition_not3297)
                    condition_expr440 = self.condition_expr()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_expr440.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 67, condition_not_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_not"

    class condition_expr_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_expr_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_expr"
    # /home/szr/subquery/SQL2XML/YSmart.g:506:1: condition_expr : ( condition_exists | condition_is | condition_comparison | condition_group_comparison | condition_in | condition_is_a_set | condition_is_any | condition_is_empty | condition_is_of_type | condition_is_present | condition_like | condition_memeber | condition_between | condition_regexp_like | condition_submultiset | condition_equals_path | condition_under_path | condition_paren );
    def condition_expr(self, ):

        retval = self.condition_expr_return()
        retval.start = self.input.LT(1)
        condition_expr_StartIndex = self.input.index()
        root_0 = None

        condition_exists441 = None

        condition_is442 = None

        condition_comparison443 = None

        condition_group_comparison444 = None

        condition_in445 = None

        condition_is_a_set446 = None

        condition_is_any447 = None

        condition_is_empty448 = None

        condition_is_of_type449 = None

        condition_is_present450 = None

        condition_like451 = None

        condition_memeber452 = None

        condition_between453 = None

        condition_regexp_like454 = None

        condition_submultiset455 = None

        condition_equals_path456 = None

        condition_under_path457 = None

        condition_paren458 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 68):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:507:2: ( condition_exists | condition_is | condition_comparison | condition_group_comparison | condition_in | condition_is_a_set | condition_is_any | condition_is_empty | condition_is_of_type | condition_is_present | condition_like | condition_memeber | condition_between | condition_regexp_like | condition_submultiset | condition_equals_path | condition_under_path | condition_paren )
                alt114 = 18
                alt114 = self.dfa114.predict(self.input)
                if alt114 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:507:4: condition_exists
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_exists_in_condition_expr3307)
                    condition_exists441 = self.condition_exists()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_exists441.tree)


                elif alt114 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:508:4: condition_is
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_in_condition_expr3312)
                    condition_is442 = self.condition_is()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is442.tree)


                elif alt114 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:509:4: condition_comparison
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_comparison_in_condition_expr3317)
                    condition_comparison443 = self.condition_comparison()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_comparison443.tree)


                elif alt114 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:510:4: condition_group_comparison
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_group_comparison_in_condition_expr3322)
                    condition_group_comparison444 = self.condition_group_comparison()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_group_comparison444.tree)


                elif alt114 == 5:
                    # /home/szr/subquery/SQL2XML/YSmart.g:511:4: condition_in
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_in_in_condition_expr3327)
                    condition_in445 = self.condition_in()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_in445.tree)


                elif alt114 == 6:
                    # /home/szr/subquery/SQL2XML/YSmart.g:512:4: condition_is_a_set
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_a_set_in_condition_expr3332)
                    condition_is_a_set446 = self.condition_is_a_set()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_a_set446.tree)


                elif alt114 == 7:
                    # /home/szr/subquery/SQL2XML/YSmart.g:513:4: condition_is_any
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_any_in_condition_expr3337)
                    condition_is_any447 = self.condition_is_any()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_any447.tree)


                elif alt114 == 8:
                    # /home/szr/subquery/SQL2XML/YSmart.g:514:4: condition_is_empty
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_empty_in_condition_expr3342)
                    condition_is_empty448 = self.condition_is_empty()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_empty448.tree)


                elif alt114 == 9:
                    # /home/szr/subquery/SQL2XML/YSmart.g:515:4: condition_is_of_type
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_of_type_in_condition_expr3347)
                    condition_is_of_type449 = self.condition_is_of_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_of_type449.tree)


                elif alt114 == 10:
                    # /home/szr/subquery/SQL2XML/YSmart.g:516:4: condition_is_present
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_is_present_in_condition_expr3352)
                    condition_is_present450 = self.condition_is_present()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_is_present450.tree)


                elif alt114 == 11:
                    # /home/szr/subquery/SQL2XML/YSmart.g:517:4: condition_like
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_like_in_condition_expr3357)
                    condition_like451 = self.condition_like()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_like451.tree)


                elif alt114 == 12:
                    # /home/szr/subquery/SQL2XML/YSmart.g:518:4: condition_memeber
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_memeber_in_condition_expr3362)
                    condition_memeber452 = self.condition_memeber()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_memeber452.tree)


                elif alt114 == 13:
                    # /home/szr/subquery/SQL2XML/YSmart.g:519:4: condition_between
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_between_in_condition_expr3367)
                    condition_between453 = self.condition_between()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_between453.tree)


                elif alt114 == 14:
                    # /home/szr/subquery/SQL2XML/YSmart.g:520:4: condition_regexp_like
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_regexp_like_in_condition_expr3372)
                    condition_regexp_like454 = self.condition_regexp_like()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_regexp_like454.tree)


                elif alt114 == 15:
                    # /home/szr/subquery/SQL2XML/YSmart.g:521:4: condition_submultiset
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_submultiset_in_condition_expr3377)
                    condition_submultiset455 = self.condition_submultiset()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_submultiset455.tree)


                elif alt114 == 16:
                    # /home/szr/subquery/SQL2XML/YSmart.g:522:4: condition_equals_path
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_equals_path_in_condition_expr3382)
                    condition_equals_path456 = self.condition_equals_path()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_equals_path456.tree)


                elif alt114 == 17:
                    # /home/szr/subquery/SQL2XML/YSmart.g:523:4: condition_under_path
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_under_path_in_condition_expr3387)
                    condition_under_path457 = self.condition_under_path()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_under_path457.tree)


                elif alt114 == 18:
                    # /home/szr/subquery/SQL2XML/YSmart.g:524:4: condition_paren
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_condition_paren_in_condition_expr3392)
                    condition_paren458 = self.condition_paren()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, condition_paren458.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 68, condition_expr_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_expr"

    class condition_exists_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_exists_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_exists"
    # /home/szr/subquery/SQL2XML/YSmart.g:527:1: condition_exists : k_exists subquery ;
    def condition_exists(self, ):

        retval = self.condition_exists_return()
        retval.start = self.input.LT(1)
        condition_exists_StartIndex = self.input.index()
        root_0 = None

        k_exists459 = None

        subquery460 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 69):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:528:2: ( k_exists subquery )
                # /home/szr/subquery/SQL2XML/YSmart.g:528:4: k_exists subquery
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_exists_in_condition_exists3403)
                k_exists459 = self.k_exists()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_exists459.tree)
                self._state.following.append(self.FOLLOW_subquery_in_condition_exists3405)
                subquery460 = self.subquery()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, subquery460.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 69, condition_exists_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_exists"

    class condition_is_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is"
    # /home/szr/subquery/SQL2XML/YSmart.g:530:1: condition_is : sql_expression k_is ( k_not )? ( k_nan | k_infinite | k_null ) ;
    def condition_is(self, ):

        retval = self.condition_is_return()
        retval.start = self.input.LT(1)
        condition_is_StartIndex = self.input.index()
        root_0 = None

        sql_expression461 = None

        k_is462 = None

        k_not463 = None

        k_nan464 = None

        k_infinite465 = None

        k_null466 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 70):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:531:2: ( sql_expression k_is ( k_not )? ( k_nan | k_infinite | k_null ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:531:4: sql_expression k_is ( k_not )? ( k_nan | k_infinite | k_null )
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_condition_is3415)
                sql_expression461 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression461.tree)
                self._state.following.append(self.FOLLOW_k_is_in_condition_is3417)
                k_is462 = self.k_is()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_is462.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:531:24: ( k_not )?
                alt115 = 2
                LA115_0 = self.input.LA(1)

                if (LA115_0 == 157) :
                    alt115 = 1
                if alt115 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:531:26: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_is3421)
                    k_not463 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not463.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:531:35: ( k_nan | k_infinite | k_null )
                alt116 = 3
                LA116 = self.input.LA(1)
                if LA116 == 442:
                    alt116 = 1
                elif LA116 == 425:
                    alt116 = 2
                elif LA116 == 160:
                    alt116 = 3
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 116, 0, self.input)

                    raise nvae

                if alt116 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:531:37: k_nan
                    pass 
                    self._state.following.append(self.FOLLOW_k_nan_in_condition_is3428)
                    k_nan464 = self.k_nan()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nan464.tree)


                elif alt116 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:531:45: k_infinite
                    pass 
                    self._state.following.append(self.FOLLOW_k_infinite_in_condition_is3432)
                    k_infinite465 = self.k_infinite()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_infinite465.tree)


                elif alt116 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:531:58: k_null
                    pass 
                    self._state.following.append(self.FOLLOW_k_null_in_condition_is3436)
                    k_null466 = self.k_null()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_null466.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 70, condition_is_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is"

    class condition_comparison_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_comparison_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_comparison"
    # /home/szr/subquery/SQL2XML/YSmart.g:533:1: condition_comparison : ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) subquery ( outer_join_sign )? | ( k_prior )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_prior )? ( sql_expression | LPAREN select_statement RPAREN ) ( outer_join_sign )? );
    def condition_comparison(self, ):

        retval = self.condition_comparison_return()
        retval.start = self.input.LT(1)
        condition_comparison_StartIndex = self.input.index()
        root_0 = None

        LPAREN467 = None
        RPAREN469 = None
        set471 = None
        set477 = None
        LPAREN480 = None
        RPAREN482 = None
        sql_expressions468 = None

        outer_join_sign470 = None

        subquery472 = None

        outer_join_sign473 = None

        k_prior474 = None

        sql_expression475 = None

        outer_join_sign476 = None

        k_prior478 = None

        sql_expression479 = None

        select_statement481 = None

        outer_join_sign483 = None


        LPAREN467_tree = None
        RPAREN469_tree = None
        set471_tree = None
        set477_tree = None
        LPAREN480_tree = None
        RPAREN482_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 71):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:534:2: ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) subquery ( outer_join_sign )? | ( k_prior )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_prior )? ( sql_expression | LPAREN select_statement RPAREN ) ( outer_join_sign )? )
                alt124 = 2
                alt124 = self.dfa124.predict(self.input)
                if alt124 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:534:4: LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) subquery ( outer_join_sign )?
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN467=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_comparison3448)
                    if self._state.backtracking == 0:

                        LPAREN467_tree = self._adaptor.createWithPayload(LPAREN467)
                        self._adaptor.addChild(root_0, LPAREN467_tree)

                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_comparison3450)
                    sql_expressions468 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions468.tree)
                    RPAREN469=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_comparison3452)
                    if self._state.backtracking == 0:

                        RPAREN469_tree = self._adaptor.createWithPayload(RPAREN469)
                        self._adaptor.addChild(root_0, RPAREN469_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:534:34: ( outer_join_sign )?
                    alt117 = 2
                    LA117_0 = self.input.LA(1)

                    if (LA117_0 == LPAREN) :
                        alt117 = 1
                    if alt117 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:534:36: outer_join_sign
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison3456)
                        outer_join_sign470 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign470.tree)



                    set471 = self.input.LT(1)
                    if (EQ <= self.input.LA(1) <= NOT_EQ):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set471))
                        self._state.errorRecovery = False

                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        mse = MismatchedSetException(None, self.input)
                        raise mse


                    self._state.following.append(self.FOLLOW_subquery_in_condition_comparison3471)
                    subquery472 = self.subquery()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, subquery472.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:534:80: ( outer_join_sign )?
                    alt118 = 2
                    LA118_0 = self.input.LA(1)

                    if (LA118_0 == LPAREN) :
                        alt118 = 1
                    if alt118 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:534:82: outer_join_sign
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison3475)
                        outer_join_sign473 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign473.tree)





                elif alt124 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:535:4: ( k_prior )? sql_expression ( outer_join_sign )? ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_prior )? ( sql_expression | LPAREN select_statement RPAREN ) ( outer_join_sign )?
                    pass 
                    root_0 = self._adaptor.nil()

                    # /home/szr/subquery/SQL2XML/YSmart.g:535:4: ( k_prior )?
                    alt119 = 2
                    LA119_0 = self.input.LA(1)

                    if (LA119_0 == 170) :
                        LA119_1 = self.input.LA(2)

                        if (self.synpred235_YSmart()) :
                            alt119 = 1
                    if alt119 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:6: k_prior
                        pass 
                        self._state.following.append(self.FOLLOW_k_prior_in_condition_comparison3485)
                        k_prior474 = self.k_prior()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_prior474.tree)



                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_comparison3490)
                    sql_expression475 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression475.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:535:32: ( outer_join_sign )?
                    alt120 = 2
                    LA120_0 = self.input.LA(1)

                    if (LA120_0 == LPAREN) :
                        alt120 = 1
                    if alt120 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:34: outer_join_sign
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison3494)
                        outer_join_sign476 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign476.tree)



                    set477 = self.input.LT(1)
                    if (EQ <= self.input.LA(1) <= LEQ):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set477))
                        self._state.errorRecovery = False

                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        mse = MismatchedSetException(None, self.input)
                        raise mse


                    # /home/szr/subquery/SQL2XML/YSmart.g:535:93: ( k_prior )?
                    alt121 = 2
                    LA121_0 = self.input.LA(1)

                    if (LA121_0 == 170) :
                        LA121_1 = self.input.LA(2)

                        if (self.synpred242_YSmart()) :
                            alt121 = 1
                    if alt121 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:95: k_prior
                        pass 
                        self._state.following.append(self.FOLLOW_k_prior_in_condition_comparison3527)
                        k_prior478 = self.k_prior()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_prior478.tree)



                    # /home/szr/subquery/SQL2XML/YSmart.g:535:106: ( sql_expression | LPAREN select_statement RPAREN )
                    alt122 = 2
                    alt122 = self.dfa122.predict(self.input)
                    if alt122 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:108: sql_expression
                        pass 
                        self._state.following.append(self.FOLLOW_sql_expression_in_condition_comparison3534)
                        sql_expression479 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression479.tree)


                    elif alt122 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:125: LPAREN select_statement RPAREN
                        pass 
                        LPAREN480=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_comparison3538)
                        if self._state.backtracking == 0:

                            LPAREN480_tree = self._adaptor.createWithPayload(LPAREN480)
                            self._adaptor.addChild(root_0, LPAREN480_tree)

                        self._state.following.append(self.FOLLOW_select_statement_in_condition_comparison3540)
                        select_statement481 = self.select_statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_statement481.tree)
                        RPAREN482=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_comparison3542)
                        if self._state.backtracking == 0:

                            RPAREN482_tree = self._adaptor.createWithPayload(RPAREN482)
                            self._adaptor.addChild(root_0, RPAREN482_tree)




                    # /home/szr/subquery/SQL2XML/YSmart.g:535:158: ( outer_join_sign )?
                    alt123 = 2
                    LA123_0 = self.input.LA(1)

                    if (LA123_0 == LPAREN) :
                        alt123 = 1
                    if alt123 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:535:160: outer_join_sign
                        pass 
                        self._state.following.append(self.FOLLOW_outer_join_sign_in_condition_comparison3548)
                        outer_join_sign483 = self.outer_join_sign()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, outer_join_sign483.tree)





                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 71, condition_comparison_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_comparison"

    class condition_group_comparison_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_group_comparison_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_group_comparison"
    # /home/szr/subquery/SQL2XML/YSmart.g:537:1: condition_group_comparison : ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( k_any | k_some | k_all ) LPAREN ( grouping_expression_list | select_statement ) RPAREN | sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_any | k_some | k_all ) LPAREN ( sql_expressions | select_statement ) RPAREN );
    def condition_group_comparison(self, ):

        retval = self.condition_group_comparison_return()
        retval.start = self.input.LT(1)
        condition_group_comparison_StartIndex = self.input.index()
        root_0 = None

        LPAREN484 = None
        RPAREN486 = None
        set487 = None
        LPAREN491 = None
        RPAREN494 = None
        set496 = None
        LPAREN500 = None
        RPAREN503 = None
        sql_expressions485 = None

        k_any488 = None

        k_some489 = None

        k_all490 = None

        grouping_expression_list492 = None

        select_statement493 = None

        sql_expression495 = None

        k_any497 = None

        k_some498 = None

        k_all499 = None

        sql_expressions501 = None

        select_statement502 = None


        LPAREN484_tree = None
        RPAREN486_tree = None
        set487_tree = None
        LPAREN491_tree = None
        RPAREN494_tree = None
        set496_tree = None
        LPAREN500_tree = None
        RPAREN503_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 72):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:538:2: ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( k_any | k_some | k_all ) LPAREN ( grouping_expression_list | select_statement ) RPAREN | sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_any | k_some | k_all ) LPAREN ( sql_expressions | select_statement ) RPAREN )
                alt129 = 2
                alt129 = self.dfa129.predict(self.input)
                if alt129 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:538:4: LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( k_any | k_some | k_all ) LPAREN ( grouping_expression_list | select_statement ) RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN484=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison3561)
                    if self._state.backtracking == 0:

                        LPAREN484_tree = self._adaptor.createWithPayload(LPAREN484)
                        self._adaptor.addChild(root_0, LPAREN484_tree)

                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_group_comparison3563)
                    sql_expressions485 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions485.tree)
                    RPAREN486=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison3565)
                    if self._state.backtracking == 0:

                        RPAREN486_tree = self._adaptor.createWithPayload(RPAREN486)
                        self._adaptor.addChild(root_0, RPAREN486_tree)

                    set487 = self.input.LT(1)
                    if (EQ <= self.input.LA(1) <= NOT_EQ):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set487))
                        self._state.errorRecovery = False

                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        mse = MismatchedSetException(None, self.input)
                        raise mse


                    # /home/szr/subquery/SQL2XML/YSmart.g:538:50: ( k_any | k_some | k_all )
                    alt125 = 3
                    LA125 = self.input.LA(1)
                    if LA125 == 98:
                        alt125 = 1
                    elif LA125 == 362:
                        alt125 = 2
                    elif LA125 == 95:
                        alt125 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 125, 0, self.input)

                        raise nvae

                    if alt125 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:538:52: k_any
                        pass 
                        self._state.following.append(self.FOLLOW_k_any_in_condition_group_comparison3579)
                        k_any488 = self.k_any()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_any488.tree)


                    elif alt125 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:538:60: k_some
                        pass 
                        self._state.following.append(self.FOLLOW_k_some_in_condition_group_comparison3583)
                        k_some489 = self.k_some()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_some489.tree)


                    elif alt125 == 3:
                        # /home/szr/subquery/SQL2XML/YSmart.g:538:69: k_all
                        pass 
                        self._state.following.append(self.FOLLOW_k_all_in_condition_group_comparison3587)
                        k_all490 = self.k_all()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_all490.tree)



                    LPAREN491=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison3591)
                    if self._state.backtracking == 0:

                        LPAREN491_tree = self._adaptor.createWithPayload(LPAREN491)
                        self._adaptor.addChild(root_0, LPAREN491_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:538:84: ( grouping_expression_list | select_statement )
                    alt126 = 2
                    LA126_0 = self.input.LA(1)

                    if ((PLUS <= LA126_0 <= MINUS) or LA126_0 == LPAREN or LA126_0 == NUMBER or (VECTOR <= LA126_0 <= DOUBLEQUOTED_STRING) or LA126_0 == QUOTED_STRING or LA126_0 == 91 or LA126_0 == 105 or LA126_0 == 125 or LA126_0 == 144 or LA126_0 == 160 or LA126_0 == 170 or LA126_0 == 178 or LA126_0 == 180 or LA126_0 == 192 or LA126_0 == 197 or (211 <= LA126_0 <= 367) or (369 <= LA126_0 <= 387) or (390 <= LA126_0 <= 428) or (430 <= LA126_0 <= 439) or (442 <= LA126_0 <= 453) or LA126_0 == 455 or (460 <= LA126_0 <= 528) or (530 <= LA126_0 <= 537) or (539 <= LA126_0 <= 546)) :
                        alt126 = 1
                    elif (LA126_0 == 182) :
                        alt126 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 126, 0, self.input)

                        raise nvae

                    if alt126 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:538:86: grouping_expression_list
                        pass 
                        self._state.following.append(self.FOLLOW_grouping_expression_list_in_condition_group_comparison3595)
                        grouping_expression_list492 = self.grouping_expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_expression_list492.tree)


                    elif alt126 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:538:113: select_statement
                        pass 
                        self._state.following.append(self.FOLLOW_select_statement_in_condition_group_comparison3599)
                        select_statement493 = self.select_statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_statement493.tree)



                    RPAREN494=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison3603)
                    if self._state.backtracking == 0:

                        RPAREN494_tree = self._adaptor.createWithPayload(RPAREN494)
                        self._adaptor.addChild(root_0, RPAREN494_tree)



                elif alt129 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:539:4: sql_expression ( EQ | NOT_EQ | GTH | GEQ | LTH | LEQ ) ( k_any | k_some | k_all ) LPAREN ( sql_expressions | select_statement ) RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_group_comparison3608)
                    sql_expression495 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression495.tree)
                    set496 = self.input.LT(1)
                    if (EQ <= self.input.LA(1) <= LEQ):
                        self.input.consume()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set496))
                        self._state.errorRecovery = False

                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        mse = MismatchedSetException(None, self.input)
                        raise mse


                    # /home/szr/subquery/SQL2XML/YSmart.g:539:59: ( k_any | k_some | k_all )
                    alt127 = 3
                    LA127 = self.input.LA(1)
                    if LA127 == 98:
                        alt127 = 1
                    elif LA127 == 362:
                        alt127 = 2
                    elif LA127 == 95:
                        alt127 = 3
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 127, 0, self.input)

                        raise nvae

                    if alt127 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:539:61: k_any
                        pass 
                        self._state.following.append(self.FOLLOW_k_any_in_condition_group_comparison3638)
                        k_any497 = self.k_any()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_any497.tree)


                    elif alt127 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:539:69: k_some
                        pass 
                        self._state.following.append(self.FOLLOW_k_some_in_condition_group_comparison3642)
                        k_some498 = self.k_some()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_some498.tree)


                    elif alt127 == 3:
                        # /home/szr/subquery/SQL2XML/YSmart.g:539:78: k_all
                        pass 
                        self._state.following.append(self.FOLLOW_k_all_in_condition_group_comparison3646)
                        k_all499 = self.k_all()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_all499.tree)



                    LPAREN500=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_group_comparison3650)
                    if self._state.backtracking == 0:

                        LPAREN500_tree = self._adaptor.createWithPayload(LPAREN500)
                        self._adaptor.addChild(root_0, LPAREN500_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:539:93: ( sql_expressions | select_statement )
                    alt128 = 2
                    LA128_0 = self.input.LA(1)

                    if ((PLUS <= LA128_0 <= MINUS) or LA128_0 == LPAREN or LA128_0 == NUMBER or (VECTOR <= LA128_0 <= DOUBLEQUOTED_STRING) or LA128_0 == QUOTED_STRING or LA128_0 == 91 or LA128_0 == 105 or LA128_0 == 125 or LA128_0 == 144 or LA128_0 == 160 or LA128_0 == 170 or LA128_0 == 178 or LA128_0 == 180 or LA128_0 == 192 or LA128_0 == 197 or (211 <= LA128_0 <= 367) or (369 <= LA128_0 <= 387) or (390 <= LA128_0 <= 428) or (430 <= LA128_0 <= 439) or (442 <= LA128_0 <= 453) or LA128_0 == 455 or (460 <= LA128_0 <= 528) or (530 <= LA128_0 <= 537) or (539 <= LA128_0 <= 546)) :
                        alt128 = 1
                    elif (LA128_0 == 182) :
                        alt128 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 128, 0, self.input)

                        raise nvae

                    if alt128 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:539:95: sql_expressions
                        pass 
                        self._state.following.append(self.FOLLOW_sql_expressions_in_condition_group_comparison3654)
                        sql_expressions501 = self.sql_expressions()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expressions501.tree)


                    elif alt128 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:539:113: select_statement
                        pass 
                        self._state.following.append(self.FOLLOW_select_statement_in_condition_group_comparison3658)
                        select_statement502 = self.select_statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_statement502.tree)



                    RPAREN503=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_group_comparison3662)
                    if self._state.backtracking == 0:

                        RPAREN503_tree = self._adaptor.createWithPayload(RPAREN503)
                        self._adaptor.addChild(root_0, RPAREN503_tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 72, condition_group_comparison_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_group_comparison"

    class condition_in_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_in_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_in"
    # /home/szr/subquery/SQL2XML/YSmart.g:541:1: condition_in : ( LPAREN sql_expressions RPAREN ( k_not )? k_in LPAREN ( grouping_expression_list | select_statement ) RPAREN | sql_expression ( k_not )? k_in LPAREN ( expression_list | select_statement ) RPAREN );
    def condition_in(self, ):

        retval = self.condition_in_return()
        retval.start = self.input.LT(1)
        condition_in_StartIndex = self.input.index()
        root_0 = None

        LPAREN504 = None
        RPAREN506 = None
        LPAREN509 = None
        RPAREN512 = None
        LPAREN516 = None
        RPAREN519 = None
        sql_expressions505 = None

        k_not507 = None

        k_in508 = None

        grouping_expression_list510 = None

        select_statement511 = None

        sql_expression513 = None

        k_not514 = None

        k_in515 = None

        expression_list517 = None

        select_statement518 = None


        LPAREN504_tree = None
        RPAREN506_tree = None
        LPAREN509_tree = None
        RPAREN512_tree = None
        LPAREN516_tree = None
        RPAREN519_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 73):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:542:2: ( LPAREN sql_expressions RPAREN ( k_not )? k_in LPAREN ( grouping_expression_list | select_statement ) RPAREN | sql_expression ( k_not )? k_in LPAREN ( expression_list | select_statement ) RPAREN )
                alt134 = 2
                alt134 = self.dfa134.predict(self.input)
                if alt134 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:542:4: LPAREN sql_expressions RPAREN ( k_not )? k_in LPAREN ( grouping_expression_list | select_statement ) RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN504=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in3672)
                    if self._state.backtracking == 0:

                        LPAREN504_tree = self._adaptor.createWithPayload(LPAREN504)
                        self._adaptor.addChild(root_0, LPAREN504_tree)

                    self._state.following.append(self.FOLLOW_sql_expressions_in_condition_in3674)
                    sql_expressions505 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions505.tree)
                    RPAREN506=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in3676)
                    if self._state.backtracking == 0:

                        RPAREN506_tree = self._adaptor.createWithPayload(RPAREN506)
                        self._adaptor.addChild(root_0, RPAREN506_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:542:34: ( k_not )?
                    alt130 = 2
                    LA130_0 = self.input.LA(1)

                    if (LA130_0 == 157) :
                        alt130 = 1
                    if alt130 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:542:36: k_not
                        pass 
                        self._state.following.append(self.FOLLOW_k_not_in_condition_in3680)
                        k_not507 = self.k_not()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_not507.tree)



                    self._state.following.append(self.FOLLOW_k_in_in_condition_in3685)
                    k_in508 = self.k_in()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_in508.tree)
                    LPAREN509=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in3687)
                    if self._state.backtracking == 0:

                        LPAREN509_tree = self._adaptor.createWithPayload(LPAREN509)
                        self._adaptor.addChild(root_0, LPAREN509_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:542:57: ( grouping_expression_list | select_statement )
                    alt131 = 2
                    LA131_0 = self.input.LA(1)

                    if ((PLUS <= LA131_0 <= MINUS) or LA131_0 == LPAREN or LA131_0 == NUMBER or (VECTOR <= LA131_0 <= DOUBLEQUOTED_STRING) or LA131_0 == QUOTED_STRING or LA131_0 == 91 or LA131_0 == 105 or LA131_0 == 125 or LA131_0 == 144 or LA131_0 == 160 or LA131_0 == 170 or LA131_0 == 178 or LA131_0 == 180 or LA131_0 == 192 or LA131_0 == 197 or (211 <= LA131_0 <= 367) or (369 <= LA131_0 <= 387) or (390 <= LA131_0 <= 428) or (430 <= LA131_0 <= 439) or (442 <= LA131_0 <= 453) or LA131_0 == 455 or (460 <= LA131_0 <= 528) or (530 <= LA131_0 <= 537) or (539 <= LA131_0 <= 546)) :
                        alt131 = 1
                    elif (LA131_0 == 182) :
                        alt131 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 131, 0, self.input)

                        raise nvae

                    if alt131 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:542:59: grouping_expression_list
                        pass 
                        self._state.following.append(self.FOLLOW_grouping_expression_list_in_condition_in3691)
                        grouping_expression_list510 = self.grouping_expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, grouping_expression_list510.tree)


                    elif alt131 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:542:86: select_statement
                        pass 
                        self._state.following.append(self.FOLLOW_select_statement_in_condition_in3695)
                        select_statement511 = self.select_statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_statement511.tree)



                    RPAREN512=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in3699)
                    if self._state.backtracking == 0:

                        RPAREN512_tree = self._adaptor.createWithPayload(RPAREN512)
                        self._adaptor.addChild(root_0, RPAREN512_tree)



                elif alt134 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:543:4: sql_expression ( k_not )? k_in LPAREN ( expression_list | select_statement ) RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_in3704)
                    sql_expression513 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression513.tree)
                    # /home/szr/subquery/SQL2XML/YSmart.g:543:19: ( k_not )?
                    alt132 = 2
                    LA132_0 = self.input.LA(1)

                    if (LA132_0 == 157) :
                        alt132 = 1
                    if alt132 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:543:21: k_not
                        pass 
                        self._state.following.append(self.FOLLOW_k_not_in_condition_in3708)
                        k_not514 = self.k_not()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, k_not514.tree)



                    self._state.following.append(self.FOLLOW_k_in_in_condition_in3713)
                    k_in515 = self.k_in()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_in515.tree)
                    LPAREN516=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_in3715)
                    if self._state.backtracking == 0:

                        LPAREN516_tree = self._adaptor.createWithPayload(LPAREN516)
                        self._adaptor.addChild(root_0, LPAREN516_tree)

                    # /home/szr/subquery/SQL2XML/YSmart.g:543:42: ( expression_list | select_statement )
                    alt133 = 2
                    LA133_0 = self.input.LA(1)

                    if ((PLUS <= LA133_0 <= MINUS) or LA133_0 == LPAREN or LA133_0 == NUMBER or (VECTOR <= LA133_0 <= DOUBLEQUOTED_STRING) or LA133_0 == QUOTED_STRING or LA133_0 == 91 or LA133_0 == 105 or LA133_0 == 125 or LA133_0 == 144 or LA133_0 == 160 or LA133_0 == 170 or LA133_0 == 178 or LA133_0 == 180 or LA133_0 == 192 or LA133_0 == 197 or (211 <= LA133_0 <= 367) or (369 <= LA133_0 <= 387) or (390 <= LA133_0 <= 428) or (430 <= LA133_0 <= 439) or (442 <= LA133_0 <= 453) or LA133_0 == 455 or (460 <= LA133_0 <= 528) or (530 <= LA133_0 <= 537) or (539 <= LA133_0 <= 546)) :
                        alt133 = 1
                    elif (LA133_0 == 182) :
                        alt133 = 2
                    else:
                        if self._state.backtracking > 0:
                            raise BacktrackingFailed

                        nvae = NoViableAltException("", 133, 0, self.input)

                        raise nvae

                    if alt133 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:543:44: expression_list
                        pass 
                        self._state.following.append(self.FOLLOW_expression_list_in_condition_in3719)
                        expression_list517 = self.expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expression_list517.tree)


                    elif alt133 == 2:
                        # /home/szr/subquery/SQL2XML/YSmart.g:543:62: select_statement
                        pass 
                        self._state.following.append(self.FOLLOW_select_statement_in_condition_in3723)
                        select_statement518 = self.select_statement()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, select_statement518.tree)



                    RPAREN519=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_in3727)
                    if self._state.backtracking == 0:

                        RPAREN519_tree = self._adaptor.createWithPayload(RPAREN519)
                        self._adaptor.addChild(root_0, RPAREN519_tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 73, condition_in_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_in"

    class condition_is_a_set_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_a_set_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_a_set"
    # /home/szr/subquery/SQL2XML/YSmart.g:545:1: condition_is_a_set : nested_table_column_name k_is ( k_not )? k_a k_set ;
    def condition_is_a_set(self, ):

        retval = self.condition_is_a_set_return()
        retval.start = self.input.LT(1)
        condition_is_a_set_StartIndex = self.input.index()
        root_0 = None

        nested_table_column_name520 = None

        k_is521 = None

        k_not522 = None

        k_a523 = None

        k_set524 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 74):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:546:2: ( nested_table_column_name k_is ( k_not )? k_a k_set )
                # /home/szr/subquery/SQL2XML/YSmart.g:546:4: nested_table_column_name k_is ( k_not )? k_a k_set
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_is_a_set3737)
                nested_table_column_name520 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name520.tree)
                self._state.following.append(self.FOLLOW_k_is_in_condition_is_a_set3739)
                k_is521 = self.k_is()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_is521.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:546:34: ( k_not )?
                alt135 = 2
                LA135_0 = self.input.LA(1)

                if (LA135_0 == 157) :
                    alt135 = 1
                if alt135 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:546:36: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_is_a_set3743)
                    k_not522 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not522.tree)



                self._state.following.append(self.FOLLOW_k_a_in_condition_is_a_set3748)
                k_a523 = self.k_a()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_a523.tree)
                self._state.following.append(self.FOLLOW_k_set_in_condition_is_a_set3750)
                k_set524 = self.k_set()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_set524.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 74, condition_is_a_set_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_a_set"

    class condition_is_any_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_any_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_any"
    # /home/szr/subquery/SQL2XML/YSmart.g:548:1: condition_is_any : ( column_name k_is )? k_any ;
    def condition_is_any(self, ):

        retval = self.condition_is_any_return()
        retval.start = self.input.LT(1)
        condition_is_any_StartIndex = self.input.index()
        root_0 = None

        column_name525 = None

        k_is526 = None

        k_any527 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 75):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:549:2: ( ( column_name k_is )? k_any )
                # /home/szr/subquery/SQL2XML/YSmart.g:549:4: ( column_name k_is )? k_any
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:549:4: ( column_name k_is )?
                alt136 = 2
                LA136_0 = self.input.LA(1)

                if ((VECTOR <= LA136_0 <= DOUBLEQUOTED_STRING) or LA136_0 == 91 or LA136_0 == 178 or LA136_0 == 180 or (211 <= LA136_0 <= 367) or (369 <= LA136_0 <= 387) or (390 <= LA136_0 <= 428) or (430 <= LA136_0 <= 439) or (442 <= LA136_0 <= 453) or LA136_0 == 455 or (460 <= LA136_0 <= 502) or (508 <= LA136_0 <= 528) or (530 <= LA136_0 <= 537) or (539 <= LA136_0 <= 546)) :
                    alt136 = 1
                if alt136 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:549:6: column_name k_is
                    pass 
                    self._state.following.append(self.FOLLOW_column_name_in_condition_is_any3762)
                    column_name525 = self.column_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, column_name525.tree)
                    self._state.following.append(self.FOLLOW_k_is_in_condition_is_any3764)
                    k_is526 = self.k_is()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_is526.tree)



                self._state.following.append(self.FOLLOW_k_any_in_condition_is_any3769)
                k_any527 = self.k_any()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_any527.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 75, condition_is_any_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_any"

    class condition_is_empty_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_empty_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_empty"
    # /home/szr/subquery/SQL2XML/YSmart.g:551:1: condition_is_empty : nested_table_column_name k_is ( k_not )? k_empty ;
    def condition_is_empty(self, ):

        retval = self.condition_is_empty_return()
        retval.start = self.input.LT(1)
        condition_is_empty_StartIndex = self.input.index()
        root_0 = None

        nested_table_column_name528 = None

        k_is529 = None

        k_not530 = None

        k_empty531 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 76):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:552:2: ( nested_table_column_name k_is ( k_not )? k_empty )
                # /home/szr/subquery/SQL2XML/YSmart.g:552:4: nested_table_column_name k_is ( k_not )? k_empty
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_is_empty3779)
                nested_table_column_name528 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name528.tree)
                self._state.following.append(self.FOLLOW_k_is_in_condition_is_empty3781)
                k_is529 = self.k_is()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_is529.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:552:34: ( k_not )?
                alt137 = 2
                LA137_0 = self.input.LA(1)

                if (LA137_0 == 157) :
                    alt137 = 1
                if alt137 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:552:36: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_is_empty3785)
                    k_not530 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not530.tree)



                self._state.following.append(self.FOLLOW_k_empty_in_condition_is_empty3790)
                k_empty531 = self.k_empty()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_empty531.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 76, condition_is_empty_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_empty"

    class condition_is_of_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_of_type_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_of_type"
    # /home/szr/subquery/SQL2XML/YSmart.g:554:1: condition_is_of_type : sql_expression k_is ( k_not )? k_of ( k_type )? LPAREN type_name RPAREN ;
    def condition_is_of_type(self, ):

        retval = self.condition_is_of_type_return()
        retval.start = self.input.LT(1)
        condition_is_of_type_StartIndex = self.input.index()
        root_0 = None

        LPAREN537 = None
        RPAREN539 = None
        sql_expression532 = None

        k_is533 = None

        k_not534 = None

        k_of535 = None

        k_type536 = None

        type_name538 = None


        LPAREN537_tree = None
        RPAREN539_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 77):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:555:2: ( sql_expression k_is ( k_not )? k_of ( k_type )? LPAREN type_name RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:555:4: sql_expression k_is ( k_not )? k_of ( k_type )? LPAREN type_name RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_condition_is_of_type3800)
                sql_expression532 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression532.tree)
                self._state.following.append(self.FOLLOW_k_is_in_condition_is_of_type3802)
                k_is533 = self.k_is()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_is533.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:555:24: ( k_not )?
                alt138 = 2
                LA138_0 = self.input.LA(1)

                if (LA138_0 == 157) :
                    alt138 = 1
                if alt138 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:555:25: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_is_of_type3805)
                    k_not534 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not534.tree)



                self._state.following.append(self.FOLLOW_k_of_in_condition_is_of_type3809)
                k_of535 = self.k_of()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_of535.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:555:38: ( k_type )?
                alt139 = 2
                LA139_0 = self.input.LA(1)

                if (LA139_0 == 493) :
                    alt139 = 1
                if alt139 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:555:40: k_type
                    pass 
                    self._state.following.append(self.FOLLOW_k_type_in_condition_is_of_type3813)
                    k_type536 = self.k_type()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_type536.tree)



                LPAREN537=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_is_of_type3818)
                if self._state.backtracking == 0:

                    LPAREN537_tree = self._adaptor.createWithPayload(LPAREN537)
                    self._adaptor.addChild(root_0, LPAREN537_tree)

                self._state.following.append(self.FOLLOW_type_name_in_condition_is_of_type3820)
                type_name538 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name538.tree)
                RPAREN539=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_is_of_type3822)
                if self._state.backtracking == 0:

                    RPAREN539_tree = self._adaptor.createWithPayload(RPAREN539)
                    self._adaptor.addChild(root_0, RPAREN539_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 77, condition_is_of_type_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_of_type"

    class condition_is_of_type_names_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_of_type_names_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_of_type_names"
    # /home/szr/subquery/SQL2XML/YSmart.g:557:1: condition_is_of_type_names : condition_is_of_type_name ( COMMA condition_is_of_type_name )* ;
    def condition_is_of_type_names(self, ):

        retval = self.condition_is_of_type_names_return()
        retval.start = self.input.LT(1)
        condition_is_of_type_names_StartIndex = self.input.index()
        root_0 = None

        COMMA541 = None
        condition_is_of_type_name540 = None

        condition_is_of_type_name542 = None


        COMMA541_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 78):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:558:2: ( condition_is_of_type_name ( COMMA condition_is_of_type_name )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:558:4: condition_is_of_type_name ( COMMA condition_is_of_type_name )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names3832)
                condition_is_of_type_name540 = self.condition_is_of_type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, condition_is_of_type_name540.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:558:30: ( COMMA condition_is_of_type_name )*
                while True: #loop140
                    alt140 = 2
                    LA140_0 = self.input.LA(1)

                    if (LA140_0 == COMMA) :
                        alt140 = 1


                    if alt140 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:558:32: COMMA condition_is_of_type_name
                        pass 
                        COMMA541=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_is_of_type_names3836)
                        if self._state.backtracking == 0:

                            COMMA541_tree = self._adaptor.createWithPayload(COMMA541)
                            self._adaptor.addChild(root_0, COMMA541_tree)

                        self._state.following.append(self.FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names3838)
                        condition_is_of_type_name542 = self.condition_is_of_type_name()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, condition_is_of_type_name542.tree)


                    else:
                        break #loop140



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 78, condition_is_of_type_names_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_of_type_names"

    class condition_is_of_type_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_of_type_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_of_type_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:560:1: condition_is_of_type_name : ( k_only )? type_name ;
    def condition_is_of_type_name(self, ):

        retval = self.condition_is_of_type_name_return()
        retval.start = self.input.LT(1)
        condition_is_of_type_name_StartIndex = self.input.index()
        root_0 = None

        k_only543 = None

        type_name544 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 79):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:561:2: ( ( k_only )? type_name )
                # /home/szr/subquery/SQL2XML/YSmart.g:561:4: ( k_only )? type_name
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:561:4: ( k_only )?
                alt141 = 2
                LA141_0 = self.input.LA(1)

                if (LA141_0 == 324) :
                    alt141 = 1
                if alt141 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:561:6: k_only
                    pass 
                    self._state.following.append(self.FOLLOW_k_only_in_condition_is_of_type_name3853)
                    k_only543 = self.k_only()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_only543.tree)



                self._state.following.append(self.FOLLOW_type_name_in_condition_is_of_type_name3858)
                type_name544 = self.type_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, type_name544.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 79, condition_is_of_type_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_of_type_name"

    class condition_is_present_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_is_present_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_is_present"
    # /home/szr/subquery/SQL2XML/YSmart.g:563:1: condition_is_present : cell_reference k_is k_present ;
    def condition_is_present(self, ):

        retval = self.condition_is_present_return()
        retval.start = self.input.LT(1)
        condition_is_present_StartIndex = self.input.index()
        root_0 = None

        cell_reference545 = None

        k_is546 = None

        k_present547 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 80):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:564:2: ( cell_reference k_is k_present )
                # /home/szr/subquery/SQL2XML/YSmart.g:564:4: cell_reference k_is k_present
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_cell_reference_in_condition_is_present3868)
                cell_reference545 = self.cell_reference()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, cell_reference545.tree)
                self._state.following.append(self.FOLLOW_k_is_in_condition_is_present3870)
                k_is546 = self.k_is()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_is546.tree)
                self._state.following.append(self.FOLLOW_k_present_in_condition_is_present3872)
                k_present547 = self.k_present()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_present547.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 80, condition_is_present_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_is_present"

    class condition_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_like_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_like"
    # /home/szr/subquery/SQL2XML/YSmart.g:566:1: condition_like : sql_expression ( k_not )? ( k_like | k_likec | k_like2 | k_like4 ) sql_expression ( k_escape sql_expression )? ;
    def condition_like(self, ):

        retval = self.condition_like_return()
        retval.start = self.input.LT(1)
        condition_like_StartIndex = self.input.index()
        root_0 = None

        sql_expression548 = None

        k_not549 = None

        k_like550 = None

        k_likec551 = None

        k_like2552 = None

        k_like4553 = None

        sql_expression554 = None

        k_escape555 = None

        sql_expression556 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 81):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:567:2: ( sql_expression ( k_not )? ( k_like | k_likec | k_like2 | k_like4 ) sql_expression ( k_escape sql_expression )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:567:4: sql_expression ( k_not )? ( k_like | k_likec | k_like2 | k_like4 ) sql_expression ( k_escape sql_expression )?
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_condition_like3882)
                sql_expression548 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression548.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:567:19: ( k_not )?
                alt142 = 2
                LA142_0 = self.input.LA(1)

                if (LA142_0 == 157) :
                    alt142 = 1
                if alt142 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:21: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_like3886)
                    k_not549 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not549.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:567:30: ( k_like | k_likec | k_like2 | k_like4 )
                alt143 = 4
                LA143 = self.input.LA(1)
                if LA143 == 145:
                    alt143 = 1
                elif LA143 == 148:
                    alt143 = 2
                elif LA143 == 146:
                    alt143 = 3
                elif LA143 == 147:
                    alt143 = 4
                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    nvae = NoViableAltException("", 143, 0, self.input)

                    raise nvae

                if alt143 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:32: k_like
                    pass 
                    self._state.following.append(self.FOLLOW_k_like_in_condition_like3893)
                    k_like550 = self.k_like()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_like550.tree)


                elif alt143 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:41: k_likec
                    pass 
                    self._state.following.append(self.FOLLOW_k_likec_in_condition_like3897)
                    k_likec551 = self.k_likec()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_likec551.tree)


                elif alt143 == 3:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:51: k_like2
                    pass 
                    self._state.following.append(self.FOLLOW_k_like2_in_condition_like3901)
                    k_like2552 = self.k_like2()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_like2552.tree)


                elif alt143 == 4:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:61: k_like4
                    pass 
                    self._state.following.append(self.FOLLOW_k_like4_in_condition_like3905)
                    k_like4553 = self.k_like4()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_like4553.tree)



                self._state.following.append(self.FOLLOW_sql_expression_in_condition_like3909)
                sql_expression554 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression554.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:567:86: ( k_escape sql_expression )?
                alt144 = 2
                LA144_0 = self.input.LA(1)

                if (LA144_0 == 259) :
                    alt144 = 1
                if alt144 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:567:88: k_escape sql_expression
                    pass 
                    self._state.following.append(self.FOLLOW_k_escape_in_condition_like3913)
                    k_escape555 = self.k_escape()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_escape555.tree)
                    self._state.following.append(self.FOLLOW_sql_expression_in_condition_like3915)
                    sql_expression556 = self.sql_expression()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expression556.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 81, condition_like_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_like"

    class condition_memeber_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_memeber_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_memeber"
    # /home/szr/subquery/SQL2XML/YSmart.g:569:1: condition_memeber : sql_expression ( k_not )? k_member ( k_of )? nested_table_column_name ;
    def condition_memeber(self, ):

        retval = self.condition_memeber_return()
        retval.start = self.input.LT(1)
        condition_memeber_StartIndex = self.input.index()
        root_0 = None

        sql_expression557 = None

        k_not558 = None

        k_member559 = None

        k_of560 = None

        nested_table_column_name561 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 82):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:570:2: ( sql_expression ( k_not )? k_member ( k_of )? nested_table_column_name )
                # /home/szr/subquery/SQL2XML/YSmart.g:570:4: sql_expression ( k_not )? k_member ( k_of )? nested_table_column_name
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_condition_memeber3928)
                sql_expression557 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression557.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:570:19: ( k_not )?
                alt145 = 2
                LA145_0 = self.input.LA(1)

                if (LA145_0 == 157) :
                    alt145 = 1
                if alt145 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:570:21: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_memeber3932)
                    k_not558 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not558.tree)



                self._state.following.append(self.FOLLOW_k_member_in_condition_memeber3937)
                k_member559 = self.k_member()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_member559.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:570:39: ( k_of )?
                alt146 = 2
                LA146_0 = self.input.LA(1)

                if (LA146_0 == 162) :
                    alt146 = 1
                if alt146 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:570:41: k_of
                    pass 
                    self._state.following.append(self.FOLLOW_k_of_in_condition_memeber3941)
                    k_of560 = self.k_of()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_of560.tree)



                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_memeber3946)
                nested_table_column_name561 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name561.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 82, condition_memeber_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_memeber"

    class condition_between_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_between_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_between"
    # /home/szr/subquery/SQL2XML/YSmart.g:572:1: condition_between : sql_expression ( k_not )? k_between sql_expression k_and sql_expression ;
    def condition_between(self, ):

        retval = self.condition_between_return()
        retval.start = self.input.LT(1)
        condition_between_StartIndex = self.input.index()
        root_0 = None

        sql_expression562 = None

        k_not563 = None

        k_between564 = None

        sql_expression565 = None

        k_and566 = None

        sql_expression567 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 83):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:573:2: ( sql_expression ( k_not )? k_between sql_expression k_and sql_expression )
                # /home/szr/subquery/SQL2XML/YSmart.g:573:4: sql_expression ( k_not )? k_between sql_expression k_and sql_expression
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between3956)
                sql_expression562 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression562.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:573:19: ( k_not )?
                alt147 = 2
                LA147_0 = self.input.LA(1)

                if (LA147_0 == 157) :
                    alt147 = 1
                if alt147 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:573:21: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_between3960)
                    k_not563 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not563.tree)



                self._state.following.append(self.FOLLOW_k_between_in_condition_between3965)
                k_between564 = self.k_between()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_between564.tree)
                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between3967)
                sql_expression565 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression565.tree)
                self._state.following.append(self.FOLLOW_k_and_in_condition_between3969)
                k_and566 = self.k_and()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_and566.tree)
                self._state.following.append(self.FOLLOW_sql_expression_in_condition_between3971)
                sql_expression567 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression567.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 83, condition_between_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_between"

    class condition_regexp_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_regexp_like_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_regexp_like"
    # /home/szr/subquery/SQL2XML/YSmart.g:575:1: condition_regexp_like : k_regexp_like LPAREN call_parameters RPAREN ;
    def condition_regexp_like(self, ):

        retval = self.condition_regexp_like_return()
        retval.start = self.input.LT(1)
        condition_regexp_like_StartIndex = self.input.index()
        root_0 = None

        LPAREN569 = None
        RPAREN571 = None
        k_regexp_like568 = None

        call_parameters570 = None


        LPAREN569_tree = None
        RPAREN571_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 84):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:576:2: ( k_regexp_like LPAREN call_parameters RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:576:4: k_regexp_like LPAREN call_parameters RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_regexp_like_in_condition_regexp_like3981)
                k_regexp_like568 = self.k_regexp_like()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_regexp_like568.tree)
                LPAREN569=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_regexp_like3983)
                if self._state.backtracking == 0:

                    LPAREN569_tree = self._adaptor.createWithPayload(LPAREN569)
                    self._adaptor.addChild(root_0, LPAREN569_tree)

                self._state.following.append(self.FOLLOW_call_parameters_in_condition_regexp_like3985)
                call_parameters570 = self.call_parameters()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, call_parameters570.tree)
                RPAREN571=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_regexp_like3987)
                if self._state.backtracking == 0:

                    RPAREN571_tree = self._adaptor.createWithPayload(RPAREN571)
                    self._adaptor.addChild(root_0, RPAREN571_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 84, condition_regexp_like_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_regexp_like"

    class condition_submultiset_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_submultiset_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_submultiset"
    # /home/szr/subquery/SQL2XML/YSmart.g:578:1: condition_submultiset : nested_table_column_name ( k_not )? k_submultiset ( k_of )? nested_table_column_name ;
    def condition_submultiset(self, ):

        retval = self.condition_submultiset_return()
        retval.start = self.input.LT(1)
        condition_submultiset_StartIndex = self.input.index()
        root_0 = None

        nested_table_column_name572 = None

        k_not573 = None

        k_submultiset574 = None

        k_of575 = None

        nested_table_column_name576 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 85):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:579:2: ( nested_table_column_name ( k_not )? k_submultiset ( k_of )? nested_table_column_name )
                # /home/szr/subquery/SQL2XML/YSmart.g:579:4: nested_table_column_name ( k_not )? k_submultiset ( k_of )? nested_table_column_name
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_submultiset3997)
                nested_table_column_name572 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name572.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:579:29: ( k_not )?
                alt148 = 2
                LA148_0 = self.input.LA(1)

                if (LA148_0 == 157) :
                    alt148 = 1
                if alt148 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:579:31: k_not
                    pass 
                    self._state.following.append(self.FOLLOW_k_not_in_condition_submultiset4001)
                    k_not573 = self.k_not()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_not573.tree)



                self._state.following.append(self.FOLLOW_k_submultiset_in_condition_submultiset4006)
                k_submultiset574 = self.k_submultiset()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_submultiset574.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:579:54: ( k_of )?
                alt149 = 2
                LA149_0 = self.input.LA(1)

                if (LA149_0 == 162) :
                    alt149 = 1
                if alt149 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:579:56: k_of
                    pass 
                    self._state.following.append(self.FOLLOW_k_of_in_condition_submultiset4010)
                    k_of575 = self.k_of()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_of575.tree)



                self._state.following.append(self.FOLLOW_nested_table_column_name_in_condition_submultiset4015)
                nested_table_column_name576 = self.nested_table_column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, nested_table_column_name576.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 85, condition_submultiset_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_submultiset"

    class condition_equals_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_equals_path_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_equals_path"
    # /home/szr/subquery/SQL2XML/YSmart.g:581:1: condition_equals_path : k_equals_path LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN ;
    def condition_equals_path(self, ):

        retval = self.condition_equals_path_return()
        retval.start = self.input.LT(1)
        condition_equals_path_StartIndex = self.input.index()
        root_0 = None

        LPAREN578 = None
        COMMA580 = None
        COMMA582 = None
        RPAREN584 = None
        k_equals_path577 = None

        column_name579 = None

        path_string581 = None

        correlation_integer583 = None


        LPAREN578_tree = None
        COMMA580_tree = None
        COMMA582_tree = None
        RPAREN584_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 86):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:582:2: ( k_equals_path LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:582:4: k_equals_path LPAREN column_name COMMA path_string ( COMMA correlation_integer )? RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_equals_path_in_condition_equals_path4025)
                k_equals_path577 = self.k_equals_path()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_equals_path577.tree)
                LPAREN578=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_equals_path4027)
                if self._state.backtracking == 0:

                    LPAREN578_tree = self._adaptor.createWithPayload(LPAREN578)
                    self._adaptor.addChild(root_0, LPAREN578_tree)

                self._state.following.append(self.FOLLOW_column_name_in_condition_equals_path4029)
                column_name579 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name579.tree)
                COMMA580=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_equals_path4031)
                if self._state.backtracking == 0:

                    COMMA580_tree = self._adaptor.createWithPayload(COMMA580)
                    self._adaptor.addChild(root_0, COMMA580_tree)

                self._state.following.append(self.FOLLOW_path_string_in_condition_equals_path4033)
                path_string581 = self.path_string()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, path_string581.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:582:55: ( COMMA correlation_integer )?
                alt150 = 2
                LA150_0 = self.input.LA(1)

                if (LA150_0 == COMMA) :
                    alt150 = 1
                if alt150 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:582:57: COMMA correlation_integer
                    pass 
                    COMMA582=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_equals_path4037)
                    if self._state.backtracking == 0:

                        COMMA582_tree = self._adaptor.createWithPayload(COMMA582)
                        self._adaptor.addChild(root_0, COMMA582_tree)

                    self._state.following.append(self.FOLLOW_correlation_integer_in_condition_equals_path4039)
                    correlation_integer583 = self.correlation_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, correlation_integer583.tree)



                RPAREN584=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_equals_path4044)
                if self._state.backtracking == 0:

                    RPAREN584_tree = self._adaptor.createWithPayload(RPAREN584)
                    self._adaptor.addChild(root_0, RPAREN584_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 86, condition_equals_path_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_equals_path"

    class condition_under_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_under_path_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_under_path"
    # /home/szr/subquery/SQL2XML/YSmart.g:584:1: condition_under_path : k_under_path LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN ;
    def condition_under_path(self, ):

        retval = self.condition_under_path_return()
        retval.start = self.input.LT(1)
        condition_under_path_StartIndex = self.input.index()
        root_0 = None

        LPAREN586 = None
        COMMA588 = None
        COMMA590 = None
        COMMA592 = None
        RPAREN594 = None
        k_under_path585 = None

        column_name587 = None

        levels589 = None

        path_string591 = None

        correlation_integer593 = None


        LPAREN586_tree = None
        COMMA588_tree = None
        COMMA590_tree = None
        COMMA592_tree = None
        RPAREN594_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 87):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:585:2: ( k_under_path LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:585:4: k_under_path LPAREN column_name ( COMMA levels )? COMMA path_string ( COMMA correlation_integer )? RPAREN
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_k_under_path_in_condition_under_path4054)
                k_under_path585 = self.k_under_path()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, k_under_path585.tree)
                LPAREN586=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_under_path4056)
                if self._state.backtracking == 0:

                    LPAREN586_tree = self._adaptor.createWithPayload(LPAREN586)
                    self._adaptor.addChild(root_0, LPAREN586_tree)

                self._state.following.append(self.FOLLOW_column_name_in_condition_under_path4058)
                column_name587 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name587.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:585:36: ( COMMA levels )?
                alt151 = 2
                LA151_0 = self.input.LA(1)

                if (LA151_0 == COMMA) :
                    LA151_1 = self.input.LA(2)

                    if (LA151_1 == NUMBER) :
                        alt151 = 1
                if alt151 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:585:38: COMMA levels
                    pass 
                    COMMA588=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path4062)
                    if self._state.backtracking == 0:

                        COMMA588_tree = self._adaptor.createWithPayload(COMMA588)
                        self._adaptor.addChild(root_0, COMMA588_tree)

                    self._state.following.append(self.FOLLOW_levels_in_condition_under_path4064)
                    levels589 = self.levels()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, levels589.tree)



                COMMA590=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path4069)
                if self._state.backtracking == 0:

                    COMMA590_tree = self._adaptor.createWithPayload(COMMA590)
                    self._adaptor.addChild(root_0, COMMA590_tree)

                self._state.following.append(self.FOLLOW_path_string_in_condition_under_path4071)
                path_string591 = self.path_string()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, path_string591.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:585:72: ( COMMA correlation_integer )?
                alt152 = 2
                LA152_0 = self.input.LA(1)

                if (LA152_0 == COMMA) :
                    alt152 = 1
                if alt152 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:585:74: COMMA correlation_integer
                    pass 
                    COMMA592=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_condition_under_path4075)
                    if self._state.backtracking == 0:

                        COMMA592_tree = self._adaptor.createWithPayload(COMMA592)
                        self._adaptor.addChild(root_0, COMMA592_tree)

                    self._state.following.append(self.FOLLOW_correlation_integer_in_condition_under_path4077)
                    correlation_integer593 = self.correlation_integer()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, correlation_integer593.tree)



                RPAREN594=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_under_path4082)
                if self._state.backtracking == 0:

                    RPAREN594_tree = self._adaptor.createWithPayload(RPAREN594)
                    self._adaptor.addChild(root_0, RPAREN594_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 87, condition_under_path_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_under_path"

    class levels_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.levels_return, self).__init__()

            self.tree = None




    # $ANTLR start "levels"
    # /home/szr/subquery/SQL2XML/YSmart.g:587:1: levels : integer ;
    def levels(self, ):

        retval = self.levels_return()
        retval.start = self.input.LT(1)
        levels_StartIndex = self.input.index()
        root_0 = None

        integer595 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 88):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:588:2: ( integer )
                # /home/szr/subquery/SQL2XML/YSmart.g:588:4: integer
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_integer_in_levels4092)
                integer595 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer595.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 88, levels_StartIndex, success)

            pass
        return retval

    # $ANTLR end "levels"

    class correlation_integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.correlation_integer_return, self).__init__()

            self.tree = None




    # $ANTLR start "correlation_integer"
    # /home/szr/subquery/SQL2XML/YSmart.g:590:1: correlation_integer : integer ;
    def correlation_integer(self, ):

        retval = self.correlation_integer_return()
        retval.start = self.input.LT(1)
        correlation_integer_StartIndex = self.input.index()
        root_0 = None

        integer596 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 89):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:591:2: ( integer )
                # /home/szr/subquery/SQL2XML/YSmart.g:591:4: integer
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_integer_in_correlation_integer4102)
                integer596 = self.integer()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, integer596.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 89, correlation_integer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "correlation_integer"

    class path_string_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.path_string_return, self).__init__()

            self.tree = None




    # $ANTLR start "path_string"
    # /home/szr/subquery/SQL2XML/YSmart.g:593:1: path_string : quoted_string ;
    def path_string(self, ):

        retval = self.path_string_return()
        retval.start = self.input.LT(1)
        path_string_StartIndex = self.input.index()
        root_0 = None

        quoted_string597 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 90):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:594:2: ( quoted_string )
                # /home/szr/subquery/SQL2XML/YSmart.g:594:4: quoted_string
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_quoted_string_in_path_string4112)
                quoted_string597 = self.quoted_string()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, quoted_string597.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 90, path_string_StartIndex, success)

            pass
        return retval

    # $ANTLR end "path_string"

    class type_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.type_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "type_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:596:1: type_name : identifier ( DOT identifier )* ;
    def type_name(self, ):

        retval = self.type_name_return()
        retval.start = self.input.LT(1)
        type_name_StartIndex = self.input.index()
        root_0 = None

        DOT599 = None
        identifier598 = None

        identifier600 = None


        DOT599_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 91):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:597:2: ( identifier ( DOT identifier )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:597:4: identifier ( DOT identifier )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_identifier_in_type_name4122)
                identifier598 = self.identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, identifier598.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:597:15: ( DOT identifier )*
                while True: #loop153
                    alt153 = 2
                    LA153_0 = self.input.LA(1)

                    if (LA153_0 == DOT) :
                        alt153 = 1


                    if alt153 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:597:17: DOT identifier
                        pass 
                        DOT599=self.match(self.input, DOT, self.FOLLOW_DOT_in_type_name4126)
                        if self._state.backtracking == 0:

                            DOT599_tree = self._adaptor.createWithPayload(DOT599)
                            self._adaptor.addChild(root_0, DOT599_tree)

                        self._state.following.append(self.FOLLOW_identifier_in_type_name4128)
                        identifier600 = self.identifier()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, identifier600.tree)


                    else:
                        break #loop153



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 91, type_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "type_name"

    class integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.integer_return, self).__init__()

            self.tree = None




    # $ANTLR start "integer"
    # /home/szr/subquery/SQL2XML/YSmart.g:599:1: integer : NUMBER ;
    def integer(self, ):

        retval = self.integer_return()
        retval.start = self.input.LT(1)
        integer_StartIndex = self.input.index()
        root_0 = None

        NUMBER601 = None

        NUMBER601_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 92):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:600:2: ( NUMBER )
                # /home/szr/subquery/SQL2XML/YSmart.g:600:4: NUMBER
                pass 
                root_0 = self._adaptor.nil()

                NUMBER601=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_integer4141)
                if self._state.backtracking == 0:

                    NUMBER601_tree = self._adaptor.createWithPayload(NUMBER601)
                    self._adaptor.addChild(root_0, NUMBER601_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 92, integer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "integer"

    class column_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.column_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "column_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:602:1: column_name : sql_identifier ;
    def column_name(self, ):

        retval = self.column_name_return()
        retval.start = self.input.LT(1)
        column_name_StartIndex = self.input.index()
        root_0 = None

        sql_identifier602 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 93):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:603:2: ( sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:603:4: sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_column_name4151)
                sql_identifier602 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier602.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 93, column_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "column_name"

    class nested_table_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.nested_table_return, self).__init__()

            self.tree = None




    # $ANTLR start "nested_table"
    # /home/szr/subquery/SQL2XML/YSmart.g:605:1: nested_table : sql_identifier ;
    def nested_table(self, ):

        retval = self.nested_table_return()
        retval.start = self.input.LT(1)
        nested_table_StartIndex = self.input.index()
        root_0 = None

        sql_identifier603 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 94):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:606:2: ( sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:606:4: sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_nested_table4161)
                sql_identifier603 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier603.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 94, nested_table_StartIndex, success)

            pass
        return retval

    # $ANTLR end "nested_table"

    class nested_table_column_name_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.nested_table_column_name_return, self).__init__()

            self.tree = None




    # $ANTLR start "nested_table_column_name"
    # /home/szr/subquery/SQL2XML/YSmart.g:608:1: nested_table_column_name : ( schema_name DOT )? ( table_name DOT )? ( nested_table DOT )? column_name ;
    def nested_table_column_name(self, ):

        retval = self.nested_table_column_name_return()
        retval.start = self.input.LT(1)
        nested_table_column_name_StartIndex = self.input.index()
        root_0 = None

        DOT605 = None
        DOT607 = None
        DOT609 = None
        schema_name604 = None

        table_name606 = None

        nested_table608 = None

        column_name610 = None


        DOT605_tree = None
        DOT607_tree = None
        DOT609_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 95):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:609:2: ( ( schema_name DOT )? ( table_name DOT )? ( nested_table DOT )? column_name )
                # /home/szr/subquery/SQL2XML/YSmart.g:609:4: ( schema_name DOT )? ( table_name DOT )? ( nested_table DOT )? column_name
                pass 
                root_0 = self._adaptor.nil()

                # /home/szr/subquery/SQL2XML/YSmart.g:609:4: ( schema_name DOT )?
                alt154 = 2
                LA154_0 = self.input.LA(1)

                if ((VECTOR <= LA154_0 <= DOUBLEQUOTED_STRING)) :
                    LA154_1 = self.input.LA(2)

                    if (LA154_1 == DOT) :
                        LA154_5 = self.input.LA(3)

                        if (self.synpred284_YSmart()) :
                            alt154 = 1
                elif (LA154_0 == 91 or (211 <= LA154_0 <= 367) or (369 <= LA154_0 <= 387) or (390 <= LA154_0 <= 428) or (430 <= LA154_0 <= 439) or (442 <= LA154_0 <= 453) or LA154_0 == 455 or (460 <= LA154_0 <= 502) or (508 <= LA154_0 <= 528) or (530 <= LA154_0 <= 537) or (539 <= LA154_0 <= 546)) :
                    LA154_2 = self.input.LA(2)

                    if (LA154_2 == DOT) :
                        LA154_5 = self.input.LA(3)

                        if (self.synpred284_YSmart()) :
                            alt154 = 1
                elif (LA154_0 == 178) :
                    LA154_3 = self.input.LA(2)

                    if (LA154_3 == DOT) :
                        LA154_5 = self.input.LA(3)

                        if (self.synpred284_YSmart()) :
                            alt154 = 1
                elif (LA154_0 == 180) :
                    LA154_4 = self.input.LA(2)

                    if (LA154_4 == DOT) :
                        LA154_5 = self.input.LA(3)

                        if (self.synpred284_YSmart()) :
                            alt154 = 1
                if alt154 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:609:6: schema_name DOT
                    pass 
                    self._state.following.append(self.FOLLOW_schema_name_in_nested_table_column_name4173)
                    schema_name604 = self.schema_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, schema_name604.tree)
                    DOT605=self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name4175)
                    if self._state.backtracking == 0:

                        DOT605_tree = self._adaptor.createWithPayload(DOT605)
                        self._adaptor.addChild(root_0, DOT605_tree)




                # /home/szr/subquery/SQL2XML/YSmart.g:609:25: ( table_name DOT )?
                alt155 = 2
                LA155_0 = self.input.LA(1)

                if ((VECTOR <= LA155_0 <= DOUBLEQUOTED_STRING)) :
                    LA155_1 = self.input.LA(2)

                    if (LA155_1 == DOT) :
                        LA155_5 = self.input.LA(3)

                        if (self.synpred285_YSmart()) :
                            alt155 = 1
                elif (LA155_0 == 91 or (211 <= LA155_0 <= 367) or (369 <= LA155_0 <= 387) or (390 <= LA155_0 <= 428) or (430 <= LA155_0 <= 439) or (442 <= LA155_0 <= 453) or LA155_0 == 455 or (460 <= LA155_0 <= 502) or (508 <= LA155_0 <= 528) or (530 <= LA155_0 <= 537) or (539 <= LA155_0 <= 546)) :
                    LA155_2 = self.input.LA(2)

                    if (LA155_2 == DOT) :
                        LA155_5 = self.input.LA(3)

                        if (self.synpred285_YSmart()) :
                            alt155 = 1
                elif (LA155_0 == 178) :
                    LA155_3 = self.input.LA(2)

                    if (LA155_3 == DOT) :
                        LA155_5 = self.input.LA(3)

                        if (self.synpred285_YSmart()) :
                            alt155 = 1
                elif (LA155_0 == 180) :
                    LA155_4 = self.input.LA(2)

                    if (LA155_4 == DOT) :
                        LA155_5 = self.input.LA(3)

                        if (self.synpred285_YSmart()) :
                            alt155 = 1
                if alt155 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:609:26: table_name DOT
                    pass 
                    self._state.following.append(self.FOLLOW_table_name_in_nested_table_column_name4181)
                    table_name606 = self.table_name()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, table_name606.tree)
                    DOT607=self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name4183)
                    if self._state.backtracking == 0:

                        DOT607_tree = self._adaptor.createWithPayload(DOT607)
                        self._adaptor.addChild(root_0, DOT607_tree)




                # /home/szr/subquery/SQL2XML/YSmart.g:609:43: ( nested_table DOT )?
                alt156 = 2
                LA156_0 = self.input.LA(1)

                if ((VECTOR <= LA156_0 <= DOUBLEQUOTED_STRING)) :
                    LA156_1 = self.input.LA(2)

                    if (LA156_1 == DOT) :
                        alt156 = 1
                elif (LA156_0 == 91 or (211 <= LA156_0 <= 367) or (369 <= LA156_0 <= 387) or (390 <= LA156_0 <= 428) or (430 <= LA156_0 <= 439) or (442 <= LA156_0 <= 453) or LA156_0 == 455 or (460 <= LA156_0 <= 502) or (508 <= LA156_0 <= 528) or (530 <= LA156_0 <= 537) or (539 <= LA156_0 <= 546)) :
                    LA156_2 = self.input.LA(2)

                    if (LA156_2 == DOT) :
                        alt156 = 1
                elif (LA156_0 == 178) :
                    LA156_3 = self.input.LA(2)

                    if (LA156_3 == DOT) :
                        alt156 = 1
                elif (LA156_0 == 180) :
                    LA156_4 = self.input.LA(2)

                    if (LA156_4 == DOT) :
                        alt156 = 1
                if alt156 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:609:44: nested_table DOT
                    pass 
                    self._state.following.append(self.FOLLOW_nested_table_in_nested_table_column_name4188)
                    nested_table608 = self.nested_table()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, nested_table608.tree)
                    DOT609=self.match(self.input, DOT, self.FOLLOW_DOT_in_nested_table_column_name4190)
                    if self._state.backtracking == 0:

                        DOT609_tree = self._adaptor.createWithPayload(DOT609)
                        self._adaptor.addChild(root_0, DOT609_tree)




                self._state.following.append(self.FOLLOW_column_name_in_nested_table_column_name4194)
                column_name610 = self.column_name()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, column_name610.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 95, nested_table_column_name_StartIndex, success)

            pass
        return retval

    # $ANTLR end "nested_table_column_name"

    class sql_expressions_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.sql_expressions_return, self).__init__()

            self.tree = None




    # $ANTLR start "sql_expressions"
    # /home/szr/subquery/SQL2XML/YSmart.g:611:1: sql_expressions : sql_expression ( COMMA sql_expression )* ;
    def sql_expressions(self, ):

        retval = self.sql_expressions_return()
        retval.start = self.input.LT(1)
        sql_expressions_StartIndex = self.input.index()
        root_0 = None

        COMMA612 = None
        sql_expression611 = None

        sql_expression613 = None


        COMMA612_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 96):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:612:2: ( sql_expression ( COMMA sql_expression )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:612:4: sql_expression ( COMMA sql_expression )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_sql_expressions4204)
                sql_expression611 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression611.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:612:19: ( COMMA sql_expression )*
                while True: #loop157
                    alt157 = 2
                    LA157_0 = self.input.LA(1)

                    if (LA157_0 == COMMA) :
                        LA157_2 = self.input.LA(2)

                        if (self.synpred287_YSmart()) :
                            alt157 = 1




                    if alt157 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:612:21: COMMA sql_expression
                        pass 
                        COMMA612=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_sql_expressions4208)
                        if self._state.backtracking == 0:

                            COMMA612_tree = self._adaptor.createWithPayload(COMMA612)
                            self._adaptor.addChild(root_0, COMMA612_tree)

                        self._state.following.append(self.FOLLOW_sql_expression_in_sql_expressions4210)
                        sql_expression613 = self.sql_expression()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, sql_expression613.tree)


                    else:
                        break #loop157



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 96, sql_expressions_StartIndex, success)

            pass
        return retval

    # $ANTLR end "sql_expressions"

    class grouping_expression_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.grouping_expression_list_return, self).__init__()

            self.tree = None




    # $ANTLR start "grouping_expression_list"
    # /home/szr/subquery/SQL2XML/YSmart.g:614:1: grouping_expression_list : expression_list ( COMMA expression_list )* ;
    def grouping_expression_list(self, ):

        retval = self.grouping_expression_list_return()
        retval.start = self.input.LT(1)
        grouping_expression_list_StartIndex = self.input.index()
        root_0 = None

        COMMA615 = None
        expression_list614 = None

        expression_list616 = None


        COMMA615_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 97):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:615:2: ( expression_list ( COMMA expression_list )* )
                # /home/szr/subquery/SQL2XML/YSmart.g:615:4: expression_list ( COMMA expression_list )*
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_expression_list_in_grouping_expression_list4223)
                expression_list614 = self.expression_list()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, expression_list614.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:615:20: ( COMMA expression_list )*
                while True: #loop158
                    alt158 = 2
                    LA158_0 = self.input.LA(1)

                    if (LA158_0 == COMMA) :
                        LA158_1 = self.input.LA(2)

                        if (self.synpred288_YSmart()) :
                            alt158 = 1




                    if alt158 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:615:22: COMMA expression_list
                        pass 
                        COMMA615=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_grouping_expression_list4227)
                        if self._state.backtracking == 0:

                            COMMA615_tree = self._adaptor.createWithPayload(COMMA615)
                            self._adaptor.addChild(root_0, COMMA615_tree)

                        self._state.following.append(self.FOLLOW_expression_list_in_grouping_expression_list4229)
                        expression_list616 = self.expression_list()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            self._adaptor.addChild(root_0, expression_list616.tree)


                    else:
                        break #loop158



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 97, grouping_expression_list_StartIndex, success)

            pass
        return retval

    # $ANTLR end "grouping_expression_list"

    class expression_list_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.expression_list_return, self).__init__()

            self.tree = None




    # $ANTLR start "expression_list"
    # /home/szr/subquery/SQL2XML/YSmart.g:617:1: expression_list : ( LPAREN sql_expressions RPAREN | sql_expressions );
    def expression_list(self, ):

        retval = self.expression_list_return()
        retval.start = self.input.LT(1)
        expression_list_StartIndex = self.input.index()
        root_0 = None

        LPAREN617 = None
        RPAREN619 = None
        sql_expressions618 = None

        sql_expressions620 = None


        LPAREN617_tree = None
        RPAREN619_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 98):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:618:2: ( LPAREN sql_expressions RPAREN | sql_expressions )
                alt159 = 2
                alt159 = self.dfa159.predict(self.input)
                if alt159 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:618:4: LPAREN sql_expressions RPAREN
                    pass 
                    root_0 = self._adaptor.nil()

                    LPAREN617=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_expression_list4242)
                    if self._state.backtracking == 0:

                        LPAREN617_tree = self._adaptor.createWithPayload(LPAREN617)
                        self._adaptor.addChild(root_0, LPAREN617_tree)

                    self._state.following.append(self.FOLLOW_sql_expressions_in_expression_list4244)
                    sql_expressions618 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions618.tree)
                    RPAREN619=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_expression_list4246)
                    if self._state.backtracking == 0:

                        RPAREN619_tree = self._adaptor.createWithPayload(RPAREN619)
                        self._adaptor.addChild(root_0, RPAREN619_tree)



                elif alt159 == 2:
                    # /home/szr/subquery/SQL2XML/YSmart.g:619:4: sql_expressions
                    pass 
                    root_0 = self._adaptor.nil()

                    self._state.following.append(self.FOLLOW_sql_expressions_in_expression_list4251)
                    sql_expressions620 = self.sql_expressions()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, sql_expressions620.tree)


                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 98, expression_list_StartIndex, success)

            pass
        return retval

    # $ANTLR end "expression_list"

    class cell_reference_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.cell_reference_return, self).__init__()

            self.tree = None




    # $ANTLR start "cell_reference"
    # /home/szr/subquery/SQL2XML/YSmart.g:621:1: cell_reference : sql_identifier ;
    def cell_reference(self, ):

        retval = self.cell_reference_return()
        retval.start = self.input.LT(1)
        cell_reference_StartIndex = self.input.index()
        root_0 = None

        sql_identifier621 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 99):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:622:2: ( sql_identifier )
                # /home/szr/subquery/SQL2XML/YSmart.g:622:4: sql_identifier
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_identifier_in_cell_reference4261)
                sql_identifier621 = self.sql_identifier()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_identifier621.tree)



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 99, cell_reference_StartIndex, success)

            pass
        return retval

    # $ANTLR end "cell_reference"

    class condition_paren_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.condition_paren_return, self).__init__()

            self.tree = None




    # $ANTLR start "condition_paren"
    # /home/szr/subquery/SQL2XML/YSmart.g:625:1: condition_paren : LPAREN sql_condition RPAREN ;
    def condition_paren(self, ):

        retval = self.condition_paren_return()
        retval.start = self.input.LT(1)
        condition_paren_StartIndex = self.input.index()
        root_0 = None

        LPAREN622 = None
        RPAREN624 = None
        sql_condition623 = None


        LPAREN622_tree = None
        RPAREN624_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 100):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:626:2: ( LPAREN sql_condition RPAREN )
                # /home/szr/subquery/SQL2XML/YSmart.g:626:4: LPAREN sql_condition RPAREN
                pass 
                root_0 = self._adaptor.nil()

                LPAREN622=self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_condition_paren4272)
                if self._state.backtracking == 0:

                    LPAREN622_tree = self._adaptor.createWithPayload(LPAREN622)
                    self._adaptor.addChild(root_0, LPAREN622_tree)

                self._state.following.append(self.FOLLOW_sql_condition_in_condition_paren4274)
                sql_condition623 = self.sql_condition()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_condition623.tree)
                RPAREN624=self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_condition_paren4276)
                if self._state.backtracking == 0:

                    RPAREN624_tree = self._adaptor.createWithPayload(RPAREN624)
                    self._adaptor.addChild(root_0, RPAREN624_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 100, condition_paren_StartIndex, success)

            pass
        return retval

    # $ANTLR end "condition_paren"

    class order_by_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.order_by_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "order_by_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:633:1: order_by_clause : k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* -> ^( 't_order_by' k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* ) ;
    def order_by_clause(self, ):

        retval = self.order_by_clause_return()
        retval.start = self.input.LT(1)
        order_by_clause_StartIndex = self.input.index()
        root_0 = None

        k_order625 = None

        k_siblings626 = None

        k_by627 = None

        order_by_clause_part_first628 = None

        order_by_clause_part_next629 = None


        stream_k_order = RewriteRuleSubtreeStream(self._adaptor, "rule k_order")
        stream_order_by_clause_part_first = RewriteRuleSubtreeStream(self._adaptor, "rule order_by_clause_part_first")
        stream_k_by = RewriteRuleSubtreeStream(self._adaptor, "rule k_by")
        stream_order_by_clause_part_next = RewriteRuleSubtreeStream(self._adaptor, "rule order_by_clause_part_next")
        stream_k_siblings = RewriteRuleSubtreeStream(self._adaptor, "rule k_siblings")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 101):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:634:2: ( k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* -> ^( 't_order_by' k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:634:4: k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )*
                pass 
                self._state.following.append(self.FOLLOW_k_order_in_order_by_clause4291)
                k_order625 = self.k_order()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_order.add(k_order625.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:634:12: ( k_siblings )?
                alt160 = 2
                LA160_0 = self.input.LA(1)

                if (LA160_0 == 522) :
                    alt160 = 1
                if alt160 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_siblings
                    pass 
                    self._state.following.append(self.FOLLOW_k_siblings_in_order_by_clause4293)
                    k_siblings626 = self.k_siblings()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        stream_k_siblings.add(k_siblings626.tree)



                self._state.following.append(self.FOLLOW_k_by_in_order_by_clause4297)
                k_by627 = self.k_by()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_by.add(k_by627.tree)
                self._state.following.append(self.FOLLOW_order_by_clause_part_first_in_order_by_clause4299)
                order_by_clause_part_first628 = self.order_by_clause_part_first()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_order_by_clause_part_first.add(order_by_clause_part_first628.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:634:57: ( order_by_clause_part_next )*
                while True: #loop161
                    alt161 = 2
                    LA161_0 = self.input.LA(1)

                    if (LA161_0 == COMMA) :
                        alt161 = 1


                    if alt161 == 1:
                        # /home/szr/subquery/SQL2XML/YSmart.g:0:0: order_by_clause_part_next
                        pass 
                        self._state.following.append(self.FOLLOW_order_by_clause_part_next_in_order_by_clause4301)
                        order_by_clause_part_next629 = self.order_by_clause_part_next()

                        self._state.following.pop()
                        if self._state.backtracking == 0:
                            stream_order_by_clause_part_next.add(order_by_clause_part_next629.tree)


                    else:
                        break #loop161

                # AST Rewrite
                # elements: k_siblings, order_by_clause_part_next, k_by, order_by_clause_part_first, k_order, T_ORDER_BY_CLAUSE
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 635:2: -> ^( 't_order_by' k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* )
                    # /home/szr/subquery/SQL2XML/YSmart.g:635:5: ^( 't_order_by' k_order ( k_siblings )? k_by order_by_clause_part_first ( order_by_clause_part_next )* )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_ORDER_BY_CLAUSE, "T_ORDER_BY_CLAUSE"), root_1)

                    self._adaptor.addChild(root_1, stream_k_order.nextTree())
                    # /home/szr/subquery/SQL2XML/YSmart.g:635:28: ( k_siblings )?
                    if stream_k_siblings.hasNext():
                        self._adaptor.addChild(root_1, stream_k_siblings.nextTree())


                    stream_k_siblings.reset();
                    self._adaptor.addChild(root_1, stream_k_by.nextTree())
                    self._adaptor.addChild(root_1, stream_order_by_clause_part_first.nextTree())
                    # /home/szr/subquery/SQL2XML/YSmart.g:635:73: ( order_by_clause_part_next )*
                    while stream_order_by_clause_part_next.hasNext():
                        self._adaptor.addChild(root_1, stream_order_by_clause_part_next.nextTree())


                    stream_order_by_clause_part_next.reset();

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 101, order_by_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "order_by_clause"

    class order_by_clause_part_first_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.order_by_clause_part_first_return, self).__init__()

            self.tree = None




    # $ANTLR start "order_by_clause_part_first"
    # /home/szr/subquery/SQL2XML/YSmart.g:637:1: order_by_clause_part_first : sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )? ;
    def order_by_clause_part_first(self, ):

        retval = self.order_by_clause_part_first_return()
        retval.start = self.input.LT(1)
        order_by_clause_part_first_StartIndex = self.input.index()
        root_0 = None

        sql_expression630 = None

        k_asc631 = None

        k_desc632 = None

        k_nulls633 = None

        k_first634 = None

        k_nulls635 = None

        k_last636 = None



        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 102):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:638:2: ( sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:638:4: sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )?
                pass 
                root_0 = self._adaptor.nil()

                self._state.following.append(self.FOLLOW_sql_expression_in_order_by_clause_part_first4332)
                sql_expression630 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression630.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:638:19: ( k_asc )?
                alt162 = 2
                LA162_0 = self.input.LA(1)

                if (LA162_0 == 101) :
                    alt162 = 1
                if alt162 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_asc
                    pass 
                    self._state.following.append(self.FOLLOW_k_asc_in_order_by_clause_part_first4334)
                    k_asc631 = self.k_asc()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_asc631.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:638:27: ( k_desc )?
                alt163 = 2
                LA163_0 = self.input.LA(1)

                if (LA163_0 == 119) :
                    alt163 = 1
                if alt163 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_desc
                    pass 
                    self._state.following.append(self.FOLLOW_k_desc_in_order_by_clause_part_first4338)
                    k_desc632 = self.k_desc()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_desc632.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:638:36: ( k_nulls k_first )?
                alt164 = 2
                LA164_0 = self.input.LA(1)

                if (LA164_0 == 449) :
                    LA164_1 = self.input.LA(2)

                    if (LA164_1 == 512) :
                        alt164 = 1
                if alt164 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:638:37: k_nulls k_first
                    pass 
                    self._state.following.append(self.FOLLOW_k_nulls_in_order_by_clause_part_first4343)
                    k_nulls633 = self.k_nulls()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nulls633.tree)
                    self._state.following.append(self.FOLLOW_k_first_in_order_by_clause_part_first4345)
                    k_first634 = self.k_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_first634.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:638:55: ( k_nulls k_last )?
                alt165 = 2
                LA165_0 = self.input.LA(1)

                if (LA165_0 == 449) :
                    alt165 = 1
                if alt165 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:638:56: k_nulls k_last
                    pass 
                    self._state.following.append(self.FOLLOW_k_nulls_in_order_by_clause_part_first4350)
                    k_nulls635 = self.k_nulls()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nulls635.tree)
                    self._state.following.append(self.FOLLOW_k_last_in_order_by_clause_part_first4352)
                    k_last636 = self.k_last()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_last636.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 102, order_by_clause_part_first_StartIndex, success)

            pass
        return retval

    # $ANTLR end "order_by_clause_part_first"

    class order_by_clause_part_next_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.order_by_clause_part_next_return, self).__init__()

            self.tree = None




    # $ANTLR start "order_by_clause_part_next"
    # /home/szr/subquery/SQL2XML/YSmart.g:640:1: order_by_clause_part_next : COMMA sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )? ;
    def order_by_clause_part_next(self, ):

        retval = self.order_by_clause_part_next_return()
        retval.start = self.input.LT(1)
        order_by_clause_part_next_StartIndex = self.input.index()
        root_0 = None

        COMMA637 = None
        sql_expression638 = None

        k_asc639 = None

        k_desc640 = None

        k_nulls641 = None

        k_first642 = None

        k_nulls643 = None

        k_last644 = None


        COMMA637_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 103):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:641:2: ( COMMA sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )? )
                # /home/szr/subquery/SQL2XML/YSmart.g:641:4: COMMA sql_expression ( k_asc )? ( k_desc )? ( k_nulls k_first )? ( k_nulls k_last )?
                pass 
                root_0 = self._adaptor.nil()

                COMMA637=self.match(self.input, COMMA, self.FOLLOW_COMMA_in_order_by_clause_part_next4372)
                if self._state.backtracking == 0:

                    COMMA637_tree = self._adaptor.createWithPayload(COMMA637)
                    self._adaptor.addChild(root_0, COMMA637_tree)

                self._state.following.append(self.FOLLOW_sql_expression_in_order_by_clause_part_next4374)
                sql_expression638 = self.sql_expression()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    self._adaptor.addChild(root_0, sql_expression638.tree)
                # /home/szr/subquery/SQL2XML/YSmart.g:641:25: ( k_asc )?
                alt166 = 2
                LA166_0 = self.input.LA(1)

                if (LA166_0 == 101) :
                    alt166 = 1
                if alt166 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_asc
                    pass 
                    self._state.following.append(self.FOLLOW_k_asc_in_order_by_clause_part_next4376)
                    k_asc639 = self.k_asc()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_asc639.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:641:33: ( k_desc )?
                alt167 = 2
                LA167_0 = self.input.LA(1)

                if (LA167_0 == 119) :
                    alt167 = 1
                if alt167 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:0:0: k_desc
                    pass 
                    self._state.following.append(self.FOLLOW_k_desc_in_order_by_clause_part_next4380)
                    k_desc640 = self.k_desc()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_desc640.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:641:42: ( k_nulls k_first )?
                alt168 = 2
                LA168_0 = self.input.LA(1)

                if (LA168_0 == 449) :
                    LA168_1 = self.input.LA(2)

                    if (LA168_1 == 512) :
                        alt168 = 1
                if alt168 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:641:43: k_nulls k_first
                    pass 
                    self._state.following.append(self.FOLLOW_k_nulls_in_order_by_clause_part_next4385)
                    k_nulls641 = self.k_nulls()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nulls641.tree)
                    self._state.following.append(self.FOLLOW_k_first_in_order_by_clause_part_next4387)
                    k_first642 = self.k_first()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_first642.tree)



                # /home/szr/subquery/SQL2XML/YSmart.g:641:61: ( k_nulls k_last )?
                alt169 = 2
                LA169_0 = self.input.LA(1)

                if (LA169_0 == 449) :
                    alt169 = 1
                if alt169 == 1:
                    # /home/szr/subquery/SQL2XML/YSmart.g:641:62: k_nulls k_last
                    pass 
                    self._state.following.append(self.FOLLOW_k_nulls_in_order_by_clause_part_next4392)
                    k_nulls643 = self.k_nulls()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_nulls643.tree)
                    self._state.following.append(self.FOLLOW_k_last_in_order_by_clause_part_next4394)
                    k_last644 = self.k_last()

                    self._state.following.pop()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, k_last644.tree)






                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 103, order_by_clause_part_next_StartIndex, success)

            pass
        return retval

    # $ANTLR end "order_by_clause_part_next"

    class limit_clause_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.limit_clause_return, self).__init__()

            self.tree = None




    # $ANTLR start "limit_clause"
    # /home/szr/subquery/SQL2XML/YSmart.g:647:1: limit_clause : k_limit NUMBER -> ^( 't_limit' k_limit NUMBER ) ;
    def limit_clause(self, ):

        retval = self.limit_clause_return()
        retval.start = self.input.LT(1)
        limit_clause_StartIndex = self.input.index()
        root_0 = None

        NUMBER646 = None
        k_limit645 = None


        NUMBER646_tree = None
        stream_NUMBER = RewriteRuleTokenStream(self._adaptor, "token NUMBER")
        stream_k_limit = RewriteRuleSubtreeStream(self._adaptor, "rule k_limit")
        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 104):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:648:2: ( k_limit NUMBER -> ^( 't_limit' k_limit NUMBER ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:648:4: k_limit NUMBER
                pass 
                self._state.following.append(self.FOLLOW_k_limit_in_limit_clause4417)
                k_limit645 = self.k_limit()

                self._state.following.pop()
                if self._state.backtracking == 0:
                    stream_k_limit.add(k_limit645.tree)
                NUMBER646=self.match(self.input, NUMBER, self.FOLLOW_NUMBER_in_limit_clause4419) 
                if self._state.backtracking == 0:
                    stream_NUMBER.add(NUMBER646)

                # AST Rewrite
                # elements: NUMBER, T_LIMIT_CLAUSE, k_limit
                # token labels: 
                # rule labels: retval
                # token list labels: 
                # rule list labels: 
                # wildcard labels: 
                if self._state.backtracking == 0:

                    retval.tree = root_0

                    if retval is not None:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "rule retval", retval.tree)
                    else:
                        stream_retval = RewriteRuleSubtreeStream(self._adaptor, "token retval", None)


                    root_0 = self._adaptor.nil()
                    # 649:2: -> ^( 't_limit' k_limit NUMBER )
                    # /home/szr/subquery/SQL2XML/YSmart.g:649:5: ^( 't_limit' k_limit NUMBER )
                    root_1 = self._adaptor.nil()
                    root_1 = self._adaptor.becomeRoot(self._adaptor.createFromType(T_LIMIT_CLAUSE, "T_LIMIT_CLAUSE"), root_1)

                    self._adaptor.addChild(root_1, stream_k_limit.nextTree())
                    self._adaptor.addChild(root_1, stream_NUMBER.nextNode())

                    self._adaptor.addChild(root_0, root_1)



                    retval.tree = root_0



                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 104, limit_clause_StartIndex, success)

            pass
        return retval

    # $ANTLR end "limit_clause"

    class k_access_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_access_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_access"
    # /home/szr/subquery/SQL2XML/YSmart.g:658:1: k_access : r= 'ACCESS' ;
    def k_access(self, ):

        retval = self.k_access_return()
        retval.start = self.input.LT(1)
        k_access_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 105):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:658:10: (r= 'ACCESS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:658:12: r= 'ACCESS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 93, self.FOLLOW_93_in_k_access4446)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 105, k_access_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_access"

    class k_add_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_add_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_add"
    # /home/szr/subquery/SQL2XML/YSmart.g:659:1: k_add : r= 'ADD' ;
    def k_add(self, ):

        retval = self.k_add_return()
        retval.start = self.input.LT(1)
        k_add_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 106):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:659:7: (r= 'ADD' )
                # /home/szr/subquery/SQL2XML/YSmart.g:659:9: r= 'ADD'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 94, self.FOLLOW_94_in_k_add4459)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 106, k_add_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_add"

    class k_all_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_all_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_all"
    # /home/szr/subquery/SQL2XML/YSmart.g:660:1: k_all : r= 'ALL' ;
    def k_all(self, ):

        retval = self.k_all_return()
        retval.start = self.input.LT(1)
        k_all_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 107):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:660:7: (r= 'ALL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:660:9: r= 'ALL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 95, self.FOLLOW_95_in_k_all4472)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 107, k_all_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_all"

    class k_alter_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_alter_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_alter"
    # /home/szr/subquery/SQL2XML/YSmart.g:661:1: k_alter : r= 'ALTER' ;
    def k_alter(self, ):

        retval = self.k_alter_return()
        retval.start = self.input.LT(1)
        k_alter_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 108):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:661:9: (r= 'ALTER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:661:11: r= 'ALTER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 96, self.FOLLOW_96_in_k_alter4485)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 108, k_alter_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_alter"

    class k_and_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_and_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_and"
    # /home/szr/subquery/SQL2XML/YSmart.g:662:1: k_and : r= 'AND' ;
    def k_and(self, ):

        retval = self.k_and_return()
        retval.start = self.input.LT(1)
        k_and_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 109):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:662:7: (r= 'AND' )
                # /home/szr/subquery/SQL2XML/YSmart.g:662:9: r= 'AND'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 97, self.FOLLOW_97_in_k_and4498)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 109, k_and_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_and"

    class k_any_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_any_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_any"
    # /home/szr/subquery/SQL2XML/YSmart.g:663:1: k_any : r= 'ANY' ;
    def k_any(self, ):

        retval = self.k_any_return()
        retval.start = self.input.LT(1)
        k_any_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 110):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:663:7: (r= 'ANY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:663:9: r= 'ANY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 98, self.FOLLOW_98_in_k_any4511)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 110, k_any_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_any"

    class k_arraylen_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_arraylen_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_arraylen"
    # /home/szr/subquery/SQL2XML/YSmart.g:664:1: k_arraylen : r= 'ARRAYLEN' ;
    def k_arraylen(self, ):

        retval = self.k_arraylen_return()
        retval.start = self.input.LT(1)
        k_arraylen_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 111):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:664:12: (r= 'ARRAYLEN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:664:14: r= 'ARRAYLEN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 99, self.FOLLOW_99_in_k_arraylen4524)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 111, k_arraylen_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_arraylen"

    class k_as_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_as_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_as"
    # /home/szr/subquery/SQL2XML/YSmart.g:665:1: k_as : r= 'AS' ;
    def k_as(self, ):

        retval = self.k_as_return()
        retval.start = self.input.LT(1)
        k_as_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 112):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:665:6: (r= 'AS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:665:8: r= 'AS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 100, self.FOLLOW_100_in_k_as4537)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 112, k_as_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_as"

    class k_asc_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_asc_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_asc"
    # /home/szr/subquery/SQL2XML/YSmart.g:666:1: k_asc : r= 'ASC' ;
    def k_asc(self, ):

        retval = self.k_asc_return()
        retval.start = self.input.LT(1)
        k_asc_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 113):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:666:7: (r= 'ASC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:666:9: r= 'ASC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 101, self.FOLLOW_101_in_k_asc4550)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 113, k_asc_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_asc"

    class k_audit_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_audit_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_audit"
    # /home/szr/subquery/SQL2XML/YSmart.g:667:1: k_audit : r= 'AUDIT' ;
    def k_audit(self, ):

        retval = self.k_audit_return()
        retval.start = self.input.LT(1)
        k_audit_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 114):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:667:9: (r= 'AUDIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:667:11: r= 'AUDIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 102, self.FOLLOW_102_in_k_audit4563)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 114, k_audit_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_audit"

    class k_between_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_between_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_between"
    # /home/szr/subquery/SQL2XML/YSmart.g:668:1: k_between : r= 'BETWEEN' ;
    def k_between(self, ):

        retval = self.k_between_return()
        retval.start = self.input.LT(1)
        k_between_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 115):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:668:11: (r= 'BETWEEN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:668:13: r= 'BETWEEN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 103, self.FOLLOW_103_in_k_between4576)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 115, k_between_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_between"

    class k_by_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_by_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_by"
    # /home/szr/subquery/SQL2XML/YSmart.g:669:1: k_by : r= 'BY' ;
    def k_by(self, ):

        retval = self.k_by_return()
        retval.start = self.input.LT(1)
        k_by_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 116):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:669:6: (r= 'BY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:669:8: r= 'BY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 104, self.FOLLOW_104_in_k_by4589)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 116, k_by_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_by"

    class k_case_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_case_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_case"
    # /home/szr/subquery/SQL2XML/YSmart.g:670:1: k_case : r= 'CASE' ;
    def k_case(self, ):

        retval = self.k_case_return()
        retval.start = self.input.LT(1)
        k_case_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 117):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:670:8: (r= 'CASE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:670:10: r= 'CASE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 105, self.FOLLOW_105_in_k_case4602)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 117, k_case_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_case"

    class k_char_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_char_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_char"
    # /home/szr/subquery/SQL2XML/YSmart.g:671:1: k_char : r= 'CHAR' ;
    def k_char(self, ):

        retval = self.k_char_return()
        retval.start = self.input.LT(1)
        k_char_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 118):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:671:8: (r= 'CHAR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:671:10: r= 'CHAR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 106, self.FOLLOW_106_in_k_char4616)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 118, k_char_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_char"

    class k_check_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_check_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_check"
    # /home/szr/subquery/SQL2XML/YSmart.g:672:1: k_check : r= 'CHECK' ;
    def k_check(self, ):

        retval = self.k_check_return()
        retval.start = self.input.LT(1)
        k_check_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 119):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:672:9: (r= 'CHECK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:672:11: r= 'CHECK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 107, self.FOLLOW_107_in_k_check4629)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 119, k_check_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_check"

    class k_cluster_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cluster_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cluster"
    # /home/szr/subquery/SQL2XML/YSmart.g:673:1: k_cluster : r= 'CLUSTER' ;
    def k_cluster(self, ):

        retval = self.k_cluster_return()
        retval.start = self.input.LT(1)
        k_cluster_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 120):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:673:11: (r= 'CLUSTER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:673:13: r= 'CLUSTER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 108, self.FOLLOW_108_in_k_cluster4642)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 120, k_cluster_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cluster"

    class k_column_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_column_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_column"
    # /home/szr/subquery/SQL2XML/YSmart.g:674:1: k_column : r= 'COLUMN' ;
    def k_column(self, ):

        retval = self.k_column_return()
        retval.start = self.input.LT(1)
        k_column_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 121):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:674:10: (r= 'COLUMN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:674:12: r= 'COLUMN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 109, self.FOLLOW_109_in_k_column4655)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 121, k_column_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_column"

    class k_comment_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_comment_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_comment"
    # /home/szr/subquery/SQL2XML/YSmart.g:675:1: k_comment : r= 'COMMENT' ;
    def k_comment(self, ):

        retval = self.k_comment_return()
        retval.start = self.input.LT(1)
        k_comment_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 122):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:675:11: (r= 'COMMENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:675:13: r= 'COMMENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 110, self.FOLLOW_110_in_k_comment4668)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 122, k_comment_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_comment"

    class k_compress_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_compress_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_compress"
    # /home/szr/subquery/SQL2XML/YSmart.g:676:1: k_compress : r= 'COMPRESS' ;
    def k_compress(self, ):

        retval = self.k_compress_return()
        retval.start = self.input.LT(1)
        k_compress_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 123):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:676:12: (r= 'COMPRESS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:676:14: r= 'COMPRESS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 111, self.FOLLOW_111_in_k_compress4681)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 123, k_compress_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_compress"

    class k_connect_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_connect_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_connect"
    # /home/szr/subquery/SQL2XML/YSmart.g:677:1: k_connect : r= 'CONNECT' ;
    def k_connect(self, ):

        retval = self.k_connect_return()
        retval.start = self.input.LT(1)
        k_connect_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 124):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:677:11: (r= 'CONNECT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:677:13: r= 'CONNECT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 112, self.FOLLOW_112_in_k_connect4694)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 124, k_connect_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_connect"

    class k_create_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_create_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_create"
    # /home/szr/subquery/SQL2XML/YSmart.g:678:1: k_create : r= 'CREATE' ;
    def k_create(self, ):

        retval = self.k_create_return()
        retval.start = self.input.LT(1)
        k_create_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 125):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:678:10: (r= 'CREATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:678:12: r= 'CREATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 113, self.FOLLOW_113_in_k_create4707)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 125, k_create_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_create"

    class k_current_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_current_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_current"
    # /home/szr/subquery/SQL2XML/YSmart.g:679:1: k_current : r= 'CURRENT' ;
    def k_current(self, ):

        retval = self.k_current_return()
        retval.start = self.input.LT(1)
        k_current_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 126):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:679:11: (r= 'CURRENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:679:13: r= 'CURRENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 114, self.FOLLOW_114_in_k_current4720)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 126, k_current_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_current"

    class k_date_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_date_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_date"
    # /home/szr/subquery/SQL2XML/YSmart.g:680:1: k_date : r= 'DATE' ;
    def k_date(self, ):

        retval = self.k_date_return()
        retval.start = self.input.LT(1)
        k_date_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 127):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:680:8: (r= 'DATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:680:10: r= 'DATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 115, self.FOLLOW_115_in_k_date4733)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 127, k_date_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_date"

    class k_decimal_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_decimal_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_decimal"
    # /home/szr/subquery/SQL2XML/YSmart.g:681:1: k_decimal : r= 'DECIMAL' ;
    def k_decimal(self, ):

        retval = self.k_decimal_return()
        retval.start = self.input.LT(1)
        k_decimal_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 128):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:681:11: (r= 'DECIMAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:681:13: r= 'DECIMAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 116, self.FOLLOW_116_in_k_decimal4746)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 128, k_decimal_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_decimal"

    class k_default_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_default_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_default"
    # /home/szr/subquery/SQL2XML/YSmart.g:682:1: k_default : r= 'DEFAULT' ;
    def k_default(self, ):

        retval = self.k_default_return()
        retval.start = self.input.LT(1)
        k_default_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 129):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:682:11: (r= 'DEFAULT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:682:13: r= 'DEFAULT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 117, self.FOLLOW_117_in_k_default4759)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 129, k_default_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_default"

    class k_delete_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_delete_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_delete"
    # /home/szr/subquery/SQL2XML/YSmart.g:683:1: k_delete : r= 'DELETE' ;
    def k_delete(self, ):

        retval = self.k_delete_return()
        retval.start = self.input.LT(1)
        k_delete_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 130):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:683:10: (r= 'DELETE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:683:12: r= 'DELETE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 118, self.FOLLOW_118_in_k_delete4772)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 130, k_delete_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_delete"

    class k_desc_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_desc_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_desc"
    # /home/szr/subquery/SQL2XML/YSmart.g:684:1: k_desc : r= 'DESC' ;
    def k_desc(self, ):

        retval = self.k_desc_return()
        retval.start = self.input.LT(1)
        k_desc_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 131):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:684:8: (r= 'DESC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:684:10: r= 'DESC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 119, self.FOLLOW_119_in_k_desc4785)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 131, k_desc_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_desc"

    class k_distinct_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_distinct_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_distinct"
    # /home/szr/subquery/SQL2XML/YSmart.g:685:1: k_distinct : r= 'DISTINCT' ;
    def k_distinct(self, ):

        retval = self.k_distinct_return()
        retval.start = self.input.LT(1)
        k_distinct_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 132):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:685:12: (r= 'DISTINCT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:685:14: r= 'DISTINCT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 120, self.FOLLOW_120_in_k_distinct4798)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 132, k_distinct_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_distinct"

    class k_drop_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_drop_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_drop"
    # /home/szr/subquery/SQL2XML/YSmart.g:686:1: k_drop : r= 'DROP' ;
    def k_drop(self, ):

        retval = self.k_drop_return()
        retval.start = self.input.LT(1)
        k_drop_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 133):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:686:8: (r= 'DROP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:686:10: r= 'DROP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 121, self.FOLLOW_121_in_k_drop4811)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 133, k_drop_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_drop"

    class k_else_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_else_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_else"
    # /home/szr/subquery/SQL2XML/YSmart.g:687:1: k_else : r= 'ELSE' ;
    def k_else(self, ):

        retval = self.k_else_return()
        retval.start = self.input.LT(1)
        k_else_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 134):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:687:8: (r= 'ELSE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:687:10: r= 'ELSE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 122, self.FOLLOW_122_in_k_else4824)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 134, k_else_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_else"

    class k_exclusive_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_exclusive_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_exclusive"
    # /home/szr/subquery/SQL2XML/YSmart.g:688:1: k_exclusive : r= 'EXCLUSIVE' ;
    def k_exclusive(self, ):

        retval = self.k_exclusive_return()
        retval.start = self.input.LT(1)
        k_exclusive_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 135):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:688:13: (r= 'EXCLUSIVE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:688:15: r= 'EXCLUSIVE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 123, self.FOLLOW_123_in_k_exclusive4837)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 135, k_exclusive_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_exclusive"

    class k_exists_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_exists_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_exists"
    # /home/szr/subquery/SQL2XML/YSmart.g:689:1: k_exists : r= 'EXISTS' ;
    def k_exists(self, ):

        retval = self.k_exists_return()
        retval.start = self.input.LT(1)
        k_exists_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 136):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:689:10: (r= 'EXISTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:689:12: r= 'EXISTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 124, self.FOLLOW_124_in_k_exists4850)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 136, k_exists_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_exists"

    class k_false_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_false_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_false"
    # /home/szr/subquery/SQL2XML/YSmart.g:690:1: k_false : r= 'FALSE' ;
    def k_false(self, ):

        retval = self.k_false_return()
        retval.start = self.input.LT(1)
        k_false_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 137):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:690:9: (r= 'FALSE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:690:11: r= 'FALSE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 125, self.FOLLOW_125_in_k_false4863)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 137, k_false_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_false"

    class k_file_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_file_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_file"
    # /home/szr/subquery/SQL2XML/YSmart.g:691:1: k_file : r= 'FILE' ;
    def k_file(self, ):

        retval = self.k_file_return()
        retval.start = self.input.LT(1)
        k_file_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 138):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:691:8: (r= 'FILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:691:10: r= 'FILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 126, self.FOLLOW_126_in_k_file4877)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 138, k_file_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_file"

    class k_float_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_float_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_float"
    # /home/szr/subquery/SQL2XML/YSmart.g:692:1: k_float : r= 'FLOAT' ;
    def k_float(self, ):

        retval = self.k_float_return()
        retval.start = self.input.LT(1)
        k_float_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 139):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:692:9: (r= 'FLOAT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:692:11: r= 'FLOAT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 127, self.FOLLOW_127_in_k_float4890)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 139, k_float_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_float"

    class k_for_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_for_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_for"
    # /home/szr/subquery/SQL2XML/YSmart.g:693:1: k_for : r= 'FOR' ;
    def k_for(self, ):

        retval = self.k_for_return()
        retval.start = self.input.LT(1)
        k_for_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 140):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:693:7: (r= 'FOR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:693:9: r= 'FOR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 128, self.FOLLOW_128_in_k_for4903)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 140, k_for_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_for"

    class k_from_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_from_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_from"
    # /home/szr/subquery/SQL2XML/YSmart.g:694:1: k_from : r= 'FROM' ;
    def k_from(self, ):

        retval = self.k_from_return()
        retval.start = self.input.LT(1)
        k_from_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 141):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:694:8: (r= 'FROM' )
                # /home/szr/subquery/SQL2XML/YSmart.g:694:10: r= 'FROM'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 129, self.FOLLOW_129_in_k_from4916)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 141, k_from_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_from"

    class k_grant_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_grant_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_grant"
    # /home/szr/subquery/SQL2XML/YSmart.g:695:1: k_grant : r= 'GRANT' ;
    def k_grant(self, ):

        retval = self.k_grant_return()
        retval.start = self.input.LT(1)
        k_grant_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 142):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:695:9: (r= 'GRANT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:695:11: r= 'GRANT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 130, self.FOLLOW_130_in_k_grant4929)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 142, k_grant_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_grant"

    class k_group_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_group_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_group"
    # /home/szr/subquery/SQL2XML/YSmart.g:696:1: k_group : r= 'GROUP' ;
    def k_group(self, ):

        retval = self.k_group_return()
        retval.start = self.input.LT(1)
        k_group_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 143):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:696:9: (r= 'GROUP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:696:11: r= 'GROUP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 131, self.FOLLOW_131_in_k_group4942)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 143, k_group_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_group"

    class k_having_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_having_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_having"
    # /home/szr/subquery/SQL2XML/YSmart.g:697:1: k_having : r= 'HAVING' ;
    def k_having(self, ):

        retval = self.k_having_return()
        retval.start = self.input.LT(1)
        k_having_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 144):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:697:10: (r= 'HAVING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:697:12: r= 'HAVING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 132, self.FOLLOW_132_in_k_having4955)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 144, k_having_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_having"

    class k_identified_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_identified_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_identified"
    # /home/szr/subquery/SQL2XML/YSmart.g:698:1: k_identified : r= 'IDENTIFIED' ;
    def k_identified(self, ):

        retval = self.k_identified_return()
        retval.start = self.input.LT(1)
        k_identified_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 145):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:698:14: (r= 'IDENTIFIED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:698:16: r= 'IDENTIFIED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 133, self.FOLLOW_133_in_k_identified4968)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 145, k_identified_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_identified"

    class k_immediate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_immediate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_immediate"
    # /home/szr/subquery/SQL2XML/YSmart.g:699:1: k_immediate : r= 'IMMEDIATE' ;
    def k_immediate(self, ):

        retval = self.k_immediate_return()
        retval.start = self.input.LT(1)
        k_immediate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 146):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:699:13: (r= 'IMMEDIATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:699:15: r= 'IMMEDIATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 134, self.FOLLOW_134_in_k_immediate4981)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 146, k_immediate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_immediate"

    class k_in_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_in_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_in"
    # /home/szr/subquery/SQL2XML/YSmart.g:700:1: k_in : r= 'IN' ;
    def k_in(self, ):

        retval = self.k_in_return()
        retval.start = self.input.LT(1)
        k_in_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 147):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:700:6: (r= 'IN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:700:8: r= 'IN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 135, self.FOLLOW_135_in_k_in4994)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 147, k_in_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_in"

    class k_increment_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_increment_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_increment"
    # /home/szr/subquery/SQL2XML/YSmart.g:701:1: k_increment : r= 'INCREMENT' ;
    def k_increment(self, ):

        retval = self.k_increment_return()
        retval.start = self.input.LT(1)
        k_increment_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 148):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:701:13: (r= 'INCREMENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:701:15: r= 'INCREMENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 136, self.FOLLOW_136_in_k_increment5007)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 148, k_increment_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_increment"

    class k_index_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_index_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_index"
    # /home/szr/subquery/SQL2XML/YSmart.g:702:1: k_index : r= 'INDEX' ;
    def k_index(self, ):

        retval = self.k_index_return()
        retval.start = self.input.LT(1)
        k_index_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 149):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:702:9: (r= 'INDEX' )
                # /home/szr/subquery/SQL2XML/YSmart.g:702:11: r= 'INDEX'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 137, self.FOLLOW_137_in_k_index5020)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 149, k_index_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_index"

    class k_initial_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_initial_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_initial"
    # /home/szr/subquery/SQL2XML/YSmart.g:703:1: k_initial : r= 'INITIAL' ;
    def k_initial(self, ):

        retval = self.k_initial_return()
        retval.start = self.input.LT(1)
        k_initial_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 150):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:703:11: (r= 'INITIAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:703:13: r= 'INITIAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 138, self.FOLLOW_138_in_k_initial5033)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 150, k_initial_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_initial"

    class k_insert_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_insert_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_insert"
    # /home/szr/subquery/SQL2XML/YSmart.g:704:1: k_insert : r= 'INSERT' ;
    def k_insert(self, ):

        retval = self.k_insert_return()
        retval.start = self.input.LT(1)
        k_insert_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 151):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:704:10: (r= 'INSERT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:704:12: r= 'INSERT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 139, self.FOLLOW_139_in_k_insert5046)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 151, k_insert_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_insert"

    class k_integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_integer_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_integer"
    # /home/szr/subquery/SQL2XML/YSmart.g:705:1: k_integer : r= 'INTEGER' ;
    def k_integer(self, ):

        retval = self.k_integer_return()
        retval.start = self.input.LT(1)
        k_integer_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 152):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:705:11: (r= 'INTEGER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:705:13: r= 'INTEGER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 140, self.FOLLOW_140_in_k_integer5059)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 152, k_integer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_integer"

    class k_intersect_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_intersect_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_intersect"
    # /home/szr/subquery/SQL2XML/YSmart.g:706:1: k_intersect : r= 'INTERSECT' ;
    def k_intersect(self, ):

        retval = self.k_intersect_return()
        retval.start = self.input.LT(1)
        k_intersect_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 153):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:706:13: (r= 'INTERSECT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:706:15: r= 'INTERSECT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 141, self.FOLLOW_141_in_k_intersect5072)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 153, k_intersect_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_intersect"

    class k_into_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_into_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_into"
    # /home/szr/subquery/SQL2XML/YSmart.g:707:1: k_into : r= 'INTO' ;
    def k_into(self, ):

        retval = self.k_into_return()
        retval.start = self.input.LT(1)
        k_into_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 154):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:707:8: (r= 'INTO' )
                # /home/szr/subquery/SQL2XML/YSmart.g:707:10: r= 'INTO'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 142, self.FOLLOW_142_in_k_into5085)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 154, k_into_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_into"

    class k_is_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_is_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_is"
    # /home/szr/subquery/SQL2XML/YSmart.g:708:1: k_is : r= 'IS' ;
    def k_is(self, ):

        retval = self.k_is_return()
        retval.start = self.input.LT(1)
        k_is_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 155):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:708:6: (r= 'IS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:708:8: r= 'IS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 143, self.FOLLOW_143_in_k_is5098)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 155, k_is_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_is"

    class k_level_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_level_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_level"
    # /home/szr/subquery/SQL2XML/YSmart.g:709:1: k_level : r= 'LEVEL' ;
    def k_level(self, ):

        retval = self.k_level_return()
        retval.start = self.input.LT(1)
        k_level_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 156):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:709:9: (r= 'LEVEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:709:11: r= 'LEVEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 144, self.FOLLOW_144_in_k_level5111)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 156, k_level_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_level"

    class k_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_like_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_like"
    # /home/szr/subquery/SQL2XML/YSmart.g:710:1: k_like : r= 'LIKE' ;
    def k_like(self, ):

        retval = self.k_like_return()
        retval.start = self.input.LT(1)
        k_like_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 157):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:710:8: (r= 'LIKE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:710:10: r= 'LIKE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 145, self.FOLLOW_145_in_k_like5124)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 157, k_like_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_like"

    class k_like2_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_like2_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_like2"
    # /home/szr/subquery/SQL2XML/YSmart.g:711:1: k_like2 : r= 'LIKE2' ;
    def k_like2(self, ):

        retval = self.k_like2_return()
        retval.start = self.input.LT(1)
        k_like2_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 158):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:711:9: (r= 'LIKE2' )
                # /home/szr/subquery/SQL2XML/YSmart.g:711:11: r= 'LIKE2'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 146, self.FOLLOW_146_in_k_like25137)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 158, k_like2_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_like2"

    class k_like4_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_like4_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_like4"
    # /home/szr/subquery/SQL2XML/YSmart.g:712:1: k_like4 : r= 'LIKE4' ;
    def k_like4(self, ):

        retval = self.k_like4_return()
        retval.start = self.input.LT(1)
        k_like4_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 159):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:712:9: (r= 'LIKE4' )
                # /home/szr/subquery/SQL2XML/YSmart.g:712:11: r= 'LIKE4'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 147, self.FOLLOW_147_in_k_like45150)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 159, k_like4_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_like4"

    class k_likec_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_likec_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_likec"
    # /home/szr/subquery/SQL2XML/YSmart.g:713:1: k_likec : r= 'LIKEC' ;
    def k_likec(self, ):

        retval = self.k_likec_return()
        retval.start = self.input.LT(1)
        k_likec_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 160):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:713:9: (r= 'LIKEC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:713:11: r= 'LIKEC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 148, self.FOLLOW_148_in_k_likec5163)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 160, k_likec_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_likec"

    class k_lock_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_lock_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_lock"
    # /home/szr/subquery/SQL2XML/YSmart.g:714:1: k_lock : r= 'LOCK' ;
    def k_lock(self, ):

        retval = self.k_lock_return()
        retval.start = self.input.LT(1)
        k_lock_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 161):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:714:8: (r= 'LOCK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:714:10: r= 'LOCK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 149, self.FOLLOW_149_in_k_lock5176)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 161, k_lock_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_lock"

    class k_long_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_long_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_long"
    # /home/szr/subquery/SQL2XML/YSmart.g:715:1: k_long : r= 'LONG' ;
    def k_long(self, ):

        retval = self.k_long_return()
        retval.start = self.input.LT(1)
        k_long_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 162):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:715:8: (r= 'LONG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:715:10: r= 'LONG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 150, self.FOLLOW_150_in_k_long5189)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 162, k_long_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_long"

    class k_maxextents_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxextents_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxextents"
    # /home/szr/subquery/SQL2XML/YSmart.g:716:1: k_maxextents : r= 'MAXEXTENTS' ;
    def k_maxextents(self, ):

        retval = self.k_maxextents_return()
        retval.start = self.input.LT(1)
        k_maxextents_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 163):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:716:14: (r= 'MAXEXTENTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:716:16: r= 'MAXEXTENTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 151, self.FOLLOW_151_in_k_maxextents5202)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 163, k_maxextents_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxextents"

    class k_minus_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_minus_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_minus"
    # /home/szr/subquery/SQL2XML/YSmart.g:717:1: k_minus : r= 'MINUS' ;
    def k_minus(self, ):

        retval = self.k_minus_return()
        retval.start = self.input.LT(1)
        k_minus_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 164):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:717:9: (r= 'MINUS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:717:11: r= 'MINUS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 152, self.FOLLOW_152_in_k_minus5215)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 164, k_minus_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_minus"

    class k_mode_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_mode_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_mode"
    # /home/szr/subquery/SQL2XML/YSmart.g:718:1: k_mode : r= 'MODE' ;
    def k_mode(self, ):

        retval = self.k_mode_return()
        retval.start = self.input.LT(1)
        k_mode_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 165):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:718:8: (r= 'MODE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:718:10: r= 'MODE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 153, self.FOLLOW_153_in_k_mode5228)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 165, k_mode_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_mode"

    class k_modify_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_modify_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_modify"
    # /home/szr/subquery/SQL2XML/YSmart.g:719:1: k_modify : r= 'MODIFY' ;
    def k_modify(self, ):

        retval = self.k_modify_return()
        retval.start = self.input.LT(1)
        k_modify_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 166):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:719:10: (r= 'MODIFY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:719:12: r= 'MODIFY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 154, self.FOLLOW_154_in_k_modify5241)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 166, k_modify_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_modify"

    class k_noaudit_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_noaudit_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_noaudit"
    # /home/szr/subquery/SQL2XML/YSmart.g:720:1: k_noaudit : r= 'NOAUDIT' ;
    def k_noaudit(self, ):

        retval = self.k_noaudit_return()
        retval.start = self.input.LT(1)
        k_noaudit_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 167):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:720:11: (r= 'NOAUDIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:720:13: r= 'NOAUDIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 155, self.FOLLOW_155_in_k_noaudit5254)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 167, k_noaudit_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_noaudit"

    class k_nocompress_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nocompress_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nocompress"
    # /home/szr/subquery/SQL2XML/YSmart.g:721:1: k_nocompress : r= 'NOCOMPRESS' ;
    def k_nocompress(self, ):

        retval = self.k_nocompress_return()
        retval.start = self.input.LT(1)
        k_nocompress_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 168):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:721:14: (r= 'NOCOMPRESS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:721:16: r= 'NOCOMPRESS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 156, self.FOLLOW_156_in_k_nocompress5267)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 168, k_nocompress_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nocompress"

    class k_not_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_not_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_not"
    # /home/szr/subquery/SQL2XML/YSmart.g:722:1: k_not : r= 'NOT' ;
    def k_not(self, ):

        retval = self.k_not_return()
        retval.start = self.input.LT(1)
        k_not_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 169):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:722:7: (r= 'NOT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:722:9: r= 'NOT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 157, self.FOLLOW_157_in_k_not5280)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 169, k_not_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_not"

    class k_notfound_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_notfound_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_notfound"
    # /home/szr/subquery/SQL2XML/YSmart.g:723:1: k_notfound : r= 'NOTFOUND' ;
    def k_notfound(self, ):

        retval = self.k_notfound_return()
        retval.start = self.input.LT(1)
        k_notfound_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 170):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:723:12: (r= 'NOTFOUND' )
                # /home/szr/subquery/SQL2XML/YSmart.g:723:14: r= 'NOTFOUND'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 158, self.FOLLOW_158_in_k_notfound5293)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 170, k_notfound_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_notfound"

    class k_nowait_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nowait_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nowait"
    # /home/szr/subquery/SQL2XML/YSmart.g:724:1: k_nowait : r= 'NOWAIT' ;
    def k_nowait(self, ):

        retval = self.k_nowait_return()
        retval.start = self.input.LT(1)
        k_nowait_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 171):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:724:10: (r= 'NOWAIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:724:12: r= 'NOWAIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 159, self.FOLLOW_159_in_k_nowait5306)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 171, k_nowait_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nowait"

    class k_null_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_null_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_null"
    # /home/szr/subquery/SQL2XML/YSmart.g:725:1: k_null : r= 'NULL' ;
    def k_null(self, ):

        retval = self.k_null_return()
        retval.start = self.input.LT(1)
        k_null_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 172):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:725:8: (r= 'NULL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:725:10: r= 'NULL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 160, self.FOLLOW_160_in_k_null5319)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 172, k_null_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_null"

    class k_number_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_number_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_number"
    # /home/szr/subquery/SQL2XML/YSmart.g:726:1: k_number : r= 'NUMBER' ;
    def k_number(self, ):

        retval = self.k_number_return()
        retval.start = self.input.LT(1)
        k_number_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 173):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:726:10: (r= 'NUMBER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:726:12: r= 'NUMBER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 161, self.FOLLOW_161_in_k_number5332)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 173, k_number_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_number"

    class k_of_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_of_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_of"
    # /home/szr/subquery/SQL2XML/YSmart.g:727:1: k_of : r= 'OF' ;
    def k_of(self, ):

        retval = self.k_of_return()
        retval.start = self.input.LT(1)
        k_of_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 174):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:727:6: (r= 'OF' )
                # /home/szr/subquery/SQL2XML/YSmart.g:727:8: r= 'OF'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 162, self.FOLLOW_162_in_k_of5345)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 174, k_of_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_of"

    class k_offline_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_offline_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_offline"
    # /home/szr/subquery/SQL2XML/YSmart.g:728:1: k_offline : r= 'OFFLINE' ;
    def k_offline(self, ):

        retval = self.k_offline_return()
        retval.start = self.input.LT(1)
        k_offline_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 175):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:728:11: (r= 'OFFLINE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:728:13: r= 'OFFLINE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 163, self.FOLLOW_163_in_k_offline5358)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 175, k_offline_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_offline"

    class k_on_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_on_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_on"
    # /home/szr/subquery/SQL2XML/YSmart.g:729:1: k_on : r= 'ON' ;
    def k_on(self, ):

        retval = self.k_on_return()
        retval.start = self.input.LT(1)
        k_on_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 176):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:729:6: (r= 'ON' )
                # /home/szr/subquery/SQL2XML/YSmart.g:729:8: r= 'ON'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 164, self.FOLLOW_164_in_k_on5371)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 176, k_on_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_on"

    class k_online_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_online_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_online"
    # /home/szr/subquery/SQL2XML/YSmart.g:730:1: k_online : r= 'ONLINE' ;
    def k_online(self, ):

        retval = self.k_online_return()
        retval.start = self.input.LT(1)
        k_online_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 177):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:730:10: (r= 'ONLINE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:730:12: r= 'ONLINE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 165, self.FOLLOW_165_in_k_online5384)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 177, k_online_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_online"

    class k_option_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_option_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_option"
    # /home/szr/subquery/SQL2XML/YSmart.g:731:1: k_option : r= 'OPTION' ;
    def k_option(self, ):

        retval = self.k_option_return()
        retval.start = self.input.LT(1)
        k_option_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 178):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:731:10: (r= 'OPTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:731:12: r= 'OPTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 166, self.FOLLOW_166_in_k_option5397)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 178, k_option_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_option"

    class k_or_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_or_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_or"
    # /home/szr/subquery/SQL2XML/YSmart.g:732:1: k_or : r= 'OR' ;
    def k_or(self, ):

        retval = self.k_or_return()
        retval.start = self.input.LT(1)
        k_or_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 179):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:732:6: (r= 'OR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:732:8: r= 'OR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 167, self.FOLLOW_167_in_k_or5410)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 179, k_or_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_or"

    class k_order_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_order_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_order"
    # /home/szr/subquery/SQL2XML/YSmart.g:733:1: k_order : r= 'ORDER' ;
    def k_order(self, ):

        retval = self.k_order_return()
        retval.start = self.input.LT(1)
        k_order_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 180):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:733:9: (r= 'ORDER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:733:11: r= 'ORDER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 168, self.FOLLOW_168_in_k_order5423)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 180, k_order_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_order"

    class k_pctfree_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pctfree_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pctfree"
    # /home/szr/subquery/SQL2XML/YSmart.g:734:1: k_pctfree : r= 'PCTFREE' ;
    def k_pctfree(self, ):

        retval = self.k_pctfree_return()
        retval.start = self.input.LT(1)
        k_pctfree_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 181):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:734:11: (r= 'PCTFREE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:734:13: r= 'PCTFREE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 169, self.FOLLOW_169_in_k_pctfree5436)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 181, k_pctfree_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pctfree"

    class k_prior_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_prior_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_prior"
    # /home/szr/subquery/SQL2XML/YSmart.g:735:1: k_prior : r= 'PRIOR' ;
    def k_prior(self, ):

        retval = self.k_prior_return()
        retval.start = self.input.LT(1)
        k_prior_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 182):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:735:9: (r= 'PRIOR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:735:11: r= 'PRIOR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 170, self.FOLLOW_170_in_k_prior5449)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 182, k_prior_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_prior"

    class k_privileges_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_privileges_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_privileges"
    # /home/szr/subquery/SQL2XML/YSmart.g:736:1: k_privileges : r= 'PRIVILEGES' ;
    def k_privileges(self, ):

        retval = self.k_privileges_return()
        retval.start = self.input.LT(1)
        k_privileges_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 183):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:736:14: (r= 'PRIVILEGES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:736:16: r= 'PRIVILEGES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 171, self.FOLLOW_171_in_k_privileges5462)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 183, k_privileges_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_privileges"

    class k_public_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_public_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_public"
    # /home/szr/subquery/SQL2XML/YSmart.g:737:1: k_public : r= 'PUBLIC' ;
    def k_public(self, ):

        retval = self.k_public_return()
        retval.start = self.input.LT(1)
        k_public_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 184):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:737:10: (r= 'PUBLIC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:737:12: r= 'PUBLIC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 172, self.FOLLOW_172_in_k_public5475)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 184, k_public_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_public"

    class k_raw_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_raw_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_raw"
    # /home/szr/subquery/SQL2XML/YSmart.g:738:1: k_raw : r= 'RAW' ;
    def k_raw(self, ):

        retval = self.k_raw_return()
        retval.start = self.input.LT(1)
        k_raw_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 185):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:738:7: (r= 'RAW' )
                # /home/szr/subquery/SQL2XML/YSmart.g:738:9: r= 'RAW'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 173, self.FOLLOW_173_in_k_raw5488)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 185, k_raw_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_raw"

    class k_rename_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rename_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rename"
    # /home/szr/subquery/SQL2XML/YSmart.g:739:1: k_rename : r= 'RENAME' ;
    def k_rename(self, ):

        retval = self.k_rename_return()
        retval.start = self.input.LT(1)
        k_rename_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 186):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:739:10: (r= 'RENAME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:739:12: r= 'RENAME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 174, self.FOLLOW_174_in_k_rename5501)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 186, k_rename_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rename"

    class k_resource_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_resource_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_resource"
    # /home/szr/subquery/SQL2XML/YSmart.g:740:1: k_resource : r= 'RESOURCE' ;
    def k_resource(self, ):

        retval = self.k_resource_return()
        retval.start = self.input.LT(1)
        k_resource_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 187):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:740:12: (r= 'RESOURCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:740:14: r= 'RESOURCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 175, self.FOLLOW_175_in_k_resource5514)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 187, k_resource_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_resource"

    class k_revoke_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_revoke_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_revoke"
    # /home/szr/subquery/SQL2XML/YSmart.g:741:1: k_revoke : r= 'REVOKE' ;
    def k_revoke(self, ):

        retval = self.k_revoke_return()
        retval.start = self.input.LT(1)
        k_revoke_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 188):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:741:10: (r= 'REVOKE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:741:12: r= 'REVOKE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 176, self.FOLLOW_176_in_k_revoke5527)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 188, k_revoke_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_revoke"

    class k_row_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_row_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_row"
    # /home/szr/subquery/SQL2XML/YSmart.g:742:1: k_row : r= 'ROW' ;
    def k_row(self, ):

        retval = self.k_row_return()
        retval.start = self.input.LT(1)
        k_row_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 189):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:742:7: (r= 'ROW' )
                # /home/szr/subquery/SQL2XML/YSmart.g:742:9: r= 'ROW'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 177, self.FOLLOW_177_in_k_row5540)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 189, k_row_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_row"

    class k_rowid_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rowid_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rowid"
    # /home/szr/subquery/SQL2XML/YSmart.g:743:1: k_rowid : r= 'ROWID' ;
    def k_rowid(self, ):

        retval = self.k_rowid_return()
        retval.start = self.input.LT(1)
        k_rowid_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 190):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:743:9: (r= 'ROWID' )
                # /home/szr/subquery/SQL2XML/YSmart.g:743:11: r= 'ROWID'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 178, self.FOLLOW_178_in_k_rowid5553)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 190, k_rowid_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rowid"

    class k_rowlabel_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rowlabel_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rowlabel"
    # /home/szr/subquery/SQL2XML/YSmart.g:744:1: k_rowlabel : r= 'ROWLABEL' ;
    def k_rowlabel(self, ):

        retval = self.k_rowlabel_return()
        retval.start = self.input.LT(1)
        k_rowlabel_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 191):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:744:12: (r= 'ROWLABEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:744:14: r= 'ROWLABEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 179, self.FOLLOW_179_in_k_rowlabel5566)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 191, k_rowlabel_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rowlabel"

    class k_rownum_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rownum_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rownum"
    # /home/szr/subquery/SQL2XML/YSmart.g:745:1: k_rownum : r= 'ROWNUM' ;
    def k_rownum(self, ):

        retval = self.k_rownum_return()
        retval.start = self.input.LT(1)
        k_rownum_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 192):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:745:10: (r= 'ROWNUM' )
                # /home/szr/subquery/SQL2XML/YSmart.g:745:12: r= 'ROWNUM'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 180, self.FOLLOW_180_in_k_rownum5579)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 192, k_rownum_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rownum"

    class k_rows_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rows_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rows"
    # /home/szr/subquery/SQL2XML/YSmart.g:746:1: k_rows : r= 'ROWS' ;
    def k_rows(self, ):

        retval = self.k_rows_return()
        retval.start = self.input.LT(1)
        k_rows_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 193):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:746:8: (r= 'ROWS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:746:10: r= 'ROWS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 181, self.FOLLOW_181_in_k_rows5592)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 193, k_rows_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rows"

    class k_select_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_select_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_select"
    # /home/szr/subquery/SQL2XML/YSmart.g:747:1: k_select : r= 'SELECT' ;
    def k_select(self, ):

        retval = self.k_select_return()
        retval.start = self.input.LT(1)
        k_select_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 194):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:747:10: (r= 'SELECT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:747:12: r= 'SELECT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 182, self.FOLLOW_182_in_k_select5605)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 194, k_select_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_select"

    class k_session_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_session_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_session"
    # /home/szr/subquery/SQL2XML/YSmart.g:748:1: k_session : r= 'SESSION' ;
    def k_session(self, ):

        retval = self.k_session_return()
        retval.start = self.input.LT(1)
        k_session_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 195):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:748:11: (r= 'SESSION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:748:13: r= 'SESSION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 183, self.FOLLOW_183_in_k_session5618)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 195, k_session_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_session"

    class k_set_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_set_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_set"
    # /home/szr/subquery/SQL2XML/YSmart.g:749:1: k_set : r= 'SET' ;
    def k_set(self, ):

        retval = self.k_set_return()
        retval.start = self.input.LT(1)
        k_set_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 196):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:749:7: (r= 'SET' )
                # /home/szr/subquery/SQL2XML/YSmart.g:749:9: r= 'SET'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 184, self.FOLLOW_184_in_k_set5631)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 196, k_set_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_set"

    class k_share_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_share_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_share"
    # /home/szr/subquery/SQL2XML/YSmart.g:750:1: k_share : r= 'SHARE' ;
    def k_share(self, ):

        retval = self.k_share_return()
        retval.start = self.input.LT(1)
        k_share_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 197):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:750:9: (r= 'SHARE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:750:11: r= 'SHARE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 185, self.FOLLOW_185_in_k_share5644)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 197, k_share_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_share"

    class k_size_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_size_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_size"
    # /home/szr/subquery/SQL2XML/YSmart.g:751:1: k_size : r= 'SIZE' ;
    def k_size(self, ):

        retval = self.k_size_return()
        retval.start = self.input.LT(1)
        k_size_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 198):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:751:8: (r= 'SIZE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:751:10: r= 'SIZE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 186, self.FOLLOW_186_in_k_size5657)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 198, k_size_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_size"

    class k_smallint_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_smallint_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_smallint"
    # /home/szr/subquery/SQL2XML/YSmart.g:752:1: k_smallint : r= 'SMALLINT' ;
    def k_smallint(self, ):

        retval = self.k_smallint_return()
        retval.start = self.input.LT(1)
        k_smallint_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 199):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:752:12: (r= 'SMALLINT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:752:14: r= 'SMALLINT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 187, self.FOLLOW_187_in_k_smallint5670)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 199, k_smallint_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_smallint"

    class k_sqlbuf_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sqlbuf_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sqlbuf"
    # /home/szr/subquery/SQL2XML/YSmart.g:753:1: k_sqlbuf : r= 'SQLBUF' ;
    def k_sqlbuf(self, ):

        retval = self.k_sqlbuf_return()
        retval.start = self.input.LT(1)
        k_sqlbuf_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 200):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:753:10: (r= 'SQLBUF' )
                # /home/szr/subquery/SQL2XML/YSmart.g:753:12: r= 'SQLBUF'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 188, self.FOLLOW_188_in_k_sqlbuf5683)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 200, k_sqlbuf_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sqlbuf"

    class k_start_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_start_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_start"
    # /home/szr/subquery/SQL2XML/YSmart.g:754:1: k_start : r= 'START' ;
    def k_start(self, ):

        retval = self.k_start_return()
        retval.start = self.input.LT(1)
        k_start_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 201):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:754:9: (r= 'START' )
                # /home/szr/subquery/SQL2XML/YSmart.g:754:11: r= 'START'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 189, self.FOLLOW_189_in_k_start5696)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 201, k_start_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_start"

    class k_successful_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_successful_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_successful"
    # /home/szr/subquery/SQL2XML/YSmart.g:755:1: k_successful : r= 'SUCCESSFUL' ;
    def k_successful(self, ):

        retval = self.k_successful_return()
        retval.start = self.input.LT(1)
        k_successful_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 202):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:755:14: (r= 'SUCCESSFUL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:755:16: r= 'SUCCESSFUL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 190, self.FOLLOW_190_in_k_successful5709)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 202, k_successful_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_successful"

    class k_synonym_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_synonym_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_synonym"
    # /home/szr/subquery/SQL2XML/YSmart.g:756:1: k_synonym : r= 'SYNONYM' ;
    def k_synonym(self, ):

        retval = self.k_synonym_return()
        retval.start = self.input.LT(1)
        k_synonym_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 203):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:756:11: (r= 'SYNONYM' )
                # /home/szr/subquery/SQL2XML/YSmart.g:756:13: r= 'SYNONYM'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 191, self.FOLLOW_191_in_k_synonym5722)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 203, k_synonym_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_synonym"

    class k_sysdate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sysdate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sysdate"
    # /home/szr/subquery/SQL2XML/YSmart.g:757:1: k_sysdate : r= 'SYSDATE' ;
    def k_sysdate(self, ):

        retval = self.k_sysdate_return()
        retval.start = self.input.LT(1)
        k_sysdate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 204):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:757:11: (r= 'SYSDATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:757:13: r= 'SYSDATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 192, self.FOLLOW_192_in_k_sysdate5735)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 204, k_sysdate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sysdate"

    class k_table_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_table_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_table"
    # /home/szr/subquery/SQL2XML/YSmart.g:758:1: k_table : r= 'TABLE' ;
    def k_table(self, ):

        retval = self.k_table_return()
        retval.start = self.input.LT(1)
        k_table_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 205):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:758:9: (r= 'TABLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:758:11: r= 'TABLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 193, self.FOLLOW_193_in_k_table5748)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 205, k_table_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_table"

    class k_then_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_then_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_then"
    # /home/szr/subquery/SQL2XML/YSmart.g:759:1: k_then : r= 'THEN' ;
    def k_then(self, ):

        retval = self.k_then_return()
        retval.start = self.input.LT(1)
        k_then_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 206):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:759:8: (r= 'THEN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:759:10: r= 'THEN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 194, self.FOLLOW_194_in_k_then5761)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 206, k_then_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_then"

    class k_to_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_to_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_to"
    # /home/szr/subquery/SQL2XML/YSmart.g:760:1: k_to : r= 'TO' ;
    def k_to(self, ):

        retval = self.k_to_return()
        retval.start = self.input.LT(1)
        k_to_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 207):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:760:6: (r= 'TO' )
                # /home/szr/subquery/SQL2XML/YSmart.g:760:8: r= 'TO'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 195, self.FOLLOW_195_in_k_to5774)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 207, k_to_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_to"

    class k_trigger_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_trigger_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_trigger"
    # /home/szr/subquery/SQL2XML/YSmart.g:761:1: k_trigger : r= 'TRIGGER' ;
    def k_trigger(self, ):

        retval = self.k_trigger_return()
        retval.start = self.input.LT(1)
        k_trigger_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 208):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:761:12: (r= 'TRIGGER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:761:14: r= 'TRIGGER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 196, self.FOLLOW_196_in_k_trigger5788)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 208, k_trigger_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_trigger"

    class k_true_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_true_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_true"
    # /home/szr/subquery/SQL2XML/YSmart.g:762:1: k_true : r= 'TRUE' ;
    def k_true(self, ):

        retval = self.k_true_return()
        retval.start = self.input.LT(1)
        k_true_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 209):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:762:9: (r= 'TRUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:762:11: r= 'TRUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 197, self.FOLLOW_197_in_k_true5802)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 209, k_true_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_true"

    class k_uid_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_uid_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_uid"
    # /home/szr/subquery/SQL2XML/YSmart.g:763:1: k_uid : r= 'UID' ;
    def k_uid(self, ):

        retval = self.k_uid_return()
        retval.start = self.input.LT(1)
        k_uid_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 210):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:763:7: (r= 'UID' )
                # /home/szr/subquery/SQL2XML/YSmart.g:763:9: r= 'UID'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 198, self.FOLLOW_198_in_k_uid5816)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 210, k_uid_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_uid"

    class k_union_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_union_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_union"
    # /home/szr/subquery/SQL2XML/YSmart.g:764:1: k_union : r= 'UNION' ;
    def k_union(self, ):

        retval = self.k_union_return()
        retval.start = self.input.LT(1)
        k_union_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 211):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:764:9: (r= 'UNION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:764:11: r= 'UNION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 199, self.FOLLOW_199_in_k_union5829)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 211, k_union_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_union"

    class k_unique_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_unique_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_unique"
    # /home/szr/subquery/SQL2XML/YSmart.g:765:1: k_unique : r= 'UNIQUE' ;
    def k_unique(self, ):

        retval = self.k_unique_return()
        retval.start = self.input.LT(1)
        k_unique_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 212):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:765:10: (r= 'UNIQUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:765:12: r= 'UNIQUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 200, self.FOLLOW_200_in_k_unique5842)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 212, k_unique_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_unique"

    class k_update_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_update_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_update"
    # /home/szr/subquery/SQL2XML/YSmart.g:766:1: k_update : r= 'UPDATE' ;
    def k_update(self, ):

        retval = self.k_update_return()
        retval.start = self.input.LT(1)
        k_update_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 213):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:766:10: (r= 'UPDATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:766:12: r= 'UPDATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 201, self.FOLLOW_201_in_k_update5855)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 213, k_update_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_update"

    class k_user_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_user_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_user"
    # /home/szr/subquery/SQL2XML/YSmart.g:767:1: k_user : r= 'USER' ;
    def k_user(self, ):

        retval = self.k_user_return()
        retval.start = self.input.LT(1)
        k_user_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 214):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:767:9: (r= 'USER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:767:11: r= 'USER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 202, self.FOLLOW_202_in_k_user5869)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 214, k_user_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_user"

    class k_validate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_validate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_validate"
    # /home/szr/subquery/SQL2XML/YSmart.g:768:1: k_validate : r= 'VALIDATE' ;
    def k_validate(self, ):

        retval = self.k_validate_return()
        retval.start = self.input.LT(1)
        k_validate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 215):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:768:12: (r= 'VALIDATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:768:14: r= 'VALIDATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 203, self.FOLLOW_203_in_k_validate5882)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 215, k_validate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_validate"

    class k_values_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_values_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_values"
    # /home/szr/subquery/SQL2XML/YSmart.g:769:1: k_values : r= 'VALUES' ;
    def k_values(self, ):

        retval = self.k_values_return()
        retval.start = self.input.LT(1)
        k_values_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 216):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:769:10: (r= 'VALUES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:769:12: r= 'VALUES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 204, self.FOLLOW_204_in_k_values5895)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 216, k_values_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_values"

    class k_varchar_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_varchar_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_varchar"
    # /home/szr/subquery/SQL2XML/YSmart.g:770:1: k_varchar : r= 'VARCHAR' ;
    def k_varchar(self, ):

        retval = self.k_varchar_return()
        retval.start = self.input.LT(1)
        k_varchar_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 217):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:770:11: (r= 'VARCHAR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:770:13: r= 'VARCHAR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 205, self.FOLLOW_205_in_k_varchar5908)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 217, k_varchar_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_varchar"

    class k_varchar2_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_varchar2_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_varchar2"
    # /home/szr/subquery/SQL2XML/YSmart.g:771:1: k_varchar2 : r= 'VARCHAR2' ;
    def k_varchar2(self, ):

        retval = self.k_varchar2_return()
        retval.start = self.input.LT(1)
        k_varchar2_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 218):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:771:12: (r= 'VARCHAR2' )
                # /home/szr/subquery/SQL2XML/YSmart.g:771:14: r= 'VARCHAR2'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 206, self.FOLLOW_206_in_k_varchar25921)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 218, k_varchar2_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_varchar2"

    class k_view_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_view_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_view"
    # /home/szr/subquery/SQL2XML/YSmart.g:772:1: k_view : r= 'VIEW' ;
    def k_view(self, ):

        retval = self.k_view_return()
        retval.start = self.input.LT(1)
        k_view_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 219):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:772:8: (r= 'VIEW' )
                # /home/szr/subquery/SQL2XML/YSmart.g:772:10: r= 'VIEW'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 207, self.FOLLOW_207_in_k_view5934)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 219, k_view_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_view"

    class k_whenever_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_whenever_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_whenever"
    # /home/szr/subquery/SQL2XML/YSmart.g:773:1: k_whenever : r= 'WHENEVER' ;
    def k_whenever(self, ):

        retval = self.k_whenever_return()
        retval.start = self.input.LT(1)
        k_whenever_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 220):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:773:12: (r= 'WHENEVER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:773:14: r= 'WHENEVER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 208, self.FOLLOW_208_in_k_whenever5947)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 220, k_whenever_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_whenever"

    class k_where_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_where_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_where"
    # /home/szr/subquery/SQL2XML/YSmart.g:774:1: k_where : r= 'WHERE' ;
    def k_where(self, ):

        retval = self.k_where_return()
        retval.start = self.input.LT(1)
        k_where_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 221):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:774:9: (r= 'WHERE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:774:11: r= 'WHERE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 209, self.FOLLOW_209_in_k_where5960)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 221, k_where_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_where"

    class k_with_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_with_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_with"
    # /home/szr/subquery/SQL2XML/YSmart.g:775:1: k_with : r= 'WITH' ;
    def k_with(self, ):

        retval = self.k_with_return()
        retval.start = self.input.LT(1)
        k_with_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 222):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:775:8: (r= 'WITH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:775:10: r= 'WITH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 210, self.FOLLOW_210_in_k_with5973)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 222, k_with_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_with"

    class reserved_word_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.reserved_word_return, self).__init__()

            self.tree = None




    # $ANTLR start "reserved_word"
    # /home/szr/subquery/SQL2XML/YSmart.g:777:1: reserved_word options {backtrack=false; } : r= ( 'ACCESS' | 'ADD' | 'ALL' | 'ALTER' | 'AND' | 'ANY' | 'ARRAYLEN' | 'AS' | 'ASC' | 'AUDIT' | 'BETWEEN' | 'BY' | 'CASE' | 'CHAR' | 'CHECK' | 'CLUSTER' | 'COLUMN' | 'COMMENT' | 'COMPRESS' | 'CONNECT' | 'CREATE' | 'CURRENT' | 'DATE' | 'DECIMAL' | 'DEFAULT' | 'DELETE' | 'DESC' | 'DISTINCT' | 'DROP' | 'ELSE' | 'EXCLUSIVE' | 'EXISTS' | 'FILE' | 'FLOAT' | 'FOR' | 'FROM' | 'GRANT' | 'GROUP' | 'HAVING' | 'IDENTIFIED' | 'IMMEDIATE' | 'IN' | 'INCREMENT' | 'INDEX' | 'INITIAL' | 'INSERT' | 'INTEGER' | 'INTERSECT' | 'INTO' | 'IS' | 'LEVEL' | 'LIKE' | 'LOCK' | 'LONG' | 'MAXEXTENTS' | 'MINUS' | 'MODE' | 'MODIFY' | 'NOAUDIT' | 'NOCOMPRESS' | 'NOT' | 'NOTFOUND' | 'NOWAIT' | 'NULL' | 'NUMBER' | 'OF' | 'OFFLINE' | 'ON' | 'ONLINE' | 'OPTION' | 'OR' | 'ORDER' | 'PCTFREE' | 'PRIOR' | 'PRIVILEGES' | 'PUBLIC' | 'RAW' | 'RENAME' | 'RESOURCE' | 'REVOKE' | 'ROW' | 'ROWID' | 'ROWLABEL' | 'ROWNUM' | 'ROWS' | 'SELECT' | 'SESSION' | 'SET' | 'SHARE' | 'SIZE' | 'SMALLINT' | 'SQLBUF' | 'START' | 'SUCCESSFUL' | 'SYNONYM' | 'SYSDATE' | 'TABLE' | 'THEN' | 'TO' | 'TRIGGER' | 'UID' | 'UNION' | 'UNIQUE' | 'UPDATE' | 'USER' | 'VALIDATE' | 'VALUES' | 'VARCHAR' | 'VARCHAR2' | 'VIEW' | 'WHENEVER' | 'WHERE' | 'WITH' ) ;
    def reserved_word(self, ):

        retval = self.reserved_word_return()
        retval.start = self.input.LT(1)
        reserved_word_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 223):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:778:2: (r= ( 'ACCESS' | 'ADD' | 'ALL' | 'ALTER' | 'AND' | 'ANY' | 'ARRAYLEN' | 'AS' | 'ASC' | 'AUDIT' | 'BETWEEN' | 'BY' | 'CASE' | 'CHAR' | 'CHECK' | 'CLUSTER' | 'COLUMN' | 'COMMENT' | 'COMPRESS' | 'CONNECT' | 'CREATE' | 'CURRENT' | 'DATE' | 'DECIMAL' | 'DEFAULT' | 'DELETE' | 'DESC' | 'DISTINCT' | 'DROP' | 'ELSE' | 'EXCLUSIVE' | 'EXISTS' | 'FILE' | 'FLOAT' | 'FOR' | 'FROM' | 'GRANT' | 'GROUP' | 'HAVING' | 'IDENTIFIED' | 'IMMEDIATE' | 'IN' | 'INCREMENT' | 'INDEX' | 'INITIAL' | 'INSERT' | 'INTEGER' | 'INTERSECT' | 'INTO' | 'IS' | 'LEVEL' | 'LIKE' | 'LOCK' | 'LONG' | 'MAXEXTENTS' | 'MINUS' | 'MODE' | 'MODIFY' | 'NOAUDIT' | 'NOCOMPRESS' | 'NOT' | 'NOTFOUND' | 'NOWAIT' | 'NULL' | 'NUMBER' | 'OF' | 'OFFLINE' | 'ON' | 'ONLINE' | 'OPTION' | 'OR' | 'ORDER' | 'PCTFREE' | 'PRIOR' | 'PRIVILEGES' | 'PUBLIC' | 'RAW' | 'RENAME' | 'RESOURCE' | 'REVOKE' | 'ROW' | 'ROWID' | 'ROWLABEL' | 'ROWNUM' | 'ROWS' | 'SELECT' | 'SESSION' | 'SET' | 'SHARE' | 'SIZE' | 'SMALLINT' | 'SQLBUF' | 'START' | 'SUCCESSFUL' | 'SYNONYM' | 'SYSDATE' | 'TABLE' | 'THEN' | 'TO' | 'TRIGGER' | 'UID' | 'UNION' | 'UNIQUE' | 'UPDATE' | 'USER' | 'VALIDATE' | 'VALUES' | 'VARCHAR' | 'VARCHAR2' | 'VIEW' | 'WHENEVER' | 'WHERE' | 'WITH' ) )
                # /home/szr/subquery/SQL2XML/YSmart.g:778:4: r= ( 'ACCESS' | 'ADD' | 'ALL' | 'ALTER' | 'AND' | 'ANY' | 'ARRAYLEN' | 'AS' | 'ASC' | 'AUDIT' | 'BETWEEN' | 'BY' | 'CASE' | 'CHAR' | 'CHECK' | 'CLUSTER' | 'COLUMN' | 'COMMENT' | 'COMPRESS' | 'CONNECT' | 'CREATE' | 'CURRENT' | 'DATE' | 'DECIMAL' | 'DEFAULT' | 'DELETE' | 'DESC' | 'DISTINCT' | 'DROP' | 'ELSE' | 'EXCLUSIVE' | 'EXISTS' | 'FILE' | 'FLOAT' | 'FOR' | 'FROM' | 'GRANT' | 'GROUP' | 'HAVING' | 'IDENTIFIED' | 'IMMEDIATE' | 'IN' | 'INCREMENT' | 'INDEX' | 'INITIAL' | 'INSERT' | 'INTEGER' | 'INTERSECT' | 'INTO' | 'IS' | 'LEVEL' | 'LIKE' | 'LOCK' | 'LONG' | 'MAXEXTENTS' | 'MINUS' | 'MODE' | 'MODIFY' | 'NOAUDIT' | 'NOCOMPRESS' | 'NOT' | 'NOTFOUND' | 'NOWAIT' | 'NULL' | 'NUMBER' | 'OF' | 'OFFLINE' | 'ON' | 'ONLINE' | 'OPTION' | 'OR' | 'ORDER' | 'PCTFREE' | 'PRIOR' | 'PRIVILEGES' | 'PUBLIC' | 'RAW' | 'RENAME' | 'RESOURCE' | 'REVOKE' | 'ROW' | 'ROWID' | 'ROWLABEL' | 'ROWNUM' | 'ROWS' | 'SELECT' | 'SESSION' | 'SET' | 'SHARE' | 'SIZE' | 'SMALLINT' | 'SQLBUF' | 'START' | 'SUCCESSFUL' | 'SYNONYM' | 'SYSDATE' | 'TABLE' | 'THEN' | 'TO' | 'TRIGGER' | 'UID' | 'UNION' | 'UNIQUE' | 'UPDATE' | 'USER' | 'VALIDATE' | 'VALUES' | 'VARCHAR' | 'VARCHAR2' | 'VIEW' | 'WHENEVER' | 'WHERE' | 'WITH' )
                pass 
                root_0 = self._adaptor.nil()

                r = self.input.LT(1)
                if (93 <= self.input.LA(1) <= 124) or (126 <= self.input.LA(1) <= 145) or (149 <= self.input.LA(1) <= 196) or (198 <= self.input.LA(1) <= 210):
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(r))
                    self._state.errorRecovery = False

                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 223, reserved_word_StartIndex, success)

            pass
        return retval

    # $ANTLR end "reserved_word"

    class k_a_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_a_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_a"
    # /home/szr/subquery/SQL2XML/YSmart.g:810:1: k_a : r= 'A' ;
    def k_a(self, ):

        retval = self.k_a_return()
        retval.start = self.input.LT(1)
        k_a_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 224):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:810:6: (r= 'A' )
                # /home/szr/subquery/SQL2XML/YSmart.g:810:8: r= 'A'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 211, self.FOLLOW_211_in_k_a6513)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 224, k_a_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_a"

    class k_at_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_at_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_at"
    # /home/szr/subquery/SQL2XML/YSmart.g:811:1: k_at : r= 'AT' ;
    def k_at(self, ):

        retval = self.k_at_return()
        retval.start = self.input.LT(1)
        k_at_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 225):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:811:7: (r= 'AT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:811:9: r= 'AT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 212, self.FOLLOW_212_in_k_at6527)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 225, k_at_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_at"

    class k_admin_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_admin_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_admin"
    # /home/szr/subquery/SQL2XML/YSmart.g:812:1: k_admin : r= 'ADMIN' ;
    def k_admin(self, ):

        retval = self.k_admin_return()
        retval.start = self.input.LT(1)
        k_admin_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 226):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:812:9: (r= 'ADMIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:812:11: r= 'ADMIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 213, self.FOLLOW_213_in_k_admin6540)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 226, k_admin_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_admin"

    class k_after_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_after_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_after"
    # /home/szr/subquery/SQL2XML/YSmart.g:813:1: k_after : r= 'AFTER' ;
    def k_after(self, ):

        retval = self.k_after_return()
        retval.start = self.input.LT(1)
        k_after_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 227):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:813:9: (r= 'AFTER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:813:11: r= 'AFTER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 214, self.FOLLOW_214_in_k_after6553)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 227, k_after_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_after"

    class k_allocate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_allocate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_allocate"
    # /home/szr/subquery/SQL2XML/YSmart.g:814:1: k_allocate : r= 'ALLOCATE' ;
    def k_allocate(self, ):

        retval = self.k_allocate_return()
        retval.start = self.input.LT(1)
        k_allocate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 228):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:814:12: (r= 'ALLOCATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:814:14: r= 'ALLOCATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 215, self.FOLLOW_215_in_k_allocate6566)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 228, k_allocate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_allocate"

    class k_analyze_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_analyze_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_analyze"
    # /home/szr/subquery/SQL2XML/YSmart.g:815:1: k_analyze : r= 'ANALYZE' ;
    def k_analyze(self, ):

        retval = self.k_analyze_return()
        retval.start = self.input.LT(1)
        k_analyze_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 229):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:815:11: (r= 'ANALYZE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:815:13: r= 'ANALYZE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 216, self.FOLLOW_216_in_k_analyze6579)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 229, k_analyze_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_analyze"

    class k_archive_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_archive_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_archive"
    # /home/szr/subquery/SQL2XML/YSmart.g:816:1: k_archive : r= 'ARCHIVE' ;
    def k_archive(self, ):

        retval = self.k_archive_return()
        retval.start = self.input.LT(1)
        k_archive_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 230):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:816:11: (r= 'ARCHIVE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:816:13: r= 'ARCHIVE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 217, self.FOLLOW_217_in_k_archive6592)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 230, k_archive_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_archive"

    class k_archivelog_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_archivelog_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_archivelog"
    # /home/szr/subquery/SQL2XML/YSmart.g:817:1: k_archivelog : r= 'ARCHIVELOG' ;
    def k_archivelog(self, ):

        retval = self.k_archivelog_return()
        retval.start = self.input.LT(1)
        k_archivelog_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 231):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:817:14: (r= 'ARCHIVELOG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:817:16: r= 'ARCHIVELOG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 218, self.FOLLOW_218_in_k_archivelog6605)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 231, k_archivelog_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_archivelog"

    class k_authorization_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_authorization_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_authorization"
    # /home/szr/subquery/SQL2XML/YSmart.g:818:1: k_authorization : r= 'AUTHORIZATION' ;
    def k_authorization(self, ):

        retval = self.k_authorization_return()
        retval.start = self.input.LT(1)
        k_authorization_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 232):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:818:17: (r= 'AUTHORIZATION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:818:19: r= 'AUTHORIZATION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 219, self.FOLLOW_219_in_k_authorization6618)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 232, k_authorization_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_authorization"

    class k_avg_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_avg_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_avg"
    # /home/szr/subquery/SQL2XML/YSmart.g:819:1: k_avg : r= 'AVG' ;
    def k_avg(self, ):

        retval = self.k_avg_return()
        retval.start = self.input.LT(1)
        k_avg_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 233):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:819:8: (r= 'AVG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:819:10: r= 'AVG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 220, self.FOLLOW_220_in_k_avg6632)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 233, k_avg_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_avg"

    class k_backup_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_backup_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_backup"
    # /home/szr/subquery/SQL2XML/YSmart.g:820:1: k_backup : r= 'BACKUP' ;
    def k_backup(self, ):

        retval = self.k_backup_return()
        retval.start = self.input.LT(1)
        k_backup_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 234):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:820:10: (r= 'BACKUP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:820:12: r= 'BACKUP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 221, self.FOLLOW_221_in_k_backup6645)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 234, k_backup_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_backup"

    class k_become_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_become_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_become"
    # /home/szr/subquery/SQL2XML/YSmart.g:821:1: k_become : r= 'BECOME' ;
    def k_become(self, ):

        retval = self.k_become_return()
        retval.start = self.input.LT(1)
        k_become_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 235):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:821:10: (r= 'BECOME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:821:12: r= 'BECOME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 222, self.FOLLOW_222_in_k_become6658)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 235, k_become_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_become"

    class k_before_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_before_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_before"
    # /home/szr/subquery/SQL2XML/YSmart.g:822:1: k_before : r= 'BEFORE' ;
    def k_before(self, ):

        retval = self.k_before_return()
        retval.start = self.input.LT(1)
        k_before_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 236):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:822:10: (r= 'BEFORE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:822:12: r= 'BEFORE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 223, self.FOLLOW_223_in_k_before6671)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 236, k_before_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_before"

    class k_begin_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_begin_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_begin"
    # /home/szr/subquery/SQL2XML/YSmart.g:823:1: k_begin : r= 'BEGIN' ;
    def k_begin(self, ):

        retval = self.k_begin_return()
        retval.start = self.input.LT(1)
        k_begin_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 237):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:823:9: (r= 'BEGIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:823:11: r= 'BEGIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 224, self.FOLLOW_224_in_k_begin6684)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 237, k_begin_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_begin"

    class k_block_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_block_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_block"
    # /home/szr/subquery/SQL2XML/YSmart.g:824:1: k_block : r= 'BLOCK' ;
    def k_block(self, ):

        retval = self.k_block_return()
        retval.start = self.input.LT(1)
        k_block_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 238):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:824:9: (r= 'BLOCK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:824:11: r= 'BLOCK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 225, self.FOLLOW_225_in_k_block6697)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 238, k_block_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_block"

    class k_body_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_body_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_body"
    # /home/szr/subquery/SQL2XML/YSmart.g:825:1: k_body : r= 'BODY' ;
    def k_body(self, ):

        retval = self.k_body_return()
        retval.start = self.input.LT(1)
        k_body_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 239):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:825:9: (r= 'BODY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:825:11: r= 'BODY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 226, self.FOLLOW_226_in_k_body6711)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 239, k_body_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_body"

    class k_cache_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cache_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cache"
    # /home/szr/subquery/SQL2XML/YSmart.g:826:1: k_cache : r= 'CACHE' ;
    def k_cache(self, ):

        retval = self.k_cache_return()
        retval.start = self.input.LT(1)
        k_cache_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 240):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:826:9: (r= 'CACHE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:826:11: r= 'CACHE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 227, self.FOLLOW_227_in_k_cache6724)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 240, k_cache_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cache"

    class k_cancel_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cancel_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cancel"
    # /home/szr/subquery/SQL2XML/YSmart.g:827:1: k_cancel : r= 'CANCEL' ;
    def k_cancel(self, ):

        retval = self.k_cancel_return()
        retval.start = self.input.LT(1)
        k_cancel_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 241):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:827:10: (r= 'CANCEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:827:12: r= 'CANCEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 228, self.FOLLOW_228_in_k_cancel6737)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 241, k_cancel_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cancel"

    class k_cascade_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cascade_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cascade"
    # /home/szr/subquery/SQL2XML/YSmart.g:828:1: k_cascade : r= 'CASCADE' ;
    def k_cascade(self, ):

        retval = self.k_cascade_return()
        retval.start = self.input.LT(1)
        k_cascade_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 242):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:828:11: (r= 'CASCADE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:828:13: r= 'CASCADE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 229, self.FOLLOW_229_in_k_cascade6750)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 242, k_cascade_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cascade"

    class k_change_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_change_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_change"
    # /home/szr/subquery/SQL2XML/YSmart.g:829:1: k_change : r= 'CHANGE' ;
    def k_change(self, ):

        retval = self.k_change_return()
        retval.start = self.input.LT(1)
        k_change_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 243):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:829:10: (r= 'CHANGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:829:12: r= 'CHANGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 230, self.FOLLOW_230_in_k_change6763)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 243, k_change_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_change"

    class k_character_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_character_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_character"
    # /home/szr/subquery/SQL2XML/YSmart.g:830:1: k_character : r= 'CHARACTER' ;
    def k_character(self, ):

        retval = self.k_character_return()
        retval.start = self.input.LT(1)
        k_character_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 244):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:830:13: (r= 'CHARACTER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:830:15: r= 'CHARACTER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 231, self.FOLLOW_231_in_k_character6776)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 244, k_character_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_character"

    class k_checkpoint_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_checkpoint_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_checkpoint"
    # /home/szr/subquery/SQL2XML/YSmart.g:831:1: k_checkpoint : r= 'CHECKPOINT' ;
    def k_checkpoint(self, ):

        retval = self.k_checkpoint_return()
        retval.start = self.input.LT(1)
        k_checkpoint_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 245):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:831:14: (r= 'CHECKPOINT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:831:16: r= 'CHECKPOINT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 232, self.FOLLOW_232_in_k_checkpoint6789)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 245, k_checkpoint_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_checkpoint"

    class k_close_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_close_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_close"
    # /home/szr/subquery/SQL2XML/YSmart.g:832:1: k_close : r= 'CLOSE' ;
    def k_close(self, ):

        retval = self.k_close_return()
        retval.start = self.input.LT(1)
        k_close_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 246):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:832:10: (r= 'CLOSE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:832:12: r= 'CLOSE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 233, self.FOLLOW_233_in_k_close6803)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 246, k_close_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_close"

    class k_cobol_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cobol_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cobol"
    # /home/szr/subquery/SQL2XML/YSmart.g:833:1: k_cobol : r= 'COBOL' ;
    def k_cobol(self, ):

        retval = self.k_cobol_return()
        retval.start = self.input.LT(1)
        k_cobol_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 247):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:833:9: (r= 'COBOL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:833:11: r= 'COBOL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 234, self.FOLLOW_234_in_k_cobol6816)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 247, k_cobol_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cobol"

    class k_commit_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_commit_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_commit"
    # /home/szr/subquery/SQL2XML/YSmart.g:834:1: k_commit : r= 'COMMIT' ;
    def k_commit(self, ):

        retval = self.k_commit_return()
        retval.start = self.input.LT(1)
        k_commit_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 248):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:834:10: (r= 'COMMIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:834:12: r= 'COMMIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 235, self.FOLLOW_235_in_k_commit6829)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 248, k_commit_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_commit"

    class k_compile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_compile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_compile"
    # /home/szr/subquery/SQL2XML/YSmart.g:835:1: k_compile : r= 'COMPILE' ;
    def k_compile(self, ):

        retval = self.k_compile_return()
        retval.start = self.input.LT(1)
        k_compile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 249):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:835:11: (r= 'COMPILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:835:13: r= 'COMPILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 236, self.FOLLOW_236_in_k_compile6842)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 249, k_compile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_compile"

    class k_constraint_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_constraint_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_constraint"
    # /home/szr/subquery/SQL2XML/YSmart.g:836:1: k_constraint : r= 'CONSTRAINT' ;
    def k_constraint(self, ):

        retval = self.k_constraint_return()
        retval.start = self.input.LT(1)
        k_constraint_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 250):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:836:14: (r= 'CONSTRAINT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:836:16: r= 'CONSTRAINT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 237, self.FOLLOW_237_in_k_constraint6855)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 250, k_constraint_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_constraint"

    class k_constraints_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_constraints_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_constraints"
    # /home/szr/subquery/SQL2XML/YSmart.g:837:1: k_constraints : r= 'CONSTRAINTS' ;
    def k_constraints(self, ):

        retval = self.k_constraints_return()
        retval.start = self.input.LT(1)
        k_constraints_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 251):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:837:15: (r= 'CONSTRAINTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:837:17: r= 'CONSTRAINTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 238, self.FOLLOW_238_in_k_constraints6868)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 251, k_constraints_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_constraints"

    class k_contents_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_contents_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_contents"
    # /home/szr/subquery/SQL2XML/YSmart.g:838:1: k_contents : r= 'CONTENTS' ;
    def k_contents(self, ):

        retval = self.k_contents_return()
        retval.start = self.input.LT(1)
        k_contents_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 252):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:838:12: (r= 'CONTENTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:838:14: r= 'CONTENTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 239, self.FOLLOW_239_in_k_contents6881)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 252, k_contents_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_contents"

    class k_continue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_continue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_continue"
    # /home/szr/subquery/SQL2XML/YSmart.g:839:1: k_continue : r= 'CONTINUE' ;
    def k_continue(self, ):

        retval = self.k_continue_return()
        retval.start = self.input.LT(1)
        k_continue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 253):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:839:13: (r= 'CONTINUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:839:15: r= 'CONTINUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 240, self.FOLLOW_240_in_k_continue6895)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 253, k_continue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_continue"

    class k_controlfile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_controlfile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_controlfile"
    # /home/szr/subquery/SQL2XML/YSmart.g:840:1: k_controlfile : r= 'CONTROLFILE' ;
    def k_controlfile(self, ):

        retval = self.k_controlfile_return()
        retval.start = self.input.LT(1)
        k_controlfile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 254):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:840:15: (r= 'CONTROLFILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:840:17: r= 'CONTROLFILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 241, self.FOLLOW_241_in_k_controlfile6908)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 254, k_controlfile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_controlfile"

    class k_count_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_count_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_count"
    # /home/szr/subquery/SQL2XML/YSmart.g:841:1: k_count : r= 'COUNT' ;
    def k_count(self, ):

        retval = self.k_count_return()
        retval.start = self.input.LT(1)
        k_count_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 255):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:841:9: (r= 'COUNT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:841:11: r= 'COUNT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 242, self.FOLLOW_242_in_k_count6921)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 255, k_count_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_count"

    class k_cursor_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cursor_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cursor"
    # /home/szr/subquery/SQL2XML/YSmart.g:842:1: k_cursor : r= 'CURSOR' ;
    def k_cursor(self, ):

        retval = self.k_cursor_return()
        retval.start = self.input.LT(1)
        k_cursor_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 256):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:842:10: (r= 'CURSOR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:842:12: r= 'CURSOR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 243, self.FOLLOW_243_in_k_cursor6934)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 256, k_cursor_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cursor"

    class k_cycle_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cycle_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cycle"
    # /home/szr/subquery/SQL2XML/YSmart.g:843:1: k_cycle : r= 'CYCLE' ;
    def k_cycle(self, ):

        retval = self.k_cycle_return()
        retval.start = self.input.LT(1)
        k_cycle_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 257):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:843:10: (r= 'CYCLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:843:12: r= 'CYCLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 244, self.FOLLOW_244_in_k_cycle6948)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 257, k_cycle_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cycle"

    class k_database_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_database_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_database"
    # /home/szr/subquery/SQL2XML/YSmart.g:844:1: k_database : r= 'DATABASE' ;
    def k_database(self, ):

        retval = self.k_database_return()
        retval.start = self.input.LT(1)
        k_database_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 258):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:844:12: (r= 'DATABASE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:844:14: r= 'DATABASE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 245, self.FOLLOW_245_in_k_database6961)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 258, k_database_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_database"

    class k_datafile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_datafile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_datafile"
    # /home/szr/subquery/SQL2XML/YSmart.g:845:1: k_datafile : r= 'DATAFILE' ;
    def k_datafile(self, ):

        retval = self.k_datafile_return()
        retval.start = self.input.LT(1)
        k_datafile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 259):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:845:12: (r= 'DATAFILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:845:14: r= 'DATAFILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 246, self.FOLLOW_246_in_k_datafile6974)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 259, k_datafile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_datafile"

    class k_day_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_day_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_day"
    # /home/szr/subquery/SQL2XML/YSmart.g:846:1: k_day : r= 'DAY' ;
    def k_day(self, ):

        retval = self.k_day_return()
        retval.start = self.input.LT(1)
        k_day_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 260):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:846:7: (r= 'DAY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:846:9: r= 'DAY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 247, self.FOLLOW_247_in_k_day6987)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 260, k_day_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_day"

    class k_dba_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dba_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dba"
    # /home/szr/subquery/SQL2XML/YSmart.g:847:1: k_dba : r= 'DBA' ;
    def k_dba(self, ):

        retval = self.k_dba_return()
        retval.start = self.input.LT(1)
        k_dba_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 261):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:847:7: (r= 'DBA' )
                # /home/szr/subquery/SQL2XML/YSmart.g:847:9: r= 'DBA'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 248, self.FOLLOW_248_in_k_dba7000)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 261, k_dba_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dba"

    class k_dbtimezone_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dbtimezone_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dbtimezone"
    # /home/szr/subquery/SQL2XML/YSmart.g:848:1: k_dbtimezone : r= 'DBTIMEZONE' ;
    def k_dbtimezone(self, ):

        retval = self.k_dbtimezone_return()
        retval.start = self.input.LT(1)
        k_dbtimezone_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 262):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:848:14: (r= 'DBTIMEZONE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:848:16: r= 'DBTIMEZONE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 249, self.FOLLOW_249_in_k_dbtimezone7013)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 262, k_dbtimezone_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dbtimezone"

    class k_dec_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dec_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dec"
    # /home/szr/subquery/SQL2XML/YSmart.g:849:1: k_dec : r= 'DEC' ;
    def k_dec(self, ):

        retval = self.k_dec_return()
        retval.start = self.input.LT(1)
        k_dec_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 263):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:849:7: (r= 'DEC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:849:9: r= 'DEC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 250, self.FOLLOW_250_in_k_dec7026)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 263, k_dec_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dec"

    class k_declare_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_declare_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_declare"
    # /home/szr/subquery/SQL2XML/YSmart.g:850:1: k_declare : r= 'DECLARE' ;
    def k_declare(self, ):

        retval = self.k_declare_return()
        retval.start = self.input.LT(1)
        k_declare_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 264):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:850:11: (r= 'DECLARE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:850:13: r= 'DECLARE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 251, self.FOLLOW_251_in_k_declare7039)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 264, k_declare_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_declare"

    class k_disable_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_disable_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_disable"
    # /home/szr/subquery/SQL2XML/YSmart.g:851:1: k_disable : r= 'DISABLE' ;
    def k_disable(self, ):

        retval = self.k_disable_return()
        retval.start = self.input.LT(1)
        k_disable_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 265):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:851:11: (r= 'DISABLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:851:13: r= 'DISABLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 252, self.FOLLOW_252_in_k_disable7052)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 265, k_disable_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_disable"

    class k_dismount_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dismount_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dismount"
    # /home/szr/subquery/SQL2XML/YSmart.g:852:1: k_dismount : r= 'DISMOUNT' ;
    def k_dismount(self, ):

        retval = self.k_dismount_return()
        retval.start = self.input.LT(1)
        k_dismount_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 266):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:852:12: (r= 'DISMOUNT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:852:14: r= 'DISMOUNT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 253, self.FOLLOW_253_in_k_dismount7065)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 266, k_dismount_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dismount"

    class k_double_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_double_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_double"
    # /home/szr/subquery/SQL2XML/YSmart.g:853:1: k_double : r= 'DOUBLE' ;
    def k_double(self, ):

        retval = self.k_double_return()
        retval.start = self.input.LT(1)
        k_double_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 267):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:853:10: (r= 'DOUBLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:853:12: r= 'DOUBLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 254, self.FOLLOW_254_in_k_double7078)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 267, k_double_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_double"

    class k_dump_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dump_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dump"
    # /home/szr/subquery/SQL2XML/YSmart.g:854:1: k_dump : r= 'DUMP' ;
    def k_dump(self, ):

        retval = self.k_dump_return()
        retval.start = self.input.LT(1)
        k_dump_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 268):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:854:9: (r= 'DUMP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:854:11: r= 'DUMP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 255, self.FOLLOW_255_in_k_dump7092)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 268, k_dump_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dump"

    class k_each_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_each_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_each"
    # /home/szr/subquery/SQL2XML/YSmart.g:855:1: k_each : r= 'EACH' ;
    def k_each(self, ):

        retval = self.k_each_return()
        retval.start = self.input.LT(1)
        k_each_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 269):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:855:8: (r= 'EACH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:855:10: r= 'EACH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 256, self.FOLLOW_256_in_k_each7105)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 269, k_each_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_each"

    class k_enable_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_enable_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_enable"
    # /home/szr/subquery/SQL2XML/YSmart.g:856:1: k_enable : r= 'ENABLE' ;
    def k_enable(self, ):

        retval = self.k_enable_return()
        retval.start = self.input.LT(1)
        k_enable_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 270):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:856:10: (r= 'ENABLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:856:12: r= 'ENABLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 257, self.FOLLOW_257_in_k_enable7118)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 270, k_enable_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_enable"

    class k_end_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_end_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_end"
    # /home/szr/subquery/SQL2XML/YSmart.g:857:1: k_end : r= 'END' ;
    def k_end(self, ):

        retval = self.k_end_return()
        retval.start = self.input.LT(1)
        k_end_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 271):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:857:7: (r= 'END' )
                # /home/szr/subquery/SQL2XML/YSmart.g:857:9: r= 'END'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 258, self.FOLLOW_258_in_k_end7131)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 271, k_end_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_end"

    class k_escape_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_escape_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_escape"
    # /home/szr/subquery/SQL2XML/YSmart.g:858:1: k_escape : r= 'ESCAPE' ;
    def k_escape(self, ):

        retval = self.k_escape_return()
        retval.start = self.input.LT(1)
        k_escape_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 272):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:858:10: (r= 'ESCAPE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:858:12: r= 'ESCAPE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 259, self.FOLLOW_259_in_k_escape7144)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 272, k_escape_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_escape"

    class k_events_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_events_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_events"
    # /home/szr/subquery/SQL2XML/YSmart.g:859:1: k_events : r= 'EVENTS' ;
    def k_events(self, ):

        retval = self.k_events_return()
        retval.start = self.input.LT(1)
        k_events_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 273):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:859:10: (r= 'EVENTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:859:12: r= 'EVENTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 260, self.FOLLOW_260_in_k_events7157)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 273, k_events_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_events"

    class k_except_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_except_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_except"
    # /home/szr/subquery/SQL2XML/YSmart.g:860:1: k_except : r= 'EXCEPT' ;
    def k_except(self, ):

        retval = self.k_except_return()
        retval.start = self.input.LT(1)
        k_except_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 274):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:860:10: (r= 'EXCEPT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:860:12: r= 'EXCEPT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 261, self.FOLLOW_261_in_k_except7170)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 274, k_except_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_except"

    class k_exceptions_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_exceptions_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_exceptions"
    # /home/szr/subquery/SQL2XML/YSmart.g:861:1: k_exceptions : r= 'EXCEPTIONS' ;
    def k_exceptions(self, ):

        retval = self.k_exceptions_return()
        retval.start = self.input.LT(1)
        k_exceptions_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 275):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:861:14: (r= 'EXCEPTIONS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:861:16: r= 'EXCEPTIONS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 262, self.FOLLOW_262_in_k_exceptions7183)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 275, k_exceptions_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_exceptions"

    class k_exec_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_exec_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_exec"
    # /home/szr/subquery/SQL2XML/YSmart.g:862:1: k_exec : r= 'EXEC' ;
    def k_exec(self, ):

        retval = self.k_exec_return()
        retval.start = self.input.LT(1)
        k_exec_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 276):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:862:8: (r= 'EXEC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:862:10: r= 'EXEC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 263, self.FOLLOW_263_in_k_exec7196)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 276, k_exec_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_exec"

    class k_execute_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_execute_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_execute"
    # /home/szr/subquery/SQL2XML/YSmart.g:863:1: k_execute : r= 'EXECUTE' ;
    def k_execute(self, ):

        retval = self.k_execute_return()
        retval.start = self.input.LT(1)
        k_execute_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 277):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:863:12: (r= 'EXECUTE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:863:14: r= 'EXECUTE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 264, self.FOLLOW_264_in_k_execute7210)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 277, k_execute_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_execute"

    class k_explain_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_explain_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_explain"
    # /home/szr/subquery/SQL2XML/YSmart.g:864:1: k_explain : r= 'EXPLAIN' ;
    def k_explain(self, ):

        retval = self.k_explain_return()
        retval.start = self.input.LT(1)
        k_explain_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 278):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:864:11: (r= 'EXPLAIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:864:13: r= 'EXPLAIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 265, self.FOLLOW_265_in_k_explain7223)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 278, k_explain_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_explain"

    class k_extent_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_extent_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_extent"
    # /home/szr/subquery/SQL2XML/YSmart.g:865:1: k_extent : r= 'EXTENT' ;
    def k_extent(self, ):

        retval = self.k_extent_return()
        retval.start = self.input.LT(1)
        k_extent_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 279):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:865:10: (r= 'EXTENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:865:12: r= 'EXTENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 266, self.FOLLOW_266_in_k_extent7236)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 279, k_extent_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_extent"

    class k_externally_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_externally_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_externally"
    # /home/szr/subquery/SQL2XML/YSmart.g:866:1: k_externally : r= 'EXTERNALLY' ;
    def k_externally(self, ):

        retval = self.k_externally_return()
        retval.start = self.input.LT(1)
        k_externally_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 280):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:866:15: (r= 'EXTERNALLY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:866:17: r= 'EXTERNALLY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 267, self.FOLLOW_267_in_k_externally7250)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 280, k_externally_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_externally"

    class k_fetch_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_fetch_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_fetch"
    # /home/szr/subquery/SQL2XML/YSmart.g:867:1: k_fetch : r= 'FETCH' ;
    def k_fetch(self, ):

        retval = self.k_fetch_return()
        retval.start = self.input.LT(1)
        k_fetch_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 281):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:867:9: (r= 'FETCH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:867:11: r= 'FETCH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 268, self.FOLLOW_268_in_k_fetch7263)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 281, k_fetch_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_fetch"

    class k_flush_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_flush_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_flush"
    # /home/szr/subquery/SQL2XML/YSmart.g:868:1: k_flush : r= 'FLUSH' ;
    def k_flush(self, ):

        retval = self.k_flush_return()
        retval.start = self.input.LT(1)
        k_flush_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 282):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:868:9: (r= 'FLUSH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:868:11: r= 'FLUSH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 269, self.FOLLOW_269_in_k_flush7276)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 282, k_flush_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_flush"

    class k_force_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_force_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_force"
    # /home/szr/subquery/SQL2XML/YSmart.g:869:1: k_force : r= 'FORCE' ;
    def k_force(self, ):

        retval = self.k_force_return()
        retval.start = self.input.LT(1)
        k_force_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 283):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:869:9: (r= 'FORCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:869:11: r= 'FORCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 270, self.FOLLOW_270_in_k_force7289)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 283, k_force_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_force"

    class k_foreign_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_foreign_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_foreign"
    # /home/szr/subquery/SQL2XML/YSmart.g:870:1: k_foreign : r= 'FOREIGN' ;
    def k_foreign(self, ):

        retval = self.k_foreign_return()
        retval.start = self.input.LT(1)
        k_foreign_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 284):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:870:11: (r= 'FOREIGN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:870:13: r= 'FOREIGN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 271, self.FOLLOW_271_in_k_foreign7302)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 284, k_foreign_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_foreign"

    class k_fortran_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_fortran_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_fortran"
    # /home/szr/subquery/SQL2XML/YSmart.g:871:1: k_fortran : r= 'FORTRAN' ;
    def k_fortran(self, ):

        retval = self.k_fortran_return()
        retval.start = self.input.LT(1)
        k_fortran_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 285):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:871:11: (r= 'FORTRAN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:871:13: r= 'FORTRAN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 272, self.FOLLOW_272_in_k_fortran7315)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 285, k_fortran_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_fortran"

    class k_found_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_found_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_found"
    # /home/szr/subquery/SQL2XML/YSmart.g:872:1: k_found : r= 'FOUND' ;
    def k_found(self, ):

        retval = self.k_found_return()
        retval.start = self.input.LT(1)
        k_found_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 286):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:872:9: (r= 'FOUND' )
                # /home/szr/subquery/SQL2XML/YSmart.g:872:11: r= 'FOUND'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 273, self.FOLLOW_273_in_k_found7328)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 286, k_found_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_found"

    class k_freelist_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_freelist_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_freelist"
    # /home/szr/subquery/SQL2XML/YSmart.g:873:1: k_freelist : r= 'FREELIST' ;
    def k_freelist(self, ):

        retval = self.k_freelist_return()
        retval.start = self.input.LT(1)
        k_freelist_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 287):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:873:12: (r= 'FREELIST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:873:14: r= 'FREELIST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 274, self.FOLLOW_274_in_k_freelist7341)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 287, k_freelist_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_freelist"

    class k_freelists_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_freelists_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_freelists"
    # /home/szr/subquery/SQL2XML/YSmart.g:874:1: k_freelists : r= 'FREELISTS' ;
    def k_freelists(self, ):

        retval = self.k_freelists_return()
        retval.start = self.input.LT(1)
        k_freelists_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 288):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:874:13: (r= 'FREELISTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:874:15: r= 'FREELISTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 275, self.FOLLOW_275_in_k_freelists7354)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 288, k_freelists_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_freelists"

    class k_function_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_function_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_function"
    # /home/szr/subquery/SQL2XML/YSmart.g:875:1: k_function : r= 'FUNCTION' ;
    def k_function(self, ):

        retval = self.k_function_return()
        retval.start = self.input.LT(1)
        k_function_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 289):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:875:13: (r= 'FUNCTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:875:15: r= 'FUNCTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 276, self.FOLLOW_276_in_k_function7368)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 289, k_function_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_function"

    class k_go_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_go_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_go"
    # /home/szr/subquery/SQL2XML/YSmart.g:876:1: k_go : r= 'GO' ;
    def k_go(self, ):

        retval = self.k_go_return()
        retval.start = self.input.LT(1)
        k_go_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 290):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:876:6: (r= 'GO' )
                # /home/szr/subquery/SQL2XML/YSmart.g:876:8: r= 'GO'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 277, self.FOLLOW_277_in_k_go7381)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 290, k_go_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_go"

    class k_goto_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_goto_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_goto"
    # /home/szr/subquery/SQL2XML/YSmart.g:877:1: k_goto : r= 'GOTO' ;
    def k_goto(self, ):

        retval = self.k_goto_return()
        retval.start = self.input.LT(1)
        k_goto_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 291):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:877:8: (r= 'GOTO' )
                # /home/szr/subquery/SQL2XML/YSmart.g:877:10: r= 'GOTO'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 278, self.FOLLOW_278_in_k_goto7394)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 291, k_goto_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_goto"

    class k_groups_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_groups_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_groups"
    # /home/szr/subquery/SQL2XML/YSmart.g:878:1: k_groups : r= 'GROUPS' ;
    def k_groups(self, ):

        retval = self.k_groups_return()
        retval.start = self.input.LT(1)
        k_groups_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 292):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:878:10: (r= 'GROUPS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:878:12: r= 'GROUPS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 279, self.FOLLOW_279_in_k_groups7407)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 292, k_groups_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_groups"

    class k_including_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_including_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_including"
    # /home/szr/subquery/SQL2XML/YSmart.g:879:1: k_including : r= 'INCLUDING' ;
    def k_including(self, ):

        retval = self.k_including_return()
        retval.start = self.input.LT(1)
        k_including_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 293):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:879:13: (r= 'INCLUDING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:879:15: r= 'INCLUDING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 280, self.FOLLOW_280_in_k_including7420)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 293, k_including_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_including"

    class k_indicator_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_indicator_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_indicator"
    # /home/szr/subquery/SQL2XML/YSmart.g:880:1: k_indicator : r= 'INDICATOR' ;
    def k_indicator(self, ):

        retval = self.k_indicator_return()
        retval.start = self.input.LT(1)
        k_indicator_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 294):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:880:13: (r= 'INDICATOR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:880:15: r= 'INDICATOR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 281, self.FOLLOW_281_in_k_indicator7433)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 294, k_indicator_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_indicator"

    class k_initrans_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_initrans_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_initrans"
    # /home/szr/subquery/SQL2XML/YSmart.g:881:1: k_initrans : r= 'INITRANS' ;
    def k_initrans(self, ):

        retval = self.k_initrans_return()
        retval.start = self.input.LT(1)
        k_initrans_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 295):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:881:12: (r= 'INITRANS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:881:14: r= 'INITRANS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 282, self.FOLLOW_282_in_k_initrans7446)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 295, k_initrans_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_initrans"

    class k_instance_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_instance_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_instance"
    # /home/szr/subquery/SQL2XML/YSmart.g:882:1: k_instance : r= 'INSTANCE' ;
    def k_instance(self, ):

        retval = self.k_instance_return()
        retval.start = self.input.LT(1)
        k_instance_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 296):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:882:12: (r= 'INSTANCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:882:14: r= 'INSTANCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 283, self.FOLLOW_283_in_k_instance7459)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 296, k_instance_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_instance"

    class k_int_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_int_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_int"
    # /home/szr/subquery/SQL2XML/YSmart.g:883:1: k_int : r= 'INT' ;
    def k_int(self, ):

        retval = self.k_int_return()
        retval.start = self.input.LT(1)
        k_int_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 297):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:883:8: (r= 'INT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:883:10: r= 'INT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 284, self.FOLLOW_284_in_k_int7473)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 297, k_int_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_int"

    class k_key_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_key_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_key"
    # /home/szr/subquery/SQL2XML/YSmart.g:884:1: k_key : r= 'KEY' ;
    def k_key(self, ):

        retval = self.k_key_return()
        retval.start = self.input.LT(1)
        k_key_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 298):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:884:8: (r= 'KEY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:884:10: r= 'KEY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 285, self.FOLLOW_285_in_k_key7487)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 298, k_key_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_key"

    class k_language_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_language_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_language"
    # /home/szr/subquery/SQL2XML/YSmart.g:885:1: k_language : r= 'LANGUAGE' ;
    def k_language(self, ):

        retval = self.k_language_return()
        retval.start = self.input.LT(1)
        k_language_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 299):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:885:12: (r= 'LANGUAGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:885:14: r= 'LANGUAGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 286, self.FOLLOW_286_in_k_language7500)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 299, k_language_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_language"

    class k_layer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_layer_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_layer"
    # /home/szr/subquery/SQL2XML/YSmart.g:886:1: k_layer : r= 'LAYER' ;
    def k_layer(self, ):

        retval = self.k_layer_return()
        retval.start = self.input.LT(1)
        k_layer_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 300):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:886:9: (r= 'LAYER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:886:11: r= 'LAYER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 287, self.FOLLOW_287_in_k_layer7513)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 300, k_layer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_layer"

    class k_link_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_link_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_link"
    # /home/szr/subquery/SQL2XML/YSmart.g:887:1: k_link : r= 'LINK' ;
    def k_link(self, ):

        retval = self.k_link_return()
        retval.start = self.input.LT(1)
        k_link_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 301):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:887:8: (r= 'LINK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:887:10: r= 'LINK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 288, self.FOLLOW_288_in_k_link7526)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 301, k_link_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_link"

    class k_lists_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_lists_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_lists"
    # /home/szr/subquery/SQL2XML/YSmart.g:888:1: k_lists : r= 'LISTS' ;
    def k_lists(self, ):

        retval = self.k_lists_return()
        retval.start = self.input.LT(1)
        k_lists_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 302):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:888:9: (r= 'LISTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:888:11: r= 'LISTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 289, self.FOLLOW_289_in_k_lists7539)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 302, k_lists_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_lists"

    class k_logfile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_logfile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_logfile"
    # /home/szr/subquery/SQL2XML/YSmart.g:889:1: k_logfile : r= 'LOGFILE' ;
    def k_logfile(self, ):

        retval = self.k_logfile_return()
        retval.start = self.input.LT(1)
        k_logfile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 303):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:889:12: (r= 'LOGFILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:889:14: r= 'LOGFILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 290, self.FOLLOW_290_in_k_logfile7553)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 303, k_logfile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_logfile"

    class k_local_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_local_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_local"
    # /home/szr/subquery/SQL2XML/YSmart.g:890:1: k_local : r= 'LOCAL' ;
    def k_local(self, ):

        retval = self.k_local_return()
        retval.start = self.input.LT(1)
        k_local_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 304):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:890:10: (r= 'LOCAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:890:12: r= 'LOCAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 291, self.FOLLOW_291_in_k_local7567)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 304, k_local_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_local"

    class k_locked_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_locked_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_locked"
    # /home/szr/subquery/SQL2XML/YSmart.g:891:1: k_locked : r= 'LOCKED' ;
    def k_locked(self, ):

        retval = self.k_locked_return()
        retval.start = self.input.LT(1)
        k_locked_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 305):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:891:11: (r= 'LOCKED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:891:13: r= 'LOCKED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 292, self.FOLLOW_292_in_k_locked7581)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 305, k_locked_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_locked"

    class k_manage_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_manage_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_manage"
    # /home/szr/subquery/SQL2XML/YSmart.g:892:1: k_manage : r= 'MANAGE' ;
    def k_manage(self, ):

        retval = self.k_manage_return()
        retval.start = self.input.LT(1)
        k_manage_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 306):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:892:10: (r= 'MANAGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:892:12: r= 'MANAGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 293, self.FOLLOW_293_in_k_manage7594)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 306, k_manage_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_manage"

    class k_manual_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_manual_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_manual"
    # /home/szr/subquery/SQL2XML/YSmart.g:893:1: k_manual : r= 'MANUAL' ;
    def k_manual(self, ):

        retval = self.k_manual_return()
        retval.start = self.input.LT(1)
        k_manual_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 307):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:893:10: (r= 'MANUAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:893:12: r= 'MANUAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 294, self.FOLLOW_294_in_k_manual7607)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 307, k_manual_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_manual"

    class k_max_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_max_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_max"
    # /home/szr/subquery/SQL2XML/YSmart.g:894:1: k_max : r= 'MAX' ;
    def k_max(self, ):

        retval = self.k_max_return()
        retval.start = self.input.LT(1)
        k_max_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 308):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:894:7: (r= 'MAX' )
                # /home/szr/subquery/SQL2XML/YSmart.g:894:9: r= 'MAX'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 295, self.FOLLOW_295_in_k_max7620)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 308, k_max_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_max"

    class k_maxdatafiles_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxdatafiles_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxdatafiles"
    # /home/szr/subquery/SQL2XML/YSmart.g:895:1: k_maxdatafiles : r= 'MAXDATAFILES' ;
    def k_maxdatafiles(self, ):

        retval = self.k_maxdatafiles_return()
        retval.start = self.input.LT(1)
        k_maxdatafiles_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 309):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:895:16: (r= 'MAXDATAFILES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:895:18: r= 'MAXDATAFILES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 296, self.FOLLOW_296_in_k_maxdatafiles7633)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 309, k_maxdatafiles_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxdatafiles"

    class k_maxinstances_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxinstances_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxinstances"
    # /home/szr/subquery/SQL2XML/YSmart.g:896:1: k_maxinstances : r= 'MAXINSTANCES' ;
    def k_maxinstances(self, ):

        retval = self.k_maxinstances_return()
        retval.start = self.input.LT(1)
        k_maxinstances_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 310):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:896:16: (r= 'MAXINSTANCES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:896:18: r= 'MAXINSTANCES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 297, self.FOLLOW_297_in_k_maxinstances7646)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 310, k_maxinstances_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxinstances"

    class k_maxlogfiles_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxlogfiles_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxlogfiles"
    # /home/szr/subquery/SQL2XML/YSmart.g:897:1: k_maxlogfiles : r= 'MAXLOGFILES' ;
    def k_maxlogfiles(self, ):

        retval = self.k_maxlogfiles_return()
        retval.start = self.input.LT(1)
        k_maxlogfiles_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 311):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:897:15: (r= 'MAXLOGFILES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:897:17: r= 'MAXLOGFILES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 298, self.FOLLOW_298_in_k_maxlogfiles7659)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 311, k_maxlogfiles_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxlogfiles"

    class k_maxloghistory_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxloghistory_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxloghistory"
    # /home/szr/subquery/SQL2XML/YSmart.g:898:1: k_maxloghistory : r= 'MAXLOGHISTORY' ;
    def k_maxloghistory(self, ):

        retval = self.k_maxloghistory_return()
        retval.start = self.input.LT(1)
        k_maxloghistory_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 312):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:898:18: (r= 'MAXLOGHISTORY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:898:20: r= 'MAXLOGHISTORY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 299, self.FOLLOW_299_in_k_maxloghistory7673)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 312, k_maxloghistory_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxloghistory"

    class k_maxlogmembers_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxlogmembers_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxlogmembers"
    # /home/szr/subquery/SQL2XML/YSmart.g:899:1: k_maxlogmembers : r= 'MAXLOGMEMBERS' ;
    def k_maxlogmembers(self, ):

        retval = self.k_maxlogmembers_return()
        retval.start = self.input.LT(1)
        k_maxlogmembers_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 313):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:899:17: (r= 'MAXLOGMEMBERS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:899:19: r= 'MAXLOGMEMBERS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 300, self.FOLLOW_300_in_k_maxlogmembers7686)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 313, k_maxlogmembers_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxlogmembers"

    class k_maxtrans_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxtrans_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxtrans"
    # /home/szr/subquery/SQL2XML/YSmart.g:900:1: k_maxtrans : r= 'MAXTRANS' ;
    def k_maxtrans(self, ):

        retval = self.k_maxtrans_return()
        retval.start = self.input.LT(1)
        k_maxtrans_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 314):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:900:12: (r= 'MAXTRANS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:900:14: r= 'MAXTRANS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 301, self.FOLLOW_301_in_k_maxtrans7699)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 314, k_maxtrans_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxtrans"

    class k_maxvalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_maxvalue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_maxvalue"
    # /home/szr/subquery/SQL2XML/YSmart.g:901:1: k_maxvalue : r= 'MAXVALUE' ;
    def k_maxvalue(self, ):

        retval = self.k_maxvalue_return()
        retval.start = self.input.LT(1)
        k_maxvalue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 315):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:901:12: (r= 'MAXVALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:901:14: r= 'MAXVALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 302, self.FOLLOW_302_in_k_maxvalue7712)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 315, k_maxvalue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_maxvalue"

    class k_min_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_min_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_min"
    # /home/szr/subquery/SQL2XML/YSmart.g:902:1: k_min : r= 'MIN' ;
    def k_min(self, ):

        retval = self.k_min_return()
        retval.start = self.input.LT(1)
        k_min_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 316):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:902:7: (r= 'MIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:902:9: r= 'MIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 303, self.FOLLOW_303_in_k_min7725)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 316, k_min_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_min"

    class k_minextents_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_minextents_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_minextents"
    # /home/szr/subquery/SQL2XML/YSmart.g:903:1: k_minextents : r= 'MINEXTENTS' ;
    def k_minextents(self, ):

        retval = self.k_minextents_return()
        retval.start = self.input.LT(1)
        k_minextents_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 317):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:903:14: (r= 'MINEXTENTS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:903:16: r= 'MINEXTENTS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 304, self.FOLLOW_304_in_k_minextents7738)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 317, k_minextents_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_minextents"

    class k_minvalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_minvalue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_minvalue"
    # /home/szr/subquery/SQL2XML/YSmart.g:904:1: k_minvalue : r= 'MINVALUE' ;
    def k_minvalue(self, ):

        retval = self.k_minvalue_return()
        retval.start = self.input.LT(1)
        k_minvalue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 318):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:904:12: (r= 'MINVALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:904:14: r= 'MINVALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 305, self.FOLLOW_305_in_k_minvalue7751)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 318, k_minvalue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_minvalue"

    class k_module_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_module_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_module"
    # /home/szr/subquery/SQL2XML/YSmart.g:905:1: k_module : r= 'MODULE' ;
    def k_module(self, ):

        retval = self.k_module_return()
        retval.start = self.input.LT(1)
        k_module_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 319):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:905:10: (r= 'MODULE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:905:12: r= 'MODULE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 306, self.FOLLOW_306_in_k_module7764)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 319, k_module_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_module"

    class k_month_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_month_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_month"
    # /home/szr/subquery/SQL2XML/YSmart.g:906:1: k_month : r= 'MONTH' ;
    def k_month(self, ):

        retval = self.k_month_return()
        retval.start = self.input.LT(1)
        k_month_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 320):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:906:10: (r= 'MONTH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:906:12: r= 'MONTH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 307, self.FOLLOW_307_in_k_month7778)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 320, k_month_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_month"

    class k_mount_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_mount_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_mount"
    # /home/szr/subquery/SQL2XML/YSmart.g:907:1: k_mount : r= 'MOUNT' ;
    def k_mount(self, ):

        retval = self.k_mount_return()
        retval.start = self.input.LT(1)
        k_mount_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 321):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:907:10: (r= 'MOUNT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:907:12: r= 'MOUNT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 308, self.FOLLOW_308_in_k_mount7792)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 321, k_mount_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_mount"

    class k_new_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_new_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_new"
    # /home/szr/subquery/SQL2XML/YSmart.g:908:1: k_new : r= 'NEW' ;
    def k_new(self, ):

        retval = self.k_new_return()
        retval.start = self.input.LT(1)
        k_new_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 322):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:908:7: (r= 'NEW' )
                # /home/szr/subquery/SQL2XML/YSmart.g:908:9: r= 'NEW'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 309, self.FOLLOW_309_in_k_new7805)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 322, k_new_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_new"

    class k_next_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_next_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_next"
    # /home/szr/subquery/SQL2XML/YSmart.g:909:1: k_next : r= 'NEXT' ;
    def k_next(self, ):

        retval = self.k_next_return()
        retval.start = self.input.LT(1)
        k_next_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 323):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:909:8: (r= 'NEXT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:909:10: r= 'NEXT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 310, self.FOLLOW_310_in_k_next7818)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 323, k_next_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_next"

    class k_noarchivelog_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_noarchivelog_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_noarchivelog"
    # /home/szr/subquery/SQL2XML/YSmart.g:910:1: k_noarchivelog : r= 'NOARCHIVELOG' ;
    def k_noarchivelog(self, ):

        retval = self.k_noarchivelog_return()
        retval.start = self.input.LT(1)
        k_noarchivelog_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 324):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:910:16: (r= 'NOARCHIVELOG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:910:18: r= 'NOARCHIVELOG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 311, self.FOLLOW_311_in_k_noarchivelog7831)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 324, k_noarchivelog_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_noarchivelog"

    class k_nocache_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nocache_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nocache"
    # /home/szr/subquery/SQL2XML/YSmart.g:911:1: k_nocache : r= 'NOCACHE' ;
    def k_nocache(self, ):

        retval = self.k_nocache_return()
        retval.start = self.input.LT(1)
        k_nocache_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 325):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:911:11: (r= 'NOCACHE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:911:13: r= 'NOCACHE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 312, self.FOLLOW_312_in_k_nocache7844)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 325, k_nocache_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nocache"

    class k_nocycle_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nocycle_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nocycle"
    # /home/szr/subquery/SQL2XML/YSmart.g:912:1: k_nocycle : r= 'NOCYCLE' ;
    def k_nocycle(self, ):

        retval = self.k_nocycle_return()
        retval.start = self.input.LT(1)
        k_nocycle_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 326):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:912:11: (r= 'NOCYCLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:912:13: r= 'NOCYCLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 313, self.FOLLOW_313_in_k_nocycle7857)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 326, k_nocycle_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nocycle"

    class k_nomaxvalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nomaxvalue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nomaxvalue"
    # /home/szr/subquery/SQL2XML/YSmart.g:913:1: k_nomaxvalue : r= 'NOMAXVALUE' ;
    def k_nomaxvalue(self, ):

        retval = self.k_nomaxvalue_return()
        retval.start = self.input.LT(1)
        k_nomaxvalue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 327):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:913:14: (r= 'NOMAXVALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:913:16: r= 'NOMAXVALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 314, self.FOLLOW_314_in_k_nomaxvalue7870)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 327, k_nomaxvalue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nomaxvalue"

    class k_nominvalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nominvalue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nominvalue"
    # /home/szr/subquery/SQL2XML/YSmart.g:914:1: k_nominvalue : r= 'NOMINVALUE' ;
    def k_nominvalue(self, ):

        retval = self.k_nominvalue_return()
        retval.start = self.input.LT(1)
        k_nominvalue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 328):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:914:14: (r= 'NOMINVALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:914:16: r= 'NOMINVALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 315, self.FOLLOW_315_in_k_nominvalue7883)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 328, k_nominvalue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nominvalue"

    class k_none_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_none_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_none"
    # /home/szr/subquery/SQL2XML/YSmart.g:915:1: k_none : r= 'NONE' ;
    def k_none(self, ):

        retval = self.k_none_return()
        retval.start = self.input.LT(1)
        k_none_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 329):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:915:9: (r= 'NONE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:915:11: r= 'NONE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 316, self.FOLLOW_316_in_k_none7897)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 329, k_none_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_none"

    class k_noorder_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_noorder_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_noorder"
    # /home/szr/subquery/SQL2XML/YSmart.g:916:1: k_noorder : r= 'NOORDER' ;
    def k_noorder(self, ):

        retval = self.k_noorder_return()
        retval.start = self.input.LT(1)
        k_noorder_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 330):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:916:11: (r= 'NOORDER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:916:13: r= 'NOORDER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 317, self.FOLLOW_317_in_k_noorder7910)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 330, k_noorder_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_noorder"

    class k_noresetlogs_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_noresetlogs_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_noresetlogs"
    # /home/szr/subquery/SQL2XML/YSmart.g:917:1: k_noresetlogs : r= 'NORESETLOGS' ;
    def k_noresetlogs(self, ):

        retval = self.k_noresetlogs_return()
        retval.start = self.input.LT(1)
        k_noresetlogs_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 331):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:917:15: (r= 'NORESETLOGS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:917:17: r= 'NORESETLOGS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 318, self.FOLLOW_318_in_k_noresetlogs7923)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 331, k_noresetlogs_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_noresetlogs"

    class k_normal_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_normal_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_normal"
    # /home/szr/subquery/SQL2XML/YSmart.g:918:1: k_normal : r= 'NORMAL' ;
    def k_normal(self, ):

        retval = self.k_normal_return()
        retval.start = self.input.LT(1)
        k_normal_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 332):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:918:10: (r= 'NORMAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:918:12: r= 'NORMAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 319, self.FOLLOW_319_in_k_normal7936)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 332, k_normal_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_normal"

    class k_nosort_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nosort_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nosort"
    # /home/szr/subquery/SQL2XML/YSmart.g:919:1: k_nosort : r= 'NOSORT' ;
    def k_nosort(self, ):

        retval = self.k_nosort_return()
        retval.start = self.input.LT(1)
        k_nosort_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 333):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:919:10: (r= 'NOSORT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:919:12: r= 'NOSORT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 320, self.FOLLOW_320_in_k_nosort7949)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 333, k_nosort_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nosort"

    class k_numeric_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_numeric_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_numeric"
    # /home/szr/subquery/SQL2XML/YSmart.g:920:1: k_numeric : r= 'NUMERIC' ;
    def k_numeric(self, ):

        retval = self.k_numeric_return()
        retval.start = self.input.LT(1)
        k_numeric_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 334):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:920:12: (r= 'NUMERIC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:920:14: r= 'NUMERIC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 321, self.FOLLOW_321_in_k_numeric7963)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 334, k_numeric_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_numeric"

    class k_off_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_off_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_off"
    # /home/szr/subquery/SQL2XML/YSmart.g:921:1: k_off : r= 'OFF' ;
    def k_off(self, ):

        retval = self.k_off_return()
        retval.start = self.input.LT(1)
        k_off_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 335):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:921:7: (r= 'OFF' )
                # /home/szr/subquery/SQL2XML/YSmart.g:921:9: r= 'OFF'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 322, self.FOLLOW_322_in_k_off7976)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 335, k_off_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_off"

    class k_old_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_old_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_old"
    # /home/szr/subquery/SQL2XML/YSmart.g:922:1: k_old : r= 'OLD' ;
    def k_old(self, ):

        retval = self.k_old_return()
        retval.start = self.input.LT(1)
        k_old_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 336):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:922:7: (r= 'OLD' )
                # /home/szr/subquery/SQL2XML/YSmart.g:922:9: r= 'OLD'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 323, self.FOLLOW_323_in_k_old7989)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 336, k_old_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_old"

    class k_only_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_only_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_only"
    # /home/szr/subquery/SQL2XML/YSmart.g:923:1: k_only : r= 'ONLY' ;
    def k_only(self, ):

        retval = self.k_only_return()
        retval.start = self.input.LT(1)
        k_only_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 337):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:923:8: (r= 'ONLY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:923:10: r= 'ONLY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 324, self.FOLLOW_324_in_k_only8002)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 337, k_only_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_only"

    class k_open_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_open_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_open"
    # /home/szr/subquery/SQL2XML/YSmart.g:924:1: k_open : r= 'OPEN' ;
    def k_open(self, ):

        retval = self.k_open_return()
        retval.start = self.input.LT(1)
        k_open_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 338):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:924:8: (r= 'OPEN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:924:10: r= 'OPEN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 325, self.FOLLOW_325_in_k_open8015)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 338, k_open_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_open"

    class k_optimal_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_optimal_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_optimal"
    # /home/szr/subquery/SQL2XML/YSmart.g:925:1: k_optimal : r= 'OPTIMAL' ;
    def k_optimal(self, ):

        retval = self.k_optimal_return()
        retval.start = self.input.LT(1)
        k_optimal_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 339):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:925:11: (r= 'OPTIMAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:925:13: r= 'OPTIMAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 326, self.FOLLOW_326_in_k_optimal8028)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 339, k_optimal_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_optimal"

    class k_own_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_own_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_own"
    # /home/szr/subquery/SQL2XML/YSmart.g:926:1: k_own : r= 'OWN' ;
    def k_own(self, ):

        retval = self.k_own_return()
        retval.start = self.input.LT(1)
        k_own_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 340):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:926:8: (r= 'OWN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:926:10: r= 'OWN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 327, self.FOLLOW_327_in_k_own8042)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 340, k_own_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_own"

    class k_package_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_package_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_package"
    # /home/szr/subquery/SQL2XML/YSmart.g:927:1: k_package : r= 'PACKAGE' ;
    def k_package(self, ):

        retval = self.k_package_return()
        retval.start = self.input.LT(1)
        k_package_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 341):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:927:11: (r= 'PACKAGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:927:13: r= 'PACKAGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 328, self.FOLLOW_328_in_k_package8055)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 341, k_package_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_package"

    class k_parallel_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_parallel_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_parallel"
    # /home/szr/subquery/SQL2XML/YSmart.g:928:1: k_parallel : r= 'PARALLEL' ;
    def k_parallel(self, ):

        retval = self.k_parallel_return()
        retval.start = self.input.LT(1)
        k_parallel_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 342):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:928:12: (r= 'PARALLEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:928:14: r= 'PARALLEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 329, self.FOLLOW_329_in_k_parallel8068)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 342, k_parallel_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_parallel"

    class k_pctincrease_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pctincrease_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pctincrease"
    # /home/szr/subquery/SQL2XML/YSmart.g:929:1: k_pctincrease : r= 'PCTINCREASE' ;
    def k_pctincrease(self, ):

        retval = self.k_pctincrease_return()
        retval.start = self.input.LT(1)
        k_pctincrease_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 343):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:929:15: (r= 'PCTINCREASE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:929:17: r= 'PCTINCREASE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 330, self.FOLLOW_330_in_k_pctincrease8081)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 343, k_pctincrease_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pctincrease"

    class k_pctused_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pctused_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pctused"
    # /home/szr/subquery/SQL2XML/YSmart.g:930:1: k_pctused : r= 'PCTUSED' ;
    def k_pctused(self, ):

        retval = self.k_pctused_return()
        retval.start = self.input.LT(1)
        k_pctused_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 344):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:930:11: (r= 'PCTUSED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:930:13: r= 'PCTUSED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 331, self.FOLLOW_331_in_k_pctused8094)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 344, k_pctused_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pctused"

    class k_plan_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_plan_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_plan"
    # /home/szr/subquery/SQL2XML/YSmart.g:931:1: k_plan : r= 'PLAN' ;
    def k_plan(self, ):

        retval = self.k_plan_return()
        retval.start = self.input.LT(1)
        k_plan_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 345):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:931:8: (r= 'PLAN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:931:10: r= 'PLAN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 332, self.FOLLOW_332_in_k_plan8107)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 345, k_plan_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_plan"

    class k_pli_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pli_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pli"
    # /home/szr/subquery/SQL2XML/YSmart.g:932:1: k_pli : r= 'PLI' ;
    def k_pli(self, ):

        retval = self.k_pli_return()
        retval.start = self.input.LT(1)
        k_pli_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 346):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:932:7: (r= 'PLI' )
                # /home/szr/subquery/SQL2XML/YSmart.g:932:9: r= 'PLI'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 333, self.FOLLOW_333_in_k_pli8120)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 346, k_pli_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pli"

    class k_precision_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_precision_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_precision"
    # /home/szr/subquery/SQL2XML/YSmart.g:933:1: k_precision : r= 'PRECISION' ;
    def k_precision(self, ):

        retval = self.k_precision_return()
        retval.start = self.input.LT(1)
        k_precision_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 347):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:933:13: (r= 'PRECISION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:933:15: r= 'PRECISION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 334, self.FOLLOW_334_in_k_precision8133)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 347, k_precision_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_precision"

    class k_primary_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_primary_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_primary"
    # /home/szr/subquery/SQL2XML/YSmart.g:934:1: k_primary : r= 'PRIMARY' ;
    def k_primary(self, ):

        retval = self.k_primary_return()
        retval.start = self.input.LT(1)
        k_primary_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 348):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:934:11: (r= 'PRIMARY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:934:13: r= 'PRIMARY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 335, self.FOLLOW_335_in_k_primary8146)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 348, k_primary_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_primary"

    class k_private_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_private_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_private"
    # /home/szr/subquery/SQL2XML/YSmart.g:935:1: k_private : r= 'PRIVATE' ;
    def k_private(self, ):

        retval = self.k_private_return()
        retval.start = self.input.LT(1)
        k_private_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 349):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:935:11: (r= 'PRIVATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:935:13: r= 'PRIVATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 336, self.FOLLOW_336_in_k_private8159)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 349, k_private_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_private"

    class k_procedure_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_procedure_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_procedure"
    # /home/szr/subquery/SQL2XML/YSmart.g:936:1: k_procedure : r= 'PROCEDURE' ;
    def k_procedure(self, ):

        retval = self.k_procedure_return()
        retval.start = self.input.LT(1)
        k_procedure_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 350):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:936:13: (r= 'PROCEDURE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:936:15: r= 'PROCEDURE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 337, self.FOLLOW_337_in_k_procedure8172)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 350, k_procedure_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_procedure"

    class k_profile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_profile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_profile"
    # /home/szr/subquery/SQL2XML/YSmart.g:937:1: k_profile : r= 'PROFILE' ;
    def k_profile(self, ):

        retval = self.k_profile_return()
        retval.start = self.input.LT(1)
        k_profile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 351):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:937:12: (r= 'PROFILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:937:14: r= 'PROFILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 338, self.FOLLOW_338_in_k_profile8186)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 351, k_profile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_profile"

    class k_quota_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_quota_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_quota"
    # /home/szr/subquery/SQL2XML/YSmart.g:938:1: k_quota : r= 'QUOTA' ;
    def k_quota(self, ):

        retval = self.k_quota_return()
        retval.start = self.input.LT(1)
        k_quota_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 352):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:938:10: (r= 'QUOTA' )
                # /home/szr/subquery/SQL2XML/YSmart.g:938:12: r= 'QUOTA'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 339, self.FOLLOW_339_in_k_quota8200)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 352, k_quota_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_quota"

    class k_read_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_read_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_read"
    # /home/szr/subquery/SQL2XML/YSmart.g:939:1: k_read : r= 'READ' ;
    def k_read(self, ):

        retval = self.k_read_return()
        retval.start = self.input.LT(1)
        k_read_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 353):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:939:8: (r= 'READ' )
                # /home/szr/subquery/SQL2XML/YSmart.g:939:10: r= 'READ'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 340, self.FOLLOW_340_in_k_read8213)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 353, k_read_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_read"

    class k_real_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_real_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_real"
    # /home/szr/subquery/SQL2XML/YSmart.g:940:1: k_real : r= 'REAL' ;
    def k_real(self, ):

        retval = self.k_real_return()
        retval.start = self.input.LT(1)
        k_real_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 354):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:940:8: (r= 'REAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:940:10: r= 'REAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 341, self.FOLLOW_341_in_k_real8226)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 354, k_real_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_real"

    class k_recover_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_recover_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_recover"
    # /home/szr/subquery/SQL2XML/YSmart.g:941:1: k_recover : r= 'RECOVER' ;
    def k_recover(self, ):

        retval = self.k_recover_return()
        retval.start = self.input.LT(1)
        k_recover_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 355):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:941:11: (r= 'RECOVER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:941:13: r= 'RECOVER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 342, self.FOLLOW_342_in_k_recover8239)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 355, k_recover_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_recover"

    class k_references_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_references_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_references"
    # /home/szr/subquery/SQL2XML/YSmart.g:942:1: k_references : r= 'REFERENCES' ;
    def k_references(self, ):

        retval = self.k_references_return()
        retval.start = self.input.LT(1)
        k_references_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 356):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:942:14: (r= 'REFERENCES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:942:16: r= 'REFERENCES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 343, self.FOLLOW_343_in_k_references8252)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 356, k_references_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_references"

    class k_referencing_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_referencing_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_referencing"
    # /home/szr/subquery/SQL2XML/YSmart.g:943:1: k_referencing : r= 'REFERENCING' ;
    def k_referencing(self, ):

        retval = self.k_referencing_return()
        retval.start = self.input.LT(1)
        k_referencing_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 357):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:943:15: (r= 'REFERENCING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:943:17: r= 'REFERENCING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 344, self.FOLLOW_344_in_k_referencing8265)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 357, k_referencing_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_referencing"

    class k_resetlogs_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_resetlogs_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_resetlogs"
    # /home/szr/subquery/SQL2XML/YSmart.g:944:1: k_resetlogs : r= 'RESETLOGS' ;
    def k_resetlogs(self, ):

        retval = self.k_resetlogs_return()
        retval.start = self.input.LT(1)
        k_resetlogs_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 358):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:944:13: (r= 'RESETLOGS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:944:15: r= 'RESETLOGS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 345, self.FOLLOW_345_in_k_resetlogs8278)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 358, k_resetlogs_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_resetlogs"

    class k_restricted_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_restricted_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_restricted"
    # /home/szr/subquery/SQL2XML/YSmart.g:945:1: k_restricted : r= 'RESTRICTED' ;
    def k_restricted(self, ):

        retval = self.k_restricted_return()
        retval.start = self.input.LT(1)
        k_restricted_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 359):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:945:14: (r= 'RESTRICTED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:945:16: r= 'RESTRICTED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 346, self.FOLLOW_346_in_k_restricted8291)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 359, k_restricted_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_restricted"

    class k_reuse_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_reuse_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_reuse"
    # /home/szr/subquery/SQL2XML/YSmart.g:946:1: k_reuse : r= 'REUSE' ;
    def k_reuse(self, ):

        retval = self.k_reuse_return()
        retval.start = self.input.LT(1)
        k_reuse_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 360):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:946:10: (r= 'REUSE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:946:12: r= 'REUSE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 347, self.FOLLOW_347_in_k_reuse8305)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 360, k_reuse_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_reuse"

    class k_role_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_role_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_role"
    # /home/szr/subquery/SQL2XML/YSmart.g:947:1: k_role : r= 'ROLE' ;
    def k_role(self, ):

        retval = self.k_role_return()
        retval.start = self.input.LT(1)
        k_role_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 361):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:947:8: (r= 'ROLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:947:10: r= 'ROLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 348, self.FOLLOW_348_in_k_role8318)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 361, k_role_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_role"

    class k_roles_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_roles_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_roles"
    # /home/szr/subquery/SQL2XML/YSmart.g:948:1: k_roles : r= 'ROLES' ;
    def k_roles(self, ):

        retval = self.k_roles_return()
        retval.start = self.input.LT(1)
        k_roles_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 362):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:948:9: (r= 'ROLES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:948:11: r= 'ROLES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 349, self.FOLLOW_349_in_k_roles8331)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 362, k_roles_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_roles"

    class k_rollback_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rollback_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rollback"
    # /home/szr/subquery/SQL2XML/YSmart.g:949:1: k_rollback : r= 'ROLLBACK' ;
    def k_rollback(self, ):

        retval = self.k_rollback_return()
        retval.start = self.input.LT(1)
        k_rollback_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 363):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:949:13: (r= 'ROLLBACK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:949:15: r= 'ROLLBACK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 350, self.FOLLOW_350_in_k_rollback8345)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 363, k_rollback_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rollback"

    class k_savepoint_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_savepoint_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_savepoint"
    # /home/szr/subquery/SQL2XML/YSmart.g:950:1: k_savepoint : r= 'SAVEPOINT' ;
    def k_savepoint(self, ):

        retval = self.k_savepoint_return()
        retval.start = self.input.LT(1)
        k_savepoint_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 364):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:950:13: (r= 'SAVEPOINT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:950:15: r= 'SAVEPOINT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 351, self.FOLLOW_351_in_k_savepoint8358)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 364, k_savepoint_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_savepoint"

    class k_schema_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_schema_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_schema"
    # /home/szr/subquery/SQL2XML/YSmart.g:951:1: k_schema : r= 'SCHEMA' ;
    def k_schema(self, ):

        retval = self.k_schema_return()
        retval.start = self.input.LT(1)
        k_schema_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 365):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:951:10: (r= 'SCHEMA' )
                # /home/szr/subquery/SQL2XML/YSmart.g:951:12: r= 'SCHEMA'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 352, self.FOLLOW_352_in_k_schema8371)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 365, k_schema_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_schema"

    class k_scn_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_scn_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_scn"
    # /home/szr/subquery/SQL2XML/YSmart.g:952:1: k_scn : r= 'SCN' ;
    def k_scn(self, ):

        retval = self.k_scn_return()
        retval.start = self.input.LT(1)
        k_scn_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 366):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:952:7: (r= 'SCN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:952:9: r= 'SCN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 353, self.FOLLOW_353_in_k_scn8384)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 366, k_scn_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_scn"

    class k_second_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_second_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_second"
    # /home/szr/subquery/SQL2XML/YSmart.g:953:1: k_second : r= 'SECOND' ;
    def k_second(self, ):

        retval = self.k_second_return()
        retval.start = self.input.LT(1)
        k_second_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 367):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:953:10: (r= 'SECOND' )
                # /home/szr/subquery/SQL2XML/YSmart.g:953:12: r= 'SECOND'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 354, self.FOLLOW_354_in_k_second8397)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 367, k_second_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_second"

    class k_section_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_section_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_section"
    # /home/szr/subquery/SQL2XML/YSmart.g:954:1: k_section : r= 'SECTION' ;
    def k_section(self, ):

        retval = self.k_section_return()
        retval.start = self.input.LT(1)
        k_section_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 368):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:954:11: (r= 'SECTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:954:13: r= 'SECTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 355, self.FOLLOW_355_in_k_section8410)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 368, k_section_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_section"

    class k_segment_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_segment_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_segment"
    # /home/szr/subquery/SQL2XML/YSmart.g:955:1: k_segment : r= 'SEGMENT' ;
    def k_segment(self, ):

        retval = self.k_segment_return()
        retval.start = self.input.LT(1)
        k_segment_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 369):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:955:11: (r= 'SEGMENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:955:13: r= 'SEGMENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 356, self.FOLLOW_356_in_k_segment8423)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 369, k_segment_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_segment"

    class k_sequence_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sequence_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sequence"
    # /home/szr/subquery/SQL2XML/YSmart.g:956:1: k_sequence : r= 'SEQUENCE' ;
    def k_sequence(self, ):

        retval = self.k_sequence_return()
        retval.start = self.input.LT(1)
        k_sequence_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 370):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:956:12: (r= 'SEQUENCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:956:14: r= 'SEQUENCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 357, self.FOLLOW_357_in_k_sequence8436)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 370, k_sequence_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sequence"

    class k_sessiontimezone_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sessiontimezone_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sessiontimezone"
    # /home/szr/subquery/SQL2XML/YSmart.g:957:1: k_sessiontimezone : r= 'SESSIONTIMEZONE' ;
    def k_sessiontimezone(self, ):

        retval = self.k_sessiontimezone_return()
        retval.start = self.input.LT(1)
        k_sessiontimezone_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 371):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:957:19: (r= 'SESSIONTIMEZONE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:957:21: r= 'SESSIONTIMEZONE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 358, self.FOLLOW_358_in_k_sessiontimezone8449)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 371, k_sessiontimezone_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sessiontimezone"

    class k_shared_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_shared_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_shared"
    # /home/szr/subquery/SQL2XML/YSmart.g:958:1: k_shared : r= 'SHARED' ;
    def k_shared(self, ):

        retval = self.k_shared_return()
        retval.start = self.input.LT(1)
        k_shared_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 372):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:958:10: (r= 'SHARED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:958:12: r= 'SHARED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 359, self.FOLLOW_359_in_k_shared8462)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 372, k_shared_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_shared"

    class k_snapshot_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_snapshot_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_snapshot"
    # /home/szr/subquery/SQL2XML/YSmart.g:959:1: k_snapshot : r= 'SNAPSHOT' ;
    def k_snapshot(self, ):

        retval = self.k_snapshot_return()
        retval.start = self.input.LT(1)
        k_snapshot_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 373):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:959:13: (r= 'SNAPSHOT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:959:15: r= 'SNAPSHOT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 360, self.FOLLOW_360_in_k_snapshot8476)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 373, k_snapshot_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_snapshot"

    class k_skip_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_skip_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_skip"
    # /home/szr/subquery/SQL2XML/YSmart.g:960:1: k_skip : r= 'SKIP' ;
    def k_skip(self, ):

        retval = self.k_skip_return()
        retval.start = self.input.LT(1)
        k_skip_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 374):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:960:8: (r= 'SKIP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:960:10: r= 'SKIP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 361, self.FOLLOW_361_in_k_skip8489)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 374, k_skip_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_skip"

    class k_some_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_some_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_some"
    # /home/szr/subquery/SQL2XML/YSmart.g:961:1: k_some : r= 'SOME' ;
    def k_some(self, ):

        retval = self.k_some_return()
        retval.start = self.input.LT(1)
        k_some_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 375):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:961:8: (r= 'SOME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:961:10: r= 'SOME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 362, self.FOLLOW_362_in_k_some8502)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 375, k_some_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_some"

    class k_sort_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sort_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sort"
    # /home/szr/subquery/SQL2XML/YSmart.g:962:1: k_sort : r= 'SORT' ;
    def k_sort(self, ):

        retval = self.k_sort_return()
        retval.start = self.input.LT(1)
        k_sort_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 376):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:962:8: (r= 'SORT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:962:10: r= 'SORT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 363, self.FOLLOW_363_in_k_sort8515)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 376, k_sort_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sort"

    class k_sql_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sql_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sql"
    # /home/szr/subquery/SQL2XML/YSmart.g:963:1: k_sql : r= 'SQL' ;
    def k_sql(self, ):

        retval = self.k_sql_return()
        retval.start = self.input.LT(1)
        k_sql_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 377):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:963:7: (r= 'SQL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:963:9: r= 'SQL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 364, self.FOLLOW_364_in_k_sql8528)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 377, k_sql_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sql"

    class k_sqlcode_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sqlcode_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sqlcode"
    # /home/szr/subquery/SQL2XML/YSmart.g:964:1: k_sqlcode : r= 'SQLCODE' ;
    def k_sqlcode(self, ):

        retval = self.k_sqlcode_return()
        retval.start = self.input.LT(1)
        k_sqlcode_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 378):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:964:11: (r= 'SQLCODE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:964:13: r= 'SQLCODE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 365, self.FOLLOW_365_in_k_sqlcode8541)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 378, k_sqlcode_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sqlcode"

    class k_sqlerror_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sqlerror_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sqlerror"
    # /home/szr/subquery/SQL2XML/YSmart.g:965:1: k_sqlerror : r= 'SQLERROR' ;
    def k_sqlerror(self, ):

        retval = self.k_sqlerror_return()
        retval.start = self.input.LT(1)
        k_sqlerror_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 379):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:965:12: (r= 'SQLERROR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:965:14: r= 'SQLERROR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 366, self.FOLLOW_366_in_k_sqlerror8554)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 379, k_sqlerror_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sqlerror"

    class k_sqlstate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sqlstate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sqlstate"
    # /home/szr/subquery/SQL2XML/YSmart.g:966:1: k_sqlstate : r= 'SQLSTATE' ;
    def k_sqlstate(self, ):

        retval = self.k_sqlstate_return()
        retval.start = self.input.LT(1)
        k_sqlstate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 380):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:966:12: (r= 'SQLSTATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:966:14: r= 'SQLSTATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 367, self.FOLLOW_367_in_k_sqlstate8567)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 380, k_sqlstate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sqlstate"

    class k_statement_ID_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_statement_ID_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_statement_ID"
    # /home/szr/subquery/SQL2XML/YSmart.g:967:1: k_statement_ID : r= 'STATEMENT' ;
    def k_statement_ID(self, ):

        retval = self.k_statement_ID_return()
        retval.start = self.input.LT(1)
        k_statement_ID_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 381):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:967:16: (r= 'STATEMENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:967:18: r= 'STATEMENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 368, self.FOLLOW_368_in_k_statement_ID8580)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 381, k_statement_ID_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_statement_ID"

    class k_statistics_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_statistics_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_statistics"
    # /home/szr/subquery/SQL2XML/YSmart.g:968:1: k_statistics : r= 'STATISTICS' ;
    def k_statistics(self, ):

        retval = self.k_statistics_return()
        retval.start = self.input.LT(1)
        k_statistics_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 382):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:968:14: (r= 'STATISTICS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:968:16: r= 'STATISTICS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 369, self.FOLLOW_369_in_k_statistics8593)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 382, k_statistics_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_statistics"

    class k_stop_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_stop_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_stop"
    # /home/szr/subquery/SQL2XML/YSmart.g:969:1: k_stop : r= 'STOP' ;
    def k_stop(self, ):

        retval = self.k_stop_return()
        retval.start = self.input.LT(1)
        k_stop_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 383):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:969:8: (r= 'STOP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:969:10: r= 'STOP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 370, self.FOLLOW_370_in_k_stop8606)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 383, k_stop_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_stop"

    class k_storage_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_storage_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_storage"
    # /home/szr/subquery/SQL2XML/YSmart.g:970:1: k_storage : r= 'STORAGE' ;
    def k_storage(self, ):

        retval = self.k_storage_return()
        retval.start = self.input.LT(1)
        k_storage_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 384):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:970:11: (r= 'STORAGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:970:13: r= 'STORAGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 371, self.FOLLOW_371_in_k_storage8619)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 384, k_storage_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_storage"

    class k_sum_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sum_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sum"
    # /home/szr/subquery/SQL2XML/YSmart.g:971:1: k_sum : r= 'SUM' ;
    def k_sum(self, ):

        retval = self.k_sum_return()
        retval.start = self.input.LT(1)
        k_sum_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 385):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:971:7: (r= 'SUM' )
                # /home/szr/subquery/SQL2XML/YSmart.g:971:9: r= 'SUM'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 372, self.FOLLOW_372_in_k_sum8632)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 385, k_sum_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sum"

    class k_switch_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_switch_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_switch"
    # /home/szr/subquery/SQL2XML/YSmart.g:972:1: k_switch : r= 'SWITCH' ;
    def k_switch(self, ):

        retval = self.k_switch_return()
        retval.start = self.input.LT(1)
        k_switch_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 386):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:972:10: (r= 'SWITCH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:972:12: r= 'SWITCH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 373, self.FOLLOW_373_in_k_switch8645)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 386, k_switch_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_switch"

    class k_system_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_system_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_system"
    # /home/szr/subquery/SQL2XML/YSmart.g:973:1: k_system : r= 'SYSTEM' ;
    def k_system(self, ):

        retval = self.k_system_return()
        retval.start = self.input.LT(1)
        k_system_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 387):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:973:11: (r= 'SYSTEM' )
                # /home/szr/subquery/SQL2XML/YSmart.g:973:13: r= 'SYSTEM'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 374, self.FOLLOW_374_in_k_system8659)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 387, k_system_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_system"

    class k_tables_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_tables_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_tables"
    # /home/szr/subquery/SQL2XML/YSmart.g:974:1: k_tables : r= 'TABLES' ;
    def k_tables(self, ):

        retval = self.k_tables_return()
        retval.start = self.input.LT(1)
        k_tables_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 388):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:974:10: (r= 'TABLES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:974:12: r= 'TABLES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 375, self.FOLLOW_375_in_k_tables8672)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 388, k_tables_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_tables"

    class k_tablespace_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_tablespace_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_tablespace"
    # /home/szr/subquery/SQL2XML/YSmart.g:975:1: k_tablespace : r= 'TABLESPACE' ;
    def k_tablespace(self, ):

        retval = self.k_tablespace_return()
        retval.start = self.input.LT(1)
        k_tablespace_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 389):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:975:14: (r= 'TABLESPACE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:975:16: r= 'TABLESPACE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 376, self.FOLLOW_376_in_k_tablespace8685)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 389, k_tablespace_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_tablespace"

    class k_temporary_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_temporary_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_temporary"
    # /home/szr/subquery/SQL2XML/YSmart.g:976:1: k_temporary : r= 'TEMPORARY' ;
    def k_temporary(self, ):

        retval = self.k_temporary_return()
        retval.start = self.input.LT(1)
        k_temporary_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 390):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:976:13: (r= 'TEMPORARY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:976:15: r= 'TEMPORARY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 377, self.FOLLOW_377_in_k_temporary8698)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 390, k_temporary_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_temporary"

    class k_thread_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_thread_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_thread"
    # /home/szr/subquery/SQL2XML/YSmart.g:977:1: k_thread : r= 'THREAD' ;
    def k_thread(self, ):

        retval = self.k_thread_return()
        retval.start = self.input.LT(1)
        k_thread_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 391):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:977:10: (r= 'THREAD' )
                # /home/szr/subquery/SQL2XML/YSmart.g:977:12: r= 'THREAD'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 378, self.FOLLOW_378_in_k_thread8711)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 391, k_thread_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_thread"

    class k_time_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_time_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_time"
    # /home/szr/subquery/SQL2XML/YSmart.g:978:1: k_time : r= 'TIME' ;
    def k_time(self, ):

        retval = self.k_time_return()
        retval.start = self.input.LT(1)
        k_time_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 392):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:978:8: (r= 'TIME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:978:10: r= 'TIME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 379, self.FOLLOW_379_in_k_time8724)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 392, k_time_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_time"

    class k_tracing_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_tracing_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_tracing"
    # /home/szr/subquery/SQL2XML/YSmart.g:979:1: k_tracing : r= 'TRACING' ;
    def k_tracing(self, ):

        retval = self.k_tracing_return()
        retval.start = self.input.LT(1)
        k_tracing_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 393):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:979:11: (r= 'TRACING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:979:13: r= 'TRACING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 380, self.FOLLOW_380_in_k_tracing8737)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 393, k_tracing_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_tracing"

    class k_transaction_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_transaction_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_transaction"
    # /home/szr/subquery/SQL2XML/YSmart.g:980:1: k_transaction : r= 'TRANSACTION' ;
    def k_transaction(self, ):

        retval = self.k_transaction_return()
        retval.start = self.input.LT(1)
        k_transaction_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 394):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:980:15: (r= 'TRANSACTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:980:17: r= 'TRANSACTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 381, self.FOLLOW_381_in_k_transaction8750)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 394, k_transaction_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_transaction"

    class k_triggers_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_triggers_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_triggers"
    # /home/szr/subquery/SQL2XML/YSmart.g:981:1: k_triggers : r= 'TRIGGERS' ;
    def k_triggers(self, ):

        retval = self.k_triggers_return()
        retval.start = self.input.LT(1)
        k_triggers_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 395):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:981:13: (r= 'TRIGGERS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:981:15: r= 'TRIGGERS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 382, self.FOLLOW_382_in_k_triggers8764)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 395, k_triggers_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_triggers"

    class k_truncate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_truncate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_truncate"
    # /home/szr/subquery/SQL2XML/YSmart.g:982:1: k_truncate : r= 'TRUNCATE' ;
    def k_truncate(self, ):

        retval = self.k_truncate_return()
        retval.start = self.input.LT(1)
        k_truncate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 396):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:982:13: (r= 'TRUNCATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:982:15: r= 'TRUNCATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 383, self.FOLLOW_383_in_k_truncate8778)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 396, k_truncate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_truncate"

    class k_under_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_under_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_under"
    # /home/szr/subquery/SQL2XML/YSmart.g:983:1: k_under : r= 'UNDER' ;
    def k_under(self, ):

        retval = self.k_under_return()
        retval.start = self.input.LT(1)
        k_under_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 397):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:983:9: (r= 'UNDER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:983:11: r= 'UNDER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 384, self.FOLLOW_384_in_k_under8791)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 397, k_under_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_under"

    class k_unlimited_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_unlimited_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_unlimited"
    # /home/szr/subquery/SQL2XML/YSmart.g:984:1: k_unlimited : r= 'UNLIMITED' ;
    def k_unlimited(self, ):

        retval = self.k_unlimited_return()
        retval.start = self.input.LT(1)
        k_unlimited_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 398):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:984:13: (r= 'UNLIMITED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:984:15: r= 'UNLIMITED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 385, self.FOLLOW_385_in_k_unlimited8804)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 398, k_unlimited_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_unlimited"

    class k_until_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_until_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_until"
    # /home/szr/subquery/SQL2XML/YSmart.g:985:1: k_until : r= 'UNTIL' ;
    def k_until(self, ):

        retval = self.k_until_return()
        retval.start = self.input.LT(1)
        k_until_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 399):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:985:9: (r= 'UNTIL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:985:11: r= 'UNTIL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 386, self.FOLLOW_386_in_k_until8817)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 399, k_until_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_until"

    class k_use_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_use_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_use"
    # /home/szr/subquery/SQL2XML/YSmart.g:986:1: k_use : r= 'USE' ;
    def k_use(self, ):

        retval = self.k_use_return()
        retval.start = self.input.LT(1)
        k_use_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 400):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:986:7: (r= 'USE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:986:9: r= 'USE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 387, self.FOLLOW_387_in_k_use8830)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 400, k_use_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_use"

    class k_using_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_using_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_using"
    # /home/szr/subquery/SQL2XML/YSmart.g:987:1: k_using : r= 'USING' ;
    def k_using(self, ):

        retval = self.k_using_return()
        retval.start = self.input.LT(1)
        k_using_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 401):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:987:10: (r= 'USING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:987:12: r= 'USING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 388, self.FOLLOW_388_in_k_using8844)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 401, k_using_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_using"

    class k_wait_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_wait_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_wait"
    # /home/szr/subquery/SQL2XML/YSmart.g:988:1: k_wait : r= 'WAIT' ;
    def k_wait(self, ):

        retval = self.k_wait_return()
        retval.start = self.input.LT(1)
        k_wait_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 402):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:988:8: (r= 'WAIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:988:10: r= 'WAIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 389, self.FOLLOW_389_in_k_wait8857)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 402, k_wait_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_wait"

    class k_when_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_when_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_when"
    # /home/szr/subquery/SQL2XML/YSmart.g:989:1: k_when : r= 'WHEN' ;
    def k_when(self, ):

        retval = self.k_when_return()
        retval.start = self.input.LT(1)
        k_when_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 403):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:989:8: (r= 'WHEN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:989:10: r= 'WHEN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 390, self.FOLLOW_390_in_k_when8870)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 403, k_when_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_when"

    class k_work_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_work_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_work"
    # /home/szr/subquery/SQL2XML/YSmart.g:990:1: k_work : r= 'WORK' ;
    def k_work(self, ):

        retval = self.k_work_return()
        retval.start = self.input.LT(1)
        k_work_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 404):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:990:8: (r= 'WORK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:990:10: r= 'WORK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 391, self.FOLLOW_391_in_k_work8883)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 404, k_work_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_work"

    class k_write_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_write_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_write"
    # /home/szr/subquery/SQL2XML/YSmart.g:991:1: k_write : r= 'WRITE' ;
    def k_write(self, ):

        retval = self.k_write_return()
        retval.start = self.input.LT(1)
        k_write_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 405):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:991:10: (r= 'WRITE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:991:12: r= 'WRITE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 392, self.FOLLOW_392_in_k_write8897)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 405, k_write_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_write"

    class k_year_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_year_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_year"
    # /home/szr/subquery/SQL2XML/YSmart.g:992:1: k_year : r= 'YEAR' ;
    def k_year(self, ):

        retval = self.k_year_return()
        retval.start = self.input.LT(1)
        k_year_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 406):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:992:9: (r= 'YEAR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:992:11: r= 'YEAR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 393, self.FOLLOW_393_in_k_year8911)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 406, k_year_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_year"

    class k_zone_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_zone_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_zone"
    # /home/szr/subquery/SQL2XML/YSmart.g:993:1: k_zone : r= 'ZONE' ;
    def k_zone(self, ):

        retval = self.k_zone_return()
        retval.start = self.input.LT(1)
        k_zone_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 407):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:993:9: (r= 'ZONE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:993:11: r= 'ZONE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 394, self.FOLLOW_394_in_k_zone8925)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 407, k_zone_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_zone"

    class k_automatic_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_automatic_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_automatic"
    # /home/szr/subquery/SQL2XML/YSmart.g:995:1: k_automatic : r= 'AUTOMATIC' ;
    def k_automatic(self, ):

        retval = self.k_automatic_return()
        retval.start = self.input.LT(1)
        k_automatic_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 408):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:995:13: (r= 'AUTOMATIC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:995:15: r= 'AUTOMATIC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 395, self.FOLLOW_395_in_k_automatic8939)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 408, k_automatic_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_automatic"

    class k_bfile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_bfile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_bfile"
    # /home/szr/subquery/SQL2XML/YSmart.g:996:1: k_bfile : r= 'BFILE' ;
    def k_bfile(self, ):

        retval = self.k_bfile_return()
        retval.start = self.input.LT(1)
        k_bfile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 409):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:996:9: (r= 'BFILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:996:11: r= 'BFILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 396, self.FOLLOW_396_in_k_bfile8952)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 409, k_bfile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_bfile"

    class k_binary_double_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_binary_double_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_binary_double"
    # /home/szr/subquery/SQL2XML/YSmart.g:997:1: k_binary_double : r= 'BINARY_DOUBLE' ;
    def k_binary_double(self, ):

        retval = self.k_binary_double_return()
        retval.start = self.input.LT(1)
        k_binary_double_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 410):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:997:17: (r= 'BINARY_DOUBLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:997:19: r= 'BINARY_DOUBLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 397, self.FOLLOW_397_in_k_binary_double8965)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 410, k_binary_double_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_binary_double"

    class k_binary_float_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_binary_float_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_binary_float"
    # /home/szr/subquery/SQL2XML/YSmart.g:998:1: k_binary_float : r= 'BINARY_FLOAT' ;
    def k_binary_float(self, ):

        retval = self.k_binary_float_return()
        retval.start = self.input.LT(1)
        k_binary_float_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 411):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:998:16: (r= 'BINARY_FLOAT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:998:18: r= 'BINARY_FLOAT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 398, self.FOLLOW_398_in_k_binary_float8978)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 411, k_binary_float_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_binary_float"

    class k_binary_integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_binary_integer_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_binary_integer"
    # /home/szr/subquery/SQL2XML/YSmart.g:999:1: k_binary_integer : r= 'BINARY_INTEGER' ;
    def k_binary_integer(self, ):

        retval = self.k_binary_integer_return()
        retval.start = self.input.LT(1)
        k_binary_integer_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 412):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:999:18: (r= 'BINARY_INTEGER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:999:20: r= 'BINARY_INTEGER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 399, self.FOLLOW_399_in_k_binary_integer8991)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 412, k_binary_integer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_binary_integer"

    class k_blob_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_blob_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_blob"
    # /home/szr/subquery/SQL2XML/YSmart.g:1000:1: k_blob : r= 'BLOB' ;
    def k_blob(self, ):

        retval = self.k_blob_return()
        retval.start = self.input.LT(1)
        k_blob_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 413):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1000:8: (r= 'BLOB' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1000:10: r= 'BLOB'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 400, self.FOLLOW_400_in_k_blob9004)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 413, k_blob_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_blob"

    class k_boolean_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_boolean_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_boolean"
    # /home/szr/subquery/SQL2XML/YSmart.g:1001:1: k_boolean : r= 'BOOLEAN' ;
    def k_boolean(self, ):

        retval = self.k_boolean_return()
        retval.start = self.input.LT(1)
        k_boolean_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 414):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1001:11: (r= 'BOOLEAN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1001:13: r= 'BOOLEAN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 401, self.FOLLOW_401_in_k_boolean9017)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 414, k_boolean_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_boolean"

    class k_byte_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_byte_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_byte"
    # /home/szr/subquery/SQL2XML/YSmart.g:1002:1: k_byte : r= 'BYTE' ;
    def k_byte(self, ):

        retval = self.k_byte_return()
        retval.start = self.input.LT(1)
        k_byte_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 415):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1002:8: (r= 'BYTE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1002:10: r= 'BYTE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 402, self.FOLLOW_402_in_k_byte9030)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 415, k_byte_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_byte"

    class k_cast_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cast_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cast"
    # /home/szr/subquery/SQL2XML/YSmart.g:1003:1: k_cast : r= 'CAST' ;
    def k_cast(self, ):

        retval = self.k_cast_return()
        retval.start = self.input.LT(1)
        k_cast_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 416):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1003:8: (r= 'CAST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1003:10: r= 'CAST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 403, self.FOLLOW_403_in_k_cast9043)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 416, k_cast_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cast"

    class k_clob_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_clob_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_clob"
    # /home/szr/subquery/SQL2XML/YSmart.g:1004:1: k_clob : r= 'CLOB' ;
    def k_clob(self, ):

        retval = self.k_clob_return()
        retval.start = self.input.LT(1)
        k_clob_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 417):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1004:8: (r= 'CLOB' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1004:10: r= 'CLOB'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 404, self.FOLLOW_404_in_k_clob9056)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 417, k_clob_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_clob"

    class k_cluster_set_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cluster_set_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cluster_set"
    # /home/szr/subquery/SQL2XML/YSmart.g:1005:1: k_cluster_set : r= 'CLUSTER_SET' ;
    def k_cluster_set(self, ):

        retval = self.k_cluster_set_return()
        retval.start = self.input.LT(1)
        k_cluster_set_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 418):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1005:15: (r= 'CLUSTER_SET' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1005:17: r= 'CLUSTER_SET'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 405, self.FOLLOW_405_in_k_cluster_set9069)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 418, k_cluster_set_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cluster_set"

    class k_column_value_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_column_value_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_column_value"
    # /home/szr/subquery/SQL2XML/YSmart.g:1006:1: k_column_value : r= 'COLUMN_VALUE' ;
    def k_column_value(self, ):

        retval = self.k_column_value_return()
        retval.start = self.input.LT(1)
        k_column_value_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 419):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1006:16: (r= 'COLUMN_VALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1006:18: r= 'COLUMN_VALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 406, self.FOLLOW_406_in_k_column_value9082)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 419, k_column_value_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_column_value"

    class k_connect_by_iscycle_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_connect_by_iscycle_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_connect_by_iscycle"
    # /home/szr/subquery/SQL2XML/YSmart.g:1007:1: k_connect_by_iscycle : r= 'CONNECT_BY_ISCYCLE' ;
    def k_connect_by_iscycle(self, ):

        retval = self.k_connect_by_iscycle_return()
        retval.start = self.input.LT(1)
        k_connect_by_iscycle_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 420):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1007:22: (r= 'CONNECT_BY_ISCYCLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1007:24: r= 'CONNECT_BY_ISCYCLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 407, self.FOLLOW_407_in_k_connect_by_iscycle9095)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 420, k_connect_by_iscycle_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_connect_by_iscycle"

    class k_connect_by_isleaf_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_connect_by_isleaf_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_connect_by_isleaf"
    # /home/szr/subquery/SQL2XML/YSmart.g:1008:1: k_connect_by_isleaf : r= 'CONNECT_BY_ISLEAF' ;
    def k_connect_by_isleaf(self, ):

        retval = self.k_connect_by_isleaf_return()
        retval.start = self.input.LT(1)
        k_connect_by_isleaf_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 421):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1008:21: (r= 'CONNECT_BY_ISLEAF' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1008:23: r= 'CONNECT_BY_ISLEAF'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 408, self.FOLLOW_408_in_k_connect_by_isleaf9108)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 421, k_connect_by_isleaf_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_connect_by_isleaf"

    class k_connect_by_root_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_connect_by_root_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_connect_by_root"
    # /home/szr/subquery/SQL2XML/YSmart.g:1009:1: k_connect_by_root : r= 'CONNECT_BY_ROOT' ;
    def k_connect_by_root(self, ):

        retval = self.k_connect_by_root_return()
        retval.start = self.input.LT(1)
        k_connect_by_root_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 422):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1009:19: (r= 'CONNECT_BY_ROOT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1009:21: r= 'CONNECT_BY_ROOT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 409, self.FOLLOW_409_in_k_connect_by_root9121)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 422, k_connect_by_root_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_connect_by_root"

    class k_corr_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_corr_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_corr"
    # /home/szr/subquery/SQL2XML/YSmart.g:1010:1: k_corr : r= 'CORR' ;
    def k_corr(self, ):

        retval = self.k_corr_return()
        retval.start = self.input.LT(1)
        k_corr_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 423):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1010:8: (r= 'CORR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1010:10: r= 'CORR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 410, self.FOLLOW_410_in_k_corr9134)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 423, k_corr_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_corr"

    class k_covar_pop_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_covar_pop_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_covar_pop"
    # /home/szr/subquery/SQL2XML/YSmart.g:1011:1: k_covar_pop : r= 'COVAR_POP' ;
    def k_covar_pop(self, ):

        retval = self.k_covar_pop_return()
        retval.start = self.input.LT(1)
        k_covar_pop_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 424):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1011:13: (r= 'COVAR_POP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1011:15: r= 'COVAR_POP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 411, self.FOLLOW_411_in_k_covar_pop9147)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 424, k_covar_pop_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_covar_pop"

    class k_covar_samp_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_covar_samp_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_covar_samp"
    # /home/szr/subquery/SQL2XML/YSmart.g:1012:1: k_covar_samp : r= 'COVAR_SAMP' ;
    def k_covar_samp(self, ):

        retval = self.k_covar_samp_return()
        retval.start = self.input.LT(1)
        k_covar_samp_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 425):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1012:14: (r= 'COVAR_SAMP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1012:16: r= 'COVAR_SAMP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 412, self.FOLLOW_412_in_k_covar_samp9160)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 425, k_covar_samp_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_covar_samp"

    class k_cross_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cross_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cross"
    # /home/szr/subquery/SQL2XML/YSmart.g:1013:1: k_cross : r= 'CROSS' ;
    def k_cross(self, ):

        retval = self.k_cross_return()
        retval.start = self.input.LT(1)
        k_cross_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 426):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1013:9: (r= 'CROSS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1013:11: r= 'CROSS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 413, self.FOLLOW_413_in_k_cross9173)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 426, k_cross_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cross"

    class k_cube_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cube_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cube"
    # /home/szr/subquery/SQL2XML/YSmart.g:1014:1: k_cube : r= 'CUBE' ;
    def k_cube(self, ):

        retval = self.k_cube_return()
        retval.start = self.input.LT(1)
        k_cube_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 427):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1014:8: (r= 'CUBE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1014:10: r= 'CUBE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 414, self.FOLLOW_414_in_k_cube9186)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 427, k_cube_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cube"

    class k_cume_dist_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_cume_dist_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_cume_dist"
    # /home/szr/subquery/SQL2XML/YSmart.g:1015:1: k_cume_dist : r= 'CUME_DIST' ;
    def k_cume_dist(self, ):

        retval = self.k_cume_dist_return()
        retval.start = self.input.LT(1)
        k_cume_dist_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 428):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1015:13: (r= 'CUME_DIST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1015:15: r= 'CUME_DIST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 415, self.FOLLOW_415_in_k_cume_dist9199)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 428, k_cume_dist_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_cume_dist"

    class k_decrement_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_decrement_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_decrement"
    # /home/szr/subquery/SQL2XML/YSmart.g:1016:1: k_decrement : r= 'DECREMENT' ;
    def k_decrement(self, ):

        retval = self.k_decrement_return()
        retval.start = self.input.LT(1)
        k_decrement_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 429):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1016:13: (r= 'DECREMENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1016:15: r= 'DECREMENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 416, self.FOLLOW_416_in_k_decrement9212)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 429, k_decrement_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_decrement"

    class k_dense_rank_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dense_rank_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dense_rank"
    # /home/szr/subquery/SQL2XML/YSmart.g:1017:1: k_dense_rank : r= 'DENSE_RANK' ;
    def k_dense_rank(self, ):

        retval = self.k_dense_rank_return()
        retval.start = self.input.LT(1)
        k_dense_rank_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 430):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1017:14: (r= 'DENSE_RANK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1017:16: r= 'DENSE_RANK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 417, self.FOLLOW_417_in_k_dense_rank9225)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 430, k_dense_rank_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dense_rank"

    class k_dimension_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_dimension_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_dimension"
    # /home/szr/subquery/SQL2XML/YSmart.g:1018:1: k_dimension : r= 'DIMENSION' ;
    def k_dimension(self, ):

        retval = self.k_dimension_return()
        retval.start = self.input.LT(1)
        k_dimension_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 431):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1018:13: (r= 'DIMENSION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1018:15: r= 'DIMENSION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 418, self.FOLLOW_418_in_k_dimension9238)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 431, k_dimension_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_dimension"

    class k_empty_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_empty_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_empty"
    # /home/szr/subquery/SQL2XML/YSmart.g:1019:1: k_empty : r= 'EMPTY' ;
    def k_empty(self, ):

        retval = self.k_empty_return()
        retval.start = self.input.LT(1)
        k_empty_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 432):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1019:9: (r= 'EMPTY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1019:11: r= 'EMPTY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 419, self.FOLLOW_419_in_k_empty9251)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 432, k_empty_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_empty"

    class k_equals_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_equals_path_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_equals_path"
    # /home/szr/subquery/SQL2XML/YSmart.g:1020:1: k_equals_path : r= 'EQUALS_PATH' ;
    def k_equals_path(self, ):

        retval = self.k_equals_path_return()
        retval.start = self.input.LT(1)
        k_equals_path_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 433):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1020:15: (r= 'EQUALS_PATH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1020:17: r= 'EQUALS_PATH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 420, self.FOLLOW_420_in_k_equals_path9264)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 433, k_equals_path_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_equals_path"

    class k_first_value_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_first_value_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_first_value"
    # /home/szr/subquery/SQL2XML/YSmart.g:1021:1: k_first_value : r= 'FIRST_VALUE' ;
    def k_first_value(self, ):

        retval = self.k_first_value_return()
        retval.start = self.input.LT(1)
        k_first_value_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 434):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1021:15: (r= 'FIRST_VALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1021:17: r= 'FIRST_VALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 421, self.FOLLOW_421_in_k_first_value9277)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 434, k_first_value_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_first_value"

    class k_full_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_full_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_full"
    # /home/szr/subquery/SQL2XML/YSmart.g:1022:1: k_full : r= 'FULL' ;
    def k_full(self, ):

        retval = self.k_full_return()
        retval.start = self.input.LT(1)
        k_full_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 435):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1022:8: (r= 'FULL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1022:10: r= 'FULL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 422, self.FOLLOW_422_in_k_full9290)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 435, k_full_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_full"

    class k_grouping_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_grouping_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_grouping"
    # /home/szr/subquery/SQL2XML/YSmart.g:1023:1: k_grouping : r= 'GROUPING' ;
    def k_grouping(self, ):

        retval = self.k_grouping_return()
        retval.start = self.input.LT(1)
        k_grouping_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 436):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1023:12: (r= 'GROUPING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1023:14: r= 'GROUPING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 423, self.FOLLOW_423_in_k_grouping9303)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 436, k_grouping_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_grouping"

    class k_ignore_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_ignore_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_ignore"
    # /home/szr/subquery/SQL2XML/YSmart.g:1024:1: k_ignore : r= 'IGNORE' ;
    def k_ignore(self, ):

        retval = self.k_ignore_return()
        retval.start = self.input.LT(1)
        k_ignore_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 437):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1024:10: (r= 'IGNORE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1024:12: r= 'IGNORE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 424, self.FOLLOW_424_in_k_ignore9316)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 437, k_ignore_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_ignore"

    class k_infinite_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_infinite_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_infinite"
    # /home/szr/subquery/SQL2XML/YSmart.g:1025:1: k_infinite : r= 'INFINITE' ;
    def k_infinite(self, ):

        retval = self.k_infinite_return()
        retval.start = self.input.LT(1)
        k_infinite_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 438):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1025:12: (r= 'INFINITE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1025:14: r= 'INFINITE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 425, self.FOLLOW_425_in_k_infinite9329)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 438, k_infinite_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_infinite"

    class k_inner_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_inner_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_inner"
    # /home/szr/subquery/SQL2XML/YSmart.g:1026:1: k_inner : r= 'INNER' ;
    def k_inner(self, ):

        retval = self.k_inner_return()
        retval.start = self.input.LT(1)
        k_inner_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 439):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1026:9: (r= 'INNER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1026:11: r= 'INNER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 426, self.FOLLOW_426_in_k_inner9342)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 439, k_inner_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_inner"

    class k_interval_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_interval_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_interval"
    # /home/szr/subquery/SQL2XML/YSmart.g:1027:1: k_interval : r= 'INTERVAL' ;
    def k_interval(self, ):

        retval = self.k_interval_return()
        retval.start = self.input.LT(1)
        k_interval_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 440):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1027:12: (r= 'INTERVAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1027:14: r= 'INTERVAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 427, self.FOLLOW_427_in_k_interval9355)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 440, k_interval_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_interval"

    class k_iterate_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_iterate_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_iterate"
    # /home/szr/subquery/SQL2XML/YSmart.g:1028:1: k_iterate : r= 'ITERATE' ;
    def k_iterate(self, ):

        retval = self.k_iterate_return()
        retval.start = self.input.LT(1)
        k_iterate_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 441):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1028:11: (r= 'ITERATE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1028:13: r= 'ITERATE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 428, self.FOLLOW_428_in_k_iterate9368)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 441, k_iterate_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_iterate"

    class k_join_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_join_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_join"
    # /home/szr/subquery/SQL2XML/YSmart.g:1029:1: k_join : r= 'JOIN' ;
    def k_join(self, ):

        retval = self.k_join_return()
        retval.start = self.input.LT(1)
        k_join_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 442):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1029:8: (r= 'JOIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1029:10: r= 'JOIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 429, self.FOLLOW_429_in_k_join9381)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 442, k_join_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_join"

    class k_keep_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_keep_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_keep"
    # /home/szr/subquery/SQL2XML/YSmart.g:1030:1: k_keep : r= 'KEEP' ;
    def k_keep(self, ):

        retval = self.k_keep_return()
        retval.start = self.input.LT(1)
        k_keep_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 443):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1030:8: (r= 'KEEP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1030:10: r= 'KEEP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 430, self.FOLLOW_430_in_k_keep9394)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 443, k_keep_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_keep"

    class k_lag_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_lag_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_lag"
    # /home/szr/subquery/SQL2XML/YSmart.g:1031:1: k_lag : r= 'LAG' ;
    def k_lag(self, ):

        retval = self.k_lag_return()
        retval.start = self.input.LT(1)
        k_lag_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 444):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1031:7: (r= 'LAG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1031:9: r= 'LAG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 431, self.FOLLOW_431_in_k_lag9407)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 444, k_lag_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_lag"

    class k_last_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_last_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_last"
    # /home/szr/subquery/SQL2XML/YSmart.g:1032:1: k_last : r= 'LAST' ;
    def k_last(self, ):

        retval = self.k_last_return()
        retval.start = self.input.LT(1)
        k_last_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 445):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1032:8: (r= 'LAST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1032:10: r= 'LAST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 432, self.FOLLOW_432_in_k_last9420)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 445, k_last_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_last"

    class k_last_value_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_last_value_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_last_value"
    # /home/szr/subquery/SQL2XML/YSmart.g:1033:1: k_last_value : r= 'LAST_VALUE' ;
    def k_last_value(self, ):

        retval = self.k_last_value_return()
        retval.start = self.input.LT(1)
        k_last_value_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 446):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1033:14: (r= 'LAST_VALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1033:16: r= 'LAST_VALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 433, self.FOLLOW_433_in_k_last_value9433)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 446, k_last_value_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_last_value"

    class k_lead_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_lead_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_lead"
    # /home/szr/subquery/SQL2XML/YSmart.g:1034:1: k_lead : r= 'LEAD' ;
    def k_lead(self, ):

        retval = self.k_lead_return()
        retval.start = self.input.LT(1)
        k_lead_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 447):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1034:8: (r= 'LEAD' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1034:10: r= 'LEAD'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 434, self.FOLLOW_434_in_k_lead9446)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 447, k_lead_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_lead"

    class k_left_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_left_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_left"
    # /home/szr/subquery/SQL2XML/YSmart.g:1035:1: k_left : r= 'LEFT' ;
    def k_left(self, ):

        retval = self.k_left_return()
        retval.start = self.input.LT(1)
        k_left_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 448):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1035:8: (r= 'LEFT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1035:10: r= 'LEFT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 435, self.FOLLOW_435_in_k_left9459)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 448, k_left_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_left"

    class k_main_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_main_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_main"
    # /home/szr/subquery/SQL2XML/YSmart.g:1036:1: k_main : r= 'MAIN' ;
    def k_main(self, ):

        retval = self.k_main_return()
        retval.start = self.input.LT(1)
        k_main_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 449):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1036:8: (r= 'MAIN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1036:10: r= 'MAIN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 436, self.FOLLOW_436_in_k_main9472)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 449, k_main_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_main"

    class k_measures_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_measures_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_measures"
    # /home/szr/subquery/SQL2XML/YSmart.g:1037:1: k_measures : r= 'MEASURES' ;
    def k_measures(self, ):

        retval = self.k_measures_return()
        retval.start = self.input.LT(1)
        k_measures_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 450):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1037:12: (r= 'MEASURES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1037:14: r= 'MEASURES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 437, self.FOLLOW_437_in_k_measures9485)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 450, k_measures_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_measures"

    class k_member_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_member_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_member"
    # /home/szr/subquery/SQL2XML/YSmart.g:1038:1: k_member : r= 'MEMBER' ;
    def k_member(self, ):

        retval = self.k_member_return()
        retval.start = self.input.LT(1)
        k_member_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 451):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1038:10: (r= 'MEMBER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1038:12: r= 'MEMBER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 438, self.FOLLOW_438_in_k_member9498)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 451, k_member_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_member"

    class k_mlslabel_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_mlslabel_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_mlslabel"
    # /home/szr/subquery/SQL2XML/YSmart.g:1039:1: k_mlslabel : r= 'MLSLABEL' ;
    def k_mlslabel(self, ):

        retval = self.k_mlslabel_return()
        retval.start = self.input.LT(1)
        k_mlslabel_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 452):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1039:12: (r= 'MLSLABEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1039:14: r= 'MLSLABEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 439, self.FOLLOW_439_in_k_mlslabel9511)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 452, k_mlslabel_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_mlslabel"

    class k_model_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_model_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_model"
    # /home/szr/subquery/SQL2XML/YSmart.g:1040:1: k_model : r= 'MODEL' ;
    def k_model(self, ):

        retval = self.k_model_return()
        retval.start = self.input.LT(1)
        k_model_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 453):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1040:9: (r= 'MODEL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1040:11: r= 'MODEL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 440, self.FOLLOW_440_in_k_model9524)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 453, k_model_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_model"

    class k_multiset_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_multiset_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_multiset"
    # /home/szr/subquery/SQL2XML/YSmart.g:1041:1: k_multiset : r= 'MULTISET' ;
    def k_multiset(self, ):

        retval = self.k_multiset_return()
        retval.start = self.input.LT(1)
        k_multiset_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 454):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1041:12: (r= 'MULTISET' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1041:14: r= 'MULTISET'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 441, self.FOLLOW_441_in_k_multiset9537)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 454, k_multiset_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_multiset"

    class k_nan_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nan_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nan"
    # /home/szr/subquery/SQL2XML/YSmart.g:1042:1: k_nan : r= 'NAN' ;
    def k_nan(self, ):

        retval = self.k_nan_return()
        retval.start = self.input.LT(1)
        k_nan_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 455):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1042:7: (r= 'NAN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1042:9: r= 'NAN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 442, self.FOLLOW_442_in_k_nan9550)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 455, k_nan_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nan"

    class k_national_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_national_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_national"
    # /home/szr/subquery/SQL2XML/YSmart.g:1043:1: k_national : r= 'NATIONAL' ;
    def k_national(self, ):

        retval = self.k_national_return()
        retval.start = self.input.LT(1)
        k_national_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 456):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1043:12: (r= 'NATIONAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1043:14: r= 'NATIONAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 443, self.FOLLOW_443_in_k_national9563)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 456, k_national_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_national"

    class k_natural_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_natural_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_natural"
    # /home/szr/subquery/SQL2XML/YSmart.g:1044:1: k_natural : r= 'NATURAL' ;
    def k_natural(self, ):

        retval = self.k_natural_return()
        retval.start = self.input.LT(1)
        k_natural_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 457):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1044:11: (r= 'NATURAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1044:13: r= 'NATURAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 444, self.FOLLOW_444_in_k_natural9576)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 457, k_natural_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_natural"

    class k_nav_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nav_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nav"
    # /home/szr/subquery/SQL2XML/YSmart.g:1045:1: k_nav : r= 'NAV' ;
    def k_nav(self, ):

        retval = self.k_nav_return()
        retval.start = self.input.LT(1)
        k_nav_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 458):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1045:7: (r= 'NAV' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1045:9: r= 'NAV'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 445, self.FOLLOW_445_in_k_nav9589)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 458, k_nav_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nav"

    class k_nchar_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nchar_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nchar"
    # /home/szr/subquery/SQL2XML/YSmart.g:1046:1: k_nchar : r= 'NCHAR' ;
    def k_nchar(self, ):

        retval = self.k_nchar_return()
        retval.start = self.input.LT(1)
        k_nchar_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 459):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1046:9: (r= 'NCHAR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1046:11: r= 'NCHAR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 446, self.FOLLOW_446_in_k_nchar9602)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 459, k_nchar_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nchar"

    class k_nclob_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nclob_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nclob"
    # /home/szr/subquery/SQL2XML/YSmart.g:1047:1: k_nclob : r= 'NCLOB' ;
    def k_nclob(self, ):

        retval = self.k_nclob_return()
        retval.start = self.input.LT(1)
        k_nclob_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 460):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1047:9: (r= 'NCLOB' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1047:11: r= 'NCLOB'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 447, self.FOLLOW_447_in_k_nclob9615)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 460, k_nclob_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nclob"

    class k_ntile_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_ntile_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_ntile"
    # /home/szr/subquery/SQL2XML/YSmart.g:1048:1: k_ntile : r= 'NTILE' ;
    def k_ntile(self, ):

        retval = self.k_ntile_return()
        retval.start = self.input.LT(1)
        k_ntile_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 461):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1048:9: (r= 'NTILE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1048:11: r= 'NTILE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 448, self.FOLLOW_448_in_k_ntile9628)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 461, k_ntile_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_ntile"

    class k_nulls_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nulls_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nulls"
    # /home/szr/subquery/SQL2XML/YSmart.g:1049:1: k_nulls : r= 'NULLS' ;
    def k_nulls(self, ):

        retval = self.k_nulls_return()
        retval.start = self.input.LT(1)
        k_nulls_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 462):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1049:9: (r= 'NULLS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1049:11: r= 'NULLS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 449, self.FOLLOW_449_in_k_nulls9641)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 462, k_nulls_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nulls"

    class k_nvarchar_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nvarchar_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nvarchar"
    # /home/szr/subquery/SQL2XML/YSmart.g:1050:1: k_nvarchar : r= 'NVARCHAR' ;
    def k_nvarchar(self, ):

        retval = self.k_nvarchar_return()
        retval.start = self.input.LT(1)
        k_nvarchar_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 463):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1050:12: (r= 'NVARCHAR' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1050:14: r= 'NVARCHAR'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 450, self.FOLLOW_450_in_k_nvarchar9654)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 463, k_nvarchar_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nvarchar"

    class k_nvarchar2_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_nvarchar2_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_nvarchar2"
    # /home/szr/subquery/SQL2XML/YSmart.g:1051:1: k_nvarchar2 : r= 'NVARCHAR2' ;
    def k_nvarchar2(self, ):

        retval = self.k_nvarchar2_return()
        retval.start = self.input.LT(1)
        k_nvarchar2_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 464):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1051:13: (r= 'NVARCHAR2' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1051:15: r= 'NVARCHAR2'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 451, self.FOLLOW_451_in_k_nvarchar29667)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 464, k_nvarchar2_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_nvarchar2"

    class k_object_value_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_object_value_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_object_value"
    # /home/szr/subquery/SQL2XML/YSmart.g:1052:1: k_object_value : r= 'OBJECT_VALUE' ;
    def k_object_value(self, ):

        retval = self.k_object_value_return()
        retval.start = self.input.LT(1)
        k_object_value_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 465):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1052:16: (r= 'OBJECT_VALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1052:18: r= 'OBJECT_VALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 452, self.FOLLOW_452_in_k_object_value9680)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 465, k_object_value_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_object_value"

    class k_ora_rowscn_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_ora_rowscn_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_ora_rowscn"
    # /home/szr/subquery/SQL2XML/YSmart.g:1053:1: k_ora_rowscn : r= 'ORA_ROWSCN' ;
    def k_ora_rowscn(self, ):

        retval = self.k_ora_rowscn_return()
        retval.start = self.input.LT(1)
        k_ora_rowscn_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 466):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1053:14: (r= 'ORA_ROWSCN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1053:16: r= 'ORA_ROWSCN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 453, self.FOLLOW_453_in_k_ora_rowscn9693)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 466, k_ora_rowscn_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_ora_rowscn"

    class k_outer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_outer_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_outer"
    # /home/szr/subquery/SQL2XML/YSmart.g:1054:1: k_outer : r= 'OUTER' ;
    def k_outer(self, ):

        retval = self.k_outer_return()
        retval.start = self.input.LT(1)
        k_outer_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 467):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1054:9: (r= 'OUTER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1054:11: r= 'OUTER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 454, self.FOLLOW_454_in_k_outer9706)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 467, k_outer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_outer"

    class k_over_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_over_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_over"
    # /home/szr/subquery/SQL2XML/YSmart.g:1055:1: k_over : r= 'OVER' ;
    def k_over(self, ):

        retval = self.k_over_return()
        retval.start = self.input.LT(1)
        k_over_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 468):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1055:8: (r= 'OVER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1055:10: r= 'OVER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 455, self.FOLLOW_455_in_k_over9719)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 468, k_over_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_over"

    class k_partition_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_partition_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_partition"
    # /home/szr/subquery/SQL2XML/YSmart.g:1056:1: k_partition : r= 'PARTITION' ;
    def k_partition(self, ):

        retval = self.k_partition_return()
        retval.start = self.input.LT(1)
        k_partition_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 469):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1056:13: (r= 'PARTITION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1056:15: r= 'PARTITION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 456, self.FOLLOW_456_in_k_partition9732)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 469, k_partition_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_partition"

    class k_percentile_cont_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_percentile_cont_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_percentile_cont"
    # /home/szr/subquery/SQL2XML/YSmart.g:1057:1: k_percentile_cont : r= 'PERCENTILE_CONT' ;
    def k_percentile_cont(self, ):

        retval = self.k_percentile_cont_return()
        retval.start = self.input.LT(1)
        k_percentile_cont_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 470):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1057:19: (r= 'PERCENTILE_CONT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1057:21: r= 'PERCENTILE_CONT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 457, self.FOLLOW_457_in_k_percentile_cont9745)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 470, k_percentile_cont_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_percentile_cont"

    class k_percentile_disc_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_percentile_disc_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_percentile_disc"
    # /home/szr/subquery/SQL2XML/YSmart.g:1058:1: k_percentile_disc : r= 'PERCENTILE_DISC' ;
    def k_percentile_disc(self, ):

        retval = self.k_percentile_disc_return()
        retval.start = self.input.LT(1)
        k_percentile_disc_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 471):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1058:19: (r= 'PERCENTILE_DISC' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1058:21: r= 'PERCENTILE_DISC'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 458, self.FOLLOW_458_in_k_percentile_disc9758)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 471, k_percentile_disc_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_percentile_disc"

    class k_percent_rank_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_percent_rank_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_percent_rank"
    # /home/szr/subquery/SQL2XML/YSmart.g:1059:1: k_percent_rank : r= 'PERCENT_RANK' ;
    def k_percent_rank(self, ):

        retval = self.k_percent_rank_return()
        retval.start = self.input.LT(1)
        k_percent_rank_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 472):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1059:16: (r= 'PERCENT_RANK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1059:18: r= 'PERCENT_RANK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 459, self.FOLLOW_459_in_k_percent_rank9771)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 472, k_percent_rank_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_percent_rank"

    class k_pivot_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pivot_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pivot"
    # /home/szr/subquery/SQL2XML/YSmart.g:1060:1: k_pivot : r= 'PIVOT' ;
    def k_pivot(self, ):

        retval = self.k_pivot_return()
        retval.start = self.input.LT(1)
        k_pivot_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 473):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1060:9: (r= 'PIVOT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1060:11: r= 'PIVOT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 460, self.FOLLOW_460_in_k_pivot9784)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 473, k_pivot_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pivot"

    class k_pls_integer_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_pls_integer_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_pls_integer"
    # /home/szr/subquery/SQL2XML/YSmart.g:1061:1: k_pls_integer : r= 'PLS_INTEGER' ;
    def k_pls_integer(self, ):

        retval = self.k_pls_integer_return()
        retval.start = self.input.LT(1)
        k_pls_integer_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 474):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1061:15: (r= 'PLS_INTEGER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1061:17: r= 'PLS_INTEGER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 461, self.FOLLOW_461_in_k_pls_integer9797)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 474, k_pls_integer_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_pls_integer"

    class k_positive_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_positive_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_positive"
    # /home/szr/subquery/SQL2XML/YSmart.g:1062:1: k_positive : r= 'POSITIVE' ;
    def k_positive(self, ):

        retval = self.k_positive_return()
        retval.start = self.input.LT(1)
        k_positive_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 475):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1062:12: (r= 'POSITIVE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1062:14: r= 'POSITIVE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 462, self.FOLLOW_462_in_k_positive9810)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 475, k_positive_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_positive"

    class k_present_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_present_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_present"
    # /home/szr/subquery/SQL2XML/YSmart.g:1063:1: k_present : r= 'PRESENT' ;
    def k_present(self, ):

        retval = self.k_present_return()
        retval.start = self.input.LT(1)
        k_present_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 476):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1063:11: (r= 'PRESENT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1063:13: r= 'PRESENT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 463, self.FOLLOW_463_in_k_present9823)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 476, k_present_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_present"

    class k_rank_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rank_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rank"
    # /home/szr/subquery/SQL2XML/YSmart.g:1064:1: k_rank : r= 'RANK' ;
    def k_rank(self, ):

        retval = self.k_rank_return()
        retval.start = self.input.LT(1)
        k_rank_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 477):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1064:8: (r= 'RANK' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1064:10: r= 'RANK'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 464, self.FOLLOW_464_in_k_rank9836)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 477, k_rank_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rank"

    class k_ratio_to_report_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_ratio_to_report_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_ratio_to_report"
    # /home/szr/subquery/SQL2XML/YSmart.g:1065:1: k_ratio_to_report : r= 'RATIO_TO_REPORT' ;
    def k_ratio_to_report(self, ):

        retval = self.k_ratio_to_report_return()
        retval.start = self.input.LT(1)
        k_ratio_to_report_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 478):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1065:19: (r= 'RATIO_TO_REPORT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1065:21: r= 'RATIO_TO_REPORT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 465, self.FOLLOW_465_in_k_ratio_to_report9849)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 478, k_ratio_to_report_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_ratio_to_report"

    class k_reference_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_reference_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_reference"
    # /home/szr/subquery/SQL2XML/YSmart.g:1066:1: k_reference : r= 'REFERENCE' ;
    def k_reference(self, ):

        retval = self.k_reference_return()
        retval.start = self.input.LT(1)
        k_reference_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 479):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1066:13: (r= 'REFERENCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1066:15: r= 'REFERENCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 466, self.FOLLOW_466_in_k_reference9862)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 479, k_reference_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_reference"

    class k_regexp_like_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regexp_like_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regexp_like"
    # /home/szr/subquery/SQL2XML/YSmart.g:1067:1: k_regexp_like : r= 'REGEXP_LIKE' ;
    def k_regexp_like(self, ):

        retval = self.k_regexp_like_return()
        retval.start = self.input.LT(1)
        k_regexp_like_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 480):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1067:15: (r= 'REGEXP_LIKE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1067:17: r= 'REGEXP_LIKE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 467, self.FOLLOW_467_in_k_regexp_like9875)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 480, k_regexp_like_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regexp_like"

    class k_regr_avgx_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_avgx_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_avgx"
    # /home/szr/subquery/SQL2XML/YSmart.g:1068:1: k_regr_avgx : r= 'REGR_AVGX' ;
    def k_regr_avgx(self, ):

        retval = self.k_regr_avgx_return()
        retval.start = self.input.LT(1)
        k_regr_avgx_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 481):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1068:13: (r= 'REGR_AVGX' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1068:15: r= 'REGR_AVGX'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 468, self.FOLLOW_468_in_k_regr_avgx9888)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 481, k_regr_avgx_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_avgx"

    class k_regr_avgy_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_avgy_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_avgy"
    # /home/szr/subquery/SQL2XML/YSmart.g:1069:1: k_regr_avgy : r= 'REGR_AVGY' ;
    def k_regr_avgy(self, ):

        retval = self.k_regr_avgy_return()
        retval.start = self.input.LT(1)
        k_regr_avgy_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 482):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1069:13: (r= 'REGR_AVGY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1069:15: r= 'REGR_AVGY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 469, self.FOLLOW_469_in_k_regr_avgy9901)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 482, k_regr_avgy_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_avgy"

    class k_regr_count_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_count_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_count"
    # /home/szr/subquery/SQL2XML/YSmart.g:1070:1: k_regr_count : r= 'REGR_COUNT' ;
    def k_regr_count(self, ):

        retval = self.k_regr_count_return()
        retval.start = self.input.LT(1)
        k_regr_count_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 483):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1070:14: (r= 'REGR_COUNT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1070:16: r= 'REGR_COUNT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 470, self.FOLLOW_470_in_k_regr_count9914)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 483, k_regr_count_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_count"

    class k_regr_intercept_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_intercept_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_intercept"
    # /home/szr/subquery/SQL2XML/YSmart.g:1071:1: k_regr_intercept : r= 'REGR_INTERCEPT' ;
    def k_regr_intercept(self, ):

        retval = self.k_regr_intercept_return()
        retval.start = self.input.LT(1)
        k_regr_intercept_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 484):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1071:18: (r= 'REGR_INTERCEPT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1071:20: r= 'REGR_INTERCEPT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 471, self.FOLLOW_471_in_k_regr_intercept9927)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 484, k_regr_intercept_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_intercept"

    class k_regr_r2_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_r2_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_r2"
    # /home/szr/subquery/SQL2XML/YSmart.g:1072:1: k_regr_r2 : r= 'REGR_R2' ;
    def k_regr_r2(self, ):

        retval = self.k_regr_r2_return()
        retval.start = self.input.LT(1)
        k_regr_r2_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 485):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1072:11: (r= 'REGR_R2' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1072:13: r= 'REGR_R2'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 472, self.FOLLOW_472_in_k_regr_r29940)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 485, k_regr_r2_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_r2"

    class k_regr_slope_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_slope_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_slope"
    # /home/szr/subquery/SQL2XML/YSmart.g:1073:1: k_regr_slope : r= 'REGR_SLOPE' ;
    def k_regr_slope(self, ):

        retval = self.k_regr_slope_return()
        retval.start = self.input.LT(1)
        k_regr_slope_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 486):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1073:14: (r= 'REGR_SLOPE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1073:16: r= 'REGR_SLOPE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 473, self.FOLLOW_473_in_k_regr_slope9953)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 486, k_regr_slope_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_slope"

    class k_regr_sxx_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_sxx_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_sxx"
    # /home/szr/subquery/SQL2XML/YSmart.g:1074:1: k_regr_sxx : r= 'REGR_SXX' ;
    def k_regr_sxx(self, ):

        retval = self.k_regr_sxx_return()
        retval.start = self.input.LT(1)
        k_regr_sxx_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 487):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1074:12: (r= 'REGR_SXX' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1074:14: r= 'REGR_SXX'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 474, self.FOLLOW_474_in_k_regr_sxx9966)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 487, k_regr_sxx_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_sxx"

    class k_regr_sxy_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_sxy_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_sxy"
    # /home/szr/subquery/SQL2XML/YSmart.g:1075:1: k_regr_sxy : r= 'REGR_SXY' ;
    def k_regr_sxy(self, ):

        retval = self.k_regr_sxy_return()
        retval.start = self.input.LT(1)
        k_regr_sxy_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 488):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1075:12: (r= 'REGR_SXY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1075:14: r= 'REGR_SXY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 475, self.FOLLOW_475_in_k_regr_sxy9979)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 488, k_regr_sxy_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_sxy"

    class k_regr_syy_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_regr_syy_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_regr_syy"
    # /home/szr/subquery/SQL2XML/YSmart.g:1076:1: k_regr_syy : r= 'REGR_SYY' ;
    def k_regr_syy(self, ):

        retval = self.k_regr_syy_return()
        retval.start = self.input.LT(1)
        k_regr_syy_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 489):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1076:12: (r= 'REGR_SYY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1076:14: r= 'REGR_SYY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 476, self.FOLLOW_476_in_k_regr_syy9992)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 489, k_regr_syy_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_regr_syy"

    class k_right_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_right_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_right"
    # /home/szr/subquery/SQL2XML/YSmart.g:1077:1: k_right : r= 'RIGHT' ;
    def k_right(self, ):

        retval = self.k_right_return()
        retval.start = self.input.LT(1)
        k_right_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 490):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1077:9: (r= 'RIGHT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1077:11: r= 'RIGHT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 477, self.FOLLOW_477_in_k_right10005)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 490, k_right_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_right"

    class k_rollup_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rollup_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rollup"
    # /home/szr/subquery/SQL2XML/YSmart.g:1078:1: k_rollup : r= 'ROLLUP' ;
    def k_rollup(self, ):

        retval = self.k_rollup_return()
        retval.start = self.input.LT(1)
        k_rollup_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 491):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1078:10: (r= 'ROLLUP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1078:12: r= 'ROLLUP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 478, self.FOLLOW_478_in_k_rollup10018)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 491, k_rollup_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rollup"

    class k_row_number_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_row_number_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_row_number"
    # /home/szr/subquery/SQL2XML/YSmart.g:1079:1: k_row_number : r= 'ROW_NUMBER' ;
    def k_row_number(self, ):

        retval = self.k_row_number_return()
        retval.start = self.input.LT(1)
        k_row_number_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 492):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1079:14: (r= 'ROW_NUMBER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1079:16: r= 'ROW_NUMBER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 479, self.FOLLOW_479_in_k_row_number10031)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 492, k_row_number_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_row_number"

    class k_rules_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_rules_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_rules"
    # /home/szr/subquery/SQL2XML/YSmart.g:1080:1: k_rules : r= 'RULES' ;
    def k_rules(self, ):

        retval = self.k_rules_return()
        retval.start = self.input.LT(1)
        k_rules_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 493):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1080:9: (r= 'RULES' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1080:11: r= 'RULES'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 480, self.FOLLOW_480_in_k_rules10044)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 493, k_rules_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_rules"

    class k_sample_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sample_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sample"
    # /home/szr/subquery/SQL2XML/YSmart.g:1081:1: k_sample : r= 'SAMPLE' ;
    def k_sample(self, ):

        retval = self.k_sample_return()
        retval.start = self.input.LT(1)
        k_sample_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 494):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1081:10: (r= 'SAMPLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1081:12: r= 'SAMPLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 481, self.FOLLOW_481_in_k_sample10057)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 494, k_sample_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sample"

    class k_search_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_search_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_search"
    # /home/szr/subquery/SQL2XML/YSmart.g:1082:1: k_search : r= 'SEARCH' ;
    def k_search(self, ):

        retval = self.k_search_return()
        retval.start = self.input.LT(1)
        k_search_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 495):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1082:10: (r= 'SEARCH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1082:12: r= 'SEARCH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 482, self.FOLLOW_482_in_k_search10070)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 495, k_search_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_search"

    class k_sequential_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sequential_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sequential"
    # /home/szr/subquery/SQL2XML/YSmart.g:1083:1: k_sequential : r= 'SEQUENTIAL' ;
    def k_sequential(self, ):

        retval = self.k_sequential_return()
        retval.start = self.input.LT(1)
        k_sequential_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 496):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1083:14: (r= 'SEQUENTIAL' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1083:16: r= 'SEQUENTIAL'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 483, self.FOLLOW_483_in_k_sequential10083)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 496, k_sequential_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sequential"

    class k_sets_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_sets_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_sets"
    # /home/szr/subquery/SQL2XML/YSmart.g:1084:1: k_sets : r= 'SETS' ;
    def k_sets(self, ):

        retval = self.k_sets_return()
        retval.start = self.input.LT(1)
        k_sets_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 497):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1084:8: (r= 'SETS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1084:10: r= 'SETS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 484, self.FOLLOW_484_in_k_sets10096)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 497, k_sets_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_sets"

    class k_single_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_single_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_single"
    # /home/szr/subquery/SQL2XML/YSmart.g:1085:1: k_single : r= 'SINGLE' ;
    def k_single(self, ):

        retval = self.k_single_return()
        retval.start = self.input.LT(1)
        k_single_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 498):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1085:10: (r= 'SINGLE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1085:12: r= 'SINGLE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 485, self.FOLLOW_485_in_k_single10109)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 498, k_single_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_single"

    class k_stddev_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_stddev_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_stddev"
    # /home/szr/subquery/SQL2XML/YSmart.g:1086:1: k_stddev : r= 'STDDEV' ;
    def k_stddev(self, ):

        retval = self.k_stddev_return()
        retval.start = self.input.LT(1)
        k_stddev_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 499):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1086:10: (r= 'STDDEV' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1086:12: r= 'STDDEV'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 486, self.FOLLOW_486_in_k_stddev10122)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 499, k_stddev_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_stddev"

    class k_stddev_pop_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_stddev_pop_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_stddev_pop"
    # /home/szr/subquery/SQL2XML/YSmart.g:1087:1: k_stddev_pop : r= 'STDDEV_POP' ;
    def k_stddev_pop(self, ):

        retval = self.k_stddev_pop_return()
        retval.start = self.input.LT(1)
        k_stddev_pop_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 500):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1087:14: (r= 'STDDEV_POP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1087:16: r= 'STDDEV_POP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 487, self.FOLLOW_487_in_k_stddev_pop10135)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 500, k_stddev_pop_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_stddev_pop"

    class k_stddev_samp_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_stddev_samp_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_stddev_samp"
    # /home/szr/subquery/SQL2XML/YSmart.g:1088:1: k_stddev_samp : r= 'STDDEV_SAMP' ;
    def k_stddev_samp(self, ):

        retval = self.k_stddev_samp_return()
        retval.start = self.input.LT(1)
        k_stddev_samp_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 501):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1088:15: (r= 'STDDEV_SAMP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1088:17: r= 'STDDEV_SAMP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 488, self.FOLLOW_488_in_k_stddev_samp10148)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 501, k_stddev_samp_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_stddev_samp"

    class k_submultiset_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_submultiset_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_submultiset"
    # /home/szr/subquery/SQL2XML/YSmart.g:1089:1: k_submultiset : r= 'SUBMULTISET' ;
    def k_submultiset(self, ):

        retval = self.k_submultiset_return()
        retval.start = self.input.LT(1)
        k_submultiset_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 502):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1089:15: (r= 'SUBMULTISET' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1089:17: r= 'SUBMULTISET'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 489, self.FOLLOW_489_in_k_submultiset10161)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 502, k_submultiset_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_submultiset"

    class k_subpartition_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_subpartition_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_subpartition"
    # /home/szr/subquery/SQL2XML/YSmart.g:1090:1: k_subpartition : r= 'SUBPARTITION' ;
    def k_subpartition(self, ):

        retval = self.k_subpartition_return()
        retval.start = self.input.LT(1)
        k_subpartition_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 503):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1090:16: (r= 'SUBPARTITION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1090:18: r= 'SUBPARTITION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 490, self.FOLLOW_490_in_k_subpartition10174)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 503, k_subpartition_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_subpartition"

    class k_the_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_the_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_the"
    # /home/szr/subquery/SQL2XML/YSmart.g:1091:1: k_the : r= 'THE' ;
    def k_the(self, ):

        retval = self.k_the_return()
        retval.start = self.input.LT(1)
        k_the_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 504):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1091:7: (r= 'THE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1091:9: r= 'THE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 491, self.FOLLOW_491_in_k_the10187)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 504, k_the_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_the"

    class k_timestamp_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_timestamp_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_timestamp"
    # /home/szr/subquery/SQL2XML/YSmart.g:1092:1: k_timestamp : r= 'TIMESTAMP' ;
    def k_timestamp(self, ):

        retval = self.k_timestamp_return()
        retval.start = self.input.LT(1)
        k_timestamp_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 505):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1092:13: (r= 'TIMESTAMP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1092:15: r= 'TIMESTAMP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 492, self.FOLLOW_492_in_k_timestamp10200)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 505, k_timestamp_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_timestamp"

    class k_type_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_type_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_type"
    # /home/szr/subquery/SQL2XML/YSmart.g:1093:1: k_type : r= 'TYPE' ;
    def k_type(self, ):

        retval = self.k_type_return()
        retval.start = self.input.LT(1)
        k_type_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 506):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1093:8: (r= 'TYPE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1093:10: r= 'TYPE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 493, self.FOLLOW_493_in_k_type10213)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 506, k_type_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_type"

    class k_unbounded_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_unbounded_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_unbounded"
    # /home/szr/subquery/SQL2XML/YSmart.g:1094:1: k_unbounded : r= 'UNBOUNDED' ;
    def k_unbounded(self, ):

        retval = self.k_unbounded_return()
        retval.start = self.input.LT(1)
        k_unbounded_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 507):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1094:13: (r= 'UNBOUNDED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1094:15: r= 'UNBOUNDED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 494, self.FOLLOW_494_in_k_unbounded10226)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 507, k_unbounded_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_unbounded"

    class k_under_path_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_under_path_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_under_path"
    # /home/szr/subquery/SQL2XML/YSmart.g:1095:1: k_under_path : r= 'UNDER_PATH' ;
    def k_under_path(self, ):

        retval = self.k_under_path_return()
        retval.start = self.input.LT(1)
        k_under_path_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 508):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1095:14: (r= 'UNDER_PATH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1095:16: r= 'UNDER_PATH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 495, self.FOLLOW_495_in_k_under_path10239)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 508, k_under_path_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_under_path"

    class k_updated_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_updated_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_updated"
    # /home/szr/subquery/SQL2XML/YSmart.g:1096:1: k_updated : r= 'UPDATED' ;
    def k_updated(self, ):

        retval = self.k_updated_return()
        retval.start = self.input.LT(1)
        k_updated_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 509):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1096:11: (r= 'UPDATED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1096:13: r= 'UPDATED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 496, self.FOLLOW_496_in_k_updated10252)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 509, k_updated_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_updated"

    class k_upsert_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_upsert_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_upsert"
    # /home/szr/subquery/SQL2XML/YSmart.g:1097:1: k_upsert : r= 'UPSERT' ;
    def k_upsert(self, ):

        retval = self.k_upsert_return()
        retval.start = self.input.LT(1)
        k_upsert_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 510):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1097:10: (r= 'UPSERT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1097:12: r= 'UPSERT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 497, self.FOLLOW_497_in_k_upsert10265)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 510, k_upsert_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_upsert"

    class k_urowid_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_urowid_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_urowid"
    # /home/szr/subquery/SQL2XML/YSmart.g:1098:1: k_urowid : r= 'UROWID' ;
    def k_urowid(self, ):

        retval = self.k_urowid_return()
        retval.start = self.input.LT(1)
        k_urowid_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 511):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1098:10: (r= 'UROWID' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1098:12: r= 'UROWID'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 498, self.FOLLOW_498_in_k_urowid10278)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 511, k_urowid_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_urowid"

    class k_variance_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_variance_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_variance"
    # /home/szr/subquery/SQL2XML/YSmart.g:1099:1: k_variance : r= 'VARIANCE' ;
    def k_variance(self, ):

        retval = self.k_variance_return()
        retval.start = self.input.LT(1)
        k_variance_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 512):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1099:12: (r= 'VARIANCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1099:14: r= 'VARIANCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 499, self.FOLLOW_499_in_k_variance10291)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 512, k_variance_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_variance"

    class k_varying_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_varying_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_varying"
    # /home/szr/subquery/SQL2XML/YSmart.g:1100:1: k_varying : r= 'VARYING' ;
    def k_varying(self, ):

        retval = self.k_varying_return()
        retval.start = self.input.LT(1)
        k_varying_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 513):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1100:11: (r= 'VARYING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1100:13: r= 'VARYING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 500, self.FOLLOW_500_in_k_varying10304)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 513, k_varying_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_varying"

    class k_var_pop_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_var_pop_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_var_pop"
    # /home/szr/subquery/SQL2XML/YSmart.g:1101:1: k_var_pop : r= 'VAR_POP' ;
    def k_var_pop(self, ):

        retval = self.k_var_pop_return()
        retval.start = self.input.LT(1)
        k_var_pop_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 514):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1101:11: (r= 'VAR_POP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1101:13: r= 'VAR_POP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 501, self.FOLLOW_501_in_k_var_pop10317)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 514, k_var_pop_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_var_pop"

    class k_var_samp_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_var_samp_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_var_samp"
    # /home/szr/subquery/SQL2XML/YSmart.g:1102:1: k_var_samp : r= 'VAR_SAMP' ;
    def k_var_samp(self, ):

        retval = self.k_var_samp_return()
        retval.start = self.input.LT(1)
        k_var_samp_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 515):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1102:12: (r= 'VAR_SAMP' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1102:14: r= 'VAR_SAMP'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 502, self.FOLLOW_502_in_k_var_samp10330)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 515, k_var_samp_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_var_samp"

    class k_versions_endscn_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_endscn_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_endscn"
    # /home/szr/subquery/SQL2XML/YSmart.g:1103:1: k_versions_endscn : r= 'VERSIONS_ENDSCN' ;
    def k_versions_endscn(self, ):

        retval = self.k_versions_endscn_return()
        retval.start = self.input.LT(1)
        k_versions_endscn_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 516):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1103:19: (r= 'VERSIONS_ENDSCN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1103:21: r= 'VERSIONS_ENDSCN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 503, self.FOLLOW_503_in_k_versions_endscn10343)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 516, k_versions_endscn_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_endscn"

    class k_versions_endtime_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_endtime_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_endtime"
    # /home/szr/subquery/SQL2XML/YSmart.g:1104:1: k_versions_endtime : r= 'VERSIONS_ENDTIME' ;
    def k_versions_endtime(self, ):

        retval = self.k_versions_endtime_return()
        retval.start = self.input.LT(1)
        k_versions_endtime_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 517):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1104:20: (r= 'VERSIONS_ENDTIME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1104:22: r= 'VERSIONS_ENDTIME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 504, self.FOLLOW_504_in_k_versions_endtime10356)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 517, k_versions_endtime_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_endtime"

    class k_versions_operation_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_operation_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_operation"
    # /home/szr/subquery/SQL2XML/YSmart.g:1105:1: k_versions_operation : r= 'VERSIONS_OPERATION' ;
    def k_versions_operation(self, ):

        retval = self.k_versions_operation_return()
        retval.start = self.input.LT(1)
        k_versions_operation_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 518):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1105:22: (r= 'VERSIONS_OPERATION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1105:24: r= 'VERSIONS_OPERATION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 505, self.FOLLOW_505_in_k_versions_operation10369)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 518, k_versions_operation_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_operation"

    class k_versions_starscn_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_starscn_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_starscn"
    # /home/szr/subquery/SQL2XML/YSmart.g:1106:1: k_versions_starscn : r= 'VERSIONS_STARSCN' ;
    def k_versions_starscn(self, ):

        retval = self.k_versions_starscn_return()
        retval.start = self.input.LT(1)
        k_versions_starscn_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 519):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1106:20: (r= 'VERSIONS_STARSCN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1106:22: r= 'VERSIONS_STARSCN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 506, self.FOLLOW_506_in_k_versions_starscn10382)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 519, k_versions_starscn_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_starscn"

    class k_versions_starttime_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_starttime_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_starttime"
    # /home/szr/subquery/SQL2XML/YSmart.g:1107:1: k_versions_starttime : r= 'VERSIONS_STARTTIME' ;
    def k_versions_starttime(self, ):

        retval = self.k_versions_starttime_return()
        retval.start = self.input.LT(1)
        k_versions_starttime_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 520):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1107:22: (r= 'VERSIONS_STARTTIME' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1107:24: r= 'VERSIONS_STARTTIME'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 507, self.FOLLOW_507_in_k_versions_starttime10395)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 520, k_versions_starttime_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_starttime"

    class k_versions_xid_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_xid_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions_xid"
    # /home/szr/subquery/SQL2XML/YSmart.g:1108:1: k_versions_xid : r= 'VERSIONS_XID' ;
    def k_versions_xid(self, ):

        retval = self.k_versions_xid_return()
        retval.start = self.input.LT(1)
        k_versions_xid_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 521):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1108:16: (r= 'VERSIONS_XID' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1108:18: r= 'VERSIONS_XID'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 508, self.FOLLOW_508_in_k_versions_xid10408)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 521, k_versions_xid_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions_xid"

    class k_xml_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_xml_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_xml"
    # /home/szr/subquery/SQL2XML/YSmart.g:1109:1: k_xml : r= 'XML' ;
    def k_xml(self, ):

        retval = self.k_xml_return()
        retval.start = self.input.LT(1)
        k_xml_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 522):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1109:7: (r= 'XML' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1109:9: r= 'XML'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 509, self.FOLLOW_509_in_k_xml10421)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 522, k_xml_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_xml"

    class k_xmldata_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_xmldata_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_xmldata"
    # /home/szr/subquery/SQL2XML/YSmart.g:1110:1: k_xmldata : r= 'XMLDATA' ;
    def k_xmldata(self, ):

        retval = self.k_xmldata_return()
        retval.start = self.input.LT(1)
        k_xmldata_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 523):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1110:11: (r= 'XMLDATA' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1110:13: r= 'XMLDATA'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 510, self.FOLLOW_510_in_k_xmldata10434)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 523, k_xmldata_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_xmldata"

    class k_errors_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_errors_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_errors"
    # /home/szr/subquery/SQL2XML/YSmart.g:1112:1: k_errors : r= 'ERRORS' ;
    def k_errors(self, ):

        retval = self.k_errors_return()
        retval.start = self.input.LT(1)
        k_errors_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 524):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1112:10: (r= 'ERRORS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1112:12: r= 'ERRORS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 511, self.FOLLOW_511_in_k_errors10448)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 524, k_errors_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_errors"

    class k_first_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_first_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_first"
    # /home/szr/subquery/SQL2XML/YSmart.g:1113:1: k_first : r= 'FIRST' ;
    def k_first(self, ):

        retval = self.k_first_return()
        retval.start = self.input.LT(1)
        k_first_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 525):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1113:9: (r= 'FIRST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1113:11: r= 'FIRST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 512, self.FOLLOW_512_in_k_first10461)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 525, k_first_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_first"

    class k_limit_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_limit_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_limit"
    # /home/szr/subquery/SQL2XML/YSmart.g:1114:1: k_limit : r= 'LIMIT' ;
    def k_limit(self, ):

        retval = self.k_limit_return()
        retval.start = self.input.LT(1)
        k_limit_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 526):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1114:9: (r= 'LIMIT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1114:11: r= 'LIMIT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 513, self.FOLLOW_513_in_k_limit10474)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 526, k_limit_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_limit"

    class k_log_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_log_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_log"
    # /home/szr/subquery/SQL2XML/YSmart.g:1115:1: k_log : r= 'LOG' ;
    def k_log(self, ):

        retval = self.k_log_return()
        retval.start = self.input.LT(1)
        k_log_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 527):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1115:7: (r= 'LOG' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1115:9: r= 'LOG'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 514, self.FOLLOW_514_in_k_log10487)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 527, k_log_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_log"

    class k_reject_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_reject_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_reject"
    # /home/szr/subquery/SQL2XML/YSmart.g:1116:1: k_reject : r= 'REJECT' ;
    def k_reject(self, ):

        retval = self.k_reject_return()
        retval.start = self.input.LT(1)
        k_reject_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 528):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1116:10: (r= 'REJECT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1116:12: r= 'REJECT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 515, self.FOLLOW_515_in_k_reject10500)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 528, k_reject_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_reject"

    class k_return_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_return_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_return"
    # /home/szr/subquery/SQL2XML/YSmart.g:1117:1: k_return : r= 'RETURN' ;
    def k_return(self, ):

        retval = self.k_return_return()
        retval.start = self.input.LT(1)
        k_return_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 529):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1117:10: (r= 'RETURN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1117:12: r= 'RETURN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 516, self.FOLLOW_516_in_k_return10513)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 529, k_return_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_return"

    class k_returning_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_returning_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_returning"
    # /home/szr/subquery/SQL2XML/YSmart.g:1118:1: k_returning : r= 'RETURNING' ;
    def k_returning(self, ):

        retval = self.k_returning_return()
        retval.start = self.input.LT(1)
        k_returning_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 530):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1118:13: (r= 'RETURNING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1118:15: r= 'RETURNING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 517, self.FOLLOW_517_in_k_returning10526)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 530, k_returning_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_returning"

    class k_merge_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_merge_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_merge"
    # /home/szr/subquery/SQL2XML/YSmart.g:1120:1: k_merge : r= 'MERGE' ;
    def k_merge(self, ):

        retval = self.k_merge_return()
        retval.start = self.input.LT(1)
        k_merge_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 531):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1120:9: (r= 'MERGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1120:11: r= 'MERGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 518, self.FOLLOW_518_in_k_merge10540)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 531, k_merge_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_merge"

    class k_matched_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_matched_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_matched"
    # /home/szr/subquery/SQL2XML/YSmart.g:1121:1: k_matched : r= 'MATCHED' ;
    def k_matched(self, ):

        retval = self.k_matched_return()
        retval.start = self.input.LT(1)
        k_matched_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 532):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1121:11: (r= 'MATCHED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1121:13: r= 'MATCHED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 519, self.FOLLOW_519_in_k_matched10553)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 532, k_matched_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_matched"

    class k_following_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_following_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_following"
    # /home/szr/subquery/SQL2XML/YSmart.g:1123:1: k_following : r= 'FOLLOWING' ;
    def k_following(self, ):

        retval = self.k_following_return()
        retval.start = self.input.LT(1)
        k_following_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 533):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1123:13: (r= 'FOLLOWING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1123:15: r= 'FOLLOWING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 520, self.FOLLOW_520_in_k_following10567)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 533, k_following_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_following"

    class k_range_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_range_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_range"
    # /home/szr/subquery/SQL2XML/YSmart.g:1124:1: k_range : r= 'RANGE' ;
    def k_range(self, ):

        retval = self.k_range_return()
        retval.start = self.input.LT(1)
        k_range_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 534):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1124:9: (r= 'RANGE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1124:11: r= 'RANGE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 521, self.FOLLOW_521_in_k_range10580)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 534, k_range_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_range"

    class k_siblings_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_siblings_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_siblings"
    # /home/szr/subquery/SQL2XML/YSmart.g:1125:1: k_siblings : r= 'SIBLINGS' ;
    def k_siblings(self, ):

        retval = self.k_siblings_return()
        retval.start = self.input.LT(1)
        k_siblings_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 535):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1125:12: (r= 'SIBLINGS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1125:14: r= 'SIBLINGS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 522, self.FOLLOW_522_in_k_siblings10593)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 535, k_siblings_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_siblings"

    class k_unpivot_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_unpivot_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_unpivot"
    # /home/szr/subquery/SQL2XML/YSmart.g:1126:1: k_unpivot : r= 'UNPIVOT' ;
    def k_unpivot(self, ):

        retval = self.k_unpivot_return()
        retval.start = self.input.LT(1)
        k_unpivot_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 536):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1126:11: (r= 'UNPIVOT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1126:13: r= 'UNPIVOT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 523, self.FOLLOW_523_in_k_unpivot10606)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 536, k_unpivot_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_unpivot"

    class k_value_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_value_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_value"
    # /home/szr/subquery/SQL2XML/YSmart.g:1128:1: k_value : r= 'VALUE' ;
    def k_value(self, ):

        retval = self.k_value_return()
        retval.start = self.input.LT(1)
        k_value_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 537):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1128:9: (r= 'VALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1128:11: r= 'VALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 524, self.FOLLOW_524_in_k_value10621)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 537, k_value_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_value"

    class k_breadth_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_breadth_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_breadth"
    # /home/szr/subquery/SQL2XML/YSmart.g:1130:1: k_breadth : r= 'BREADTH' ;
    def k_breadth(self, ):

        retval = self.k_breadth_return()
        retval.start = self.input.LT(1)
        k_breadth_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 538):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1130:11: (r= 'BREADTH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1130:13: r= 'BREADTH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 525, self.FOLLOW_525_in_k_breadth10635)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 538, k_breadth_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_breadth"

    class k_depth_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_depth_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_depth"
    # /home/szr/subquery/SQL2XML/YSmart.g:1131:1: k_depth : r= 'DEPTH' ;
    def k_depth(self, ):

        retval = self.k_depth_return()
        retval.start = self.input.LT(1)
        k_depth_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 539):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1131:9: (r= 'DEPTH' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1131:11: r= 'DEPTH'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 526, self.FOLLOW_526_in_k_depth10648)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 539, k_depth_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_depth"

    class k_exclude_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_exclude_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_exclude"
    # /home/szr/subquery/SQL2XML/YSmart.g:1132:1: k_exclude : r= 'EXCLUDE' ;
    def k_exclude(self, ):

        retval = self.k_exclude_return()
        retval.start = self.input.LT(1)
        k_exclude_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 540):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1132:11: (r= 'EXCLUDE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1132:13: r= 'EXCLUDE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 527, self.FOLLOW_527_in_k_exclude10661)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 540, k_exclude_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_exclude"

    class k_include_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_include_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_include"
    # /home/szr/subquery/SQL2XML/YSmart.g:1133:1: k_include : r= 'INCLUDE' ;
    def k_include(self, ):

        retval = self.k_include_return()
        retval.start = self.input.LT(1)
        k_include_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 541):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1133:11: (r= 'INCLUDE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1133:13: r= 'INCLUDE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 528, self.FOLLOW_528_in_k_include10674)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 541, k_include_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_include"

    class k_mivalue_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_mivalue_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_mivalue"
    # /home/szr/subquery/SQL2XML/YSmart.g:1134:1: k_mivalue : r= 'MIVALUE' ;
    def k_mivalue(self, ):

        retval = self.k_mivalue_return()
        retval.start = self.input.LT(1)
        k_mivalue_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 542):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1134:11: (r= 'MIVALUE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1134:13: r= 'MIVALUE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 529, self.FOLLOW_529_in_k_mivalue10687)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 542, k_mivalue_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_mivalue"

    class k_preceding_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_preceding_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_preceding"
    # /home/szr/subquery/SQL2XML/YSmart.g:1135:1: k_preceding : r= 'PRECEDING' ;
    def k_preceding(self, ):

        retval = self.k_preceding_return()
        retval.start = self.input.LT(1)
        k_preceding_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 543):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1135:13: (r= 'PRECEDING' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1135:15: r= 'PRECEDING'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 530, self.FOLLOW_530_in_k_preceding10700)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 543, k_preceding_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_preceding"

    class k_respect_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_respect_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_respect"
    # /home/szr/subquery/SQL2XML/YSmart.g:1136:1: k_respect : r= 'RESPECT' ;
    def k_respect(self, ):

        retval = self.k_respect_return()
        retval.start = self.input.LT(1)
        k_respect_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 544):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1136:11: (r= 'RESPECT' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1136:13: r= 'RESPECT'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 531, self.FOLLOW_531_in_k_respect10713)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 544, k_respect_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_respect"

    class k_seed_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_seed_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_seed"
    # /home/szr/subquery/SQL2XML/YSmart.g:1137:1: k_seed : r= 'SEED' ;
    def k_seed(self, ):

        retval = self.k_seed_return()
        retval.start = self.input.LT(1)
        k_seed_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 545):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1137:8: (r= 'SEED' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1137:10: r= 'SEED'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 532, self.FOLLOW_532_in_k_seed10726)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 545, k_seed_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_seed"

    class k_versions_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_versions_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_versions"
    # /home/szr/subquery/SQL2XML/YSmart.g:1138:1: k_versions : r= 'VERSIONS' ;
    def k_versions(self, ):

        retval = self.k_versions_return()
        retval.start = self.input.LT(1)
        k_versions_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 546):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1138:12: (r= 'VERSIONS' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1138:14: r= 'VERSIONS'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 533, self.FOLLOW_533_in_k_versions10739)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 546, k_versions_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_versions"

    class k_distance_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_distance_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_distance"
    # /home/szr/subquery/SQL2XML/YSmart.g:1139:1: k_distance : r= 'DISTANCE' ;
    def k_distance(self, ):

        retval = self.k_distance_return()
        retval.start = self.input.LT(1)
        k_distance_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 547):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1139:12: (r= 'DISTANCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1139:14: r= 'DISTANCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 534, self.FOLLOW_534_in_k_distance10752)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 547, k_distance_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_distance"

    class k_video_extraction_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_video_extraction_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_video_extraction"
    # /home/szr/subquery/SQL2XML/YSmart.g:1140:1: k_video_extraction : r= 'VIDEO_EXTRACTION' ;
    def k_video_extraction(self, ):

        retval = self.k_video_extraction_return()
        retval.start = self.input.LT(1)
        k_video_extraction_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 548):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1140:20: (r= 'VIDEO_EXTRACTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1140:22: r= 'VIDEO_EXTRACTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 535, self.FOLLOW_535_in_k_video_extraction10767)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 548, k_video_extraction_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_video_extraction"

    class k_extraction_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_extraction_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_extraction"
    # /home/szr/subquery/SQL2XML/YSmart.g:1141:1: k_extraction : r= 'EXTRACTION' ;
    def k_extraction(self, ):

        retval = self.k_extraction_return()
        retval.start = self.input.LT(1)
        k_extraction_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 549):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1141:14: (r= 'EXTRACTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1141:16: r= 'EXTRACTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 536, self.FOLLOW_536_in_k_extraction10782)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 549, k_extraction_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_extraction"

    class k_video_feature_extraction_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_video_feature_extraction_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_video_feature_extraction"
    # /home/szr/subquery/SQL2XML/YSmart.g:1142:1: k_video_feature_extraction : r= 'VIDEO_FEATURE_EXTRACTION' ;
    def k_video_feature_extraction(self, ):

        retval = self.k_video_feature_extraction_return()
        retval.start = self.input.LT(1)
        k_video_feature_extraction_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 550):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1142:28: (r= 'VIDEO_FEATURE_EXTRACTION' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1142:30: r= 'VIDEO_FEATURE_EXTRACTION'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 537, self.FOLLOW_537_in_k_video_feature_extraction10797)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 550, k_video_feature_extraction_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_video_feature_extraction"

    class k_knn_avg_distance_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_knn_avg_distance_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_knn_avg_distance"
    # /home/szr/subquery/SQL2XML/YSmart.g:1143:1: k_knn_avg_distance : r= 'kNN_AVG_DISTANCE' ;
    def k_knn_avg_distance(self, ):

        retval = self.k_knn_avg_distance_return()
        retval.start = self.input.LT(1)
        k_knn_avg_distance_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 551):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1143:20: (r= 'kNN_AVG_DISTANCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1143:22: r= 'kNN_AVG_DISTANCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 538, self.FOLLOW_538_in_k_knn_avg_distance10812)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 551, k_knn_avg_distance_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_knn_avg_distance"

    class k_knn_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_knn_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_knn"
    # /home/szr/subquery/SQL2XML/YSmart.g:1144:1: k_knn : r= 'KNN' ;
    def k_knn(self, ):

        retval = self.k_knn_return()
        retval.start = self.input.LT(1)
        k_knn_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 552):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1144:7: (r= 'KNN' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1144:9: r= 'KNN'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 91, self.FOLLOW_91_in_k_knn10827)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 552, k_knn_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_knn"

    class k_outlier_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_outlier_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_outlier"
    # /home/szr/subquery/SQL2XML/YSmart.g:1145:1: k_outlier : r= 'OUTLIER' ;
    def k_outlier(self, ):

        retval = self.k_outlier_return()
        retval.start = self.input.LT(1)
        k_outlier_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 553):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1145:11: (r= 'OUTLIER' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1145:13: r= 'OUTLIER'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 539, self.FOLLOW_539_in_k_outlier10842)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 553, k_outlier_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_outlier"

    class k_farthest_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_farthest_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_farthest"
    # /home/szr/subquery/SQL2XML/YSmart.g:1146:1: k_farthest : r= 'FARTHEST' ;
    def k_farthest(self, ):

        retval = self.k_farthest_return()
        retval.start = self.input.LT(1)
        k_farthest_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 554):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1146:12: (r= 'FARTHEST' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1146:14: r= 'FARTHEST'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 540, self.FOLLOW_540_in_k_farthest10857)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 554, k_farthest_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_farthest"

    class k_feature_distance_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_feature_distance_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_feature_distance"
    # /home/szr/subquery/SQL2XML/YSmart.g:1147:1: k_feature_distance : r= 'FEATURE_DISTANCE' ;
    def k_feature_distance(self, ):

        retval = self.k_feature_distance_return()
        retval.start = self.input.LT(1)
        k_feature_distance_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 555):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1147:20: (r= 'FEATURE_DISTANCE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1147:22: r= 'FEATURE_DISTANCE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 541, self.FOLLOW_541_in_k_feature_distance10872)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 555, k_feature_distance_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_feature_distance"

    class k_outlier_line_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_outlier_line_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_outlier_line"
    # /home/szr/subquery/SQL2XML/YSmart.g:1148:1: k_outlier_line : r= 'OUTLIER_LINE' ;
    def k_outlier_line(self, ):

        retval = self.k_outlier_line_return()
        retval.start = self.input.LT(1)
        k_outlier_line_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 556):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1148:16: (r= 'OUTLIER_LINE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1148:18: r= 'OUTLIER_LINE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 542, self.FOLLOW_542_in_k_outlier_line10887)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 556, k_outlier_line_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_outlier_line"

    class k_outlier_score_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_outlier_score_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_outlier_score"
    # /home/szr/subquery/SQL2XML/YSmart.g:1149:1: k_outlier_score : r= 'OUTLIER_SCORE' ;
    def k_outlier_score(self, ):

        retval = self.k_outlier_score_return()
        retval.start = self.input.LT(1)
        k_outlier_score_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 557):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1149:17: (r= 'OUTLIER_SCORE' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1149:19: r= 'OUTLIER_SCORE'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 543, self.FOLLOW_543_in_k_outlier_score10902)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 557, k_outlier_score_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_outlier_score"

    class k_video_similarity_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.k_video_similarity_return, self).__init__()

            self.tree = None




    # $ANTLR start "k_video_similarity"
    # /home/szr/subquery/SQL2XML/YSmart.g:1150:1: k_video_similarity : r= 'VIDEO_SIMILARITY' ;
    def k_video_similarity(self, ):

        retval = self.k_video_similarity_return()
        retval.start = self.input.LT(1)
        k_video_similarity_StartIndex = self.input.index()
        root_0 = None

        r = None

        r_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 558):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1150:20: (r= 'VIDEO_SIMILARITY' )
                # /home/szr/subquery/SQL2XML/YSmart.g:1150:22: r= 'VIDEO_SIMILARITY'
                pass 
                root_0 = self._adaptor.nil()

                r=self.match(self.input, 544, self.FOLLOW_544_in_k_video_similarity10917)
                if self._state.backtracking == 0:

                    r_tree = self._adaptor.createWithPayload(r)
                    self._adaptor.addChild(root_0, r_tree)

                if self._state.backtracking == 0:
                    r.setType(T_RESERVED) 




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 558, k_video_similarity_StartIndex, success)

            pass
        return retval

    # $ANTLR end "k_video_similarity"

    class keyword_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.keyword_return, self).__init__()

            self.tree = None




    # $ANTLR start "keyword"
    # /home/szr/subquery/SQL2XML/YSmart.g:1152:1: keyword : ( 'A' | 'ADMIN' | 'AFTER' | 'ALLOCATE' | 'ANALYZE' | 'ARCHIVE' | 'ARCHIVELOG' | 'AT' | 'AUTHORIZATION' | 'AVG' | 'BACKUP' | 'BECOME' | 'BEFORE' | 'BEGIN' | 'BLOCK' | 'BODY' | 'BREADTH' | 'CACHE' | 'CANCEL' | 'CASCADE' | 'CHANGE' | 'CHARACTER' | 'CHECKPOINT' | 'CLOSE' | 'COBOL' | 'COMMIT' | 'COMPILE' | 'CONSTRAINT' | 'CONSTRAINTS' | 'CONTENTS' | 'CONTINUE' | 'CONTROLFILE' | 'COUNT' | 'CURSOR' | 'CYCLE' | 'DATABASE' | 'DATAFILE' | 'DAY' | 'DBA' | 'DBTIMEZONE' | 'DEC' | 'DECLARE' | 'DISABLE' | 'DISMOUNT' | 'DOUBLE' | 'DUMP' | 'DEPTH' | 'DISTANCE' | 'EACH' | 'ENABLE' | 'END' | 'ESCAPE' | 'EVENTS' | 'ERRORS' | 'EXCEPT' | 'EXCEPTIONS' | 'EXEC' | 'EXECUTE' | 'EXCLUDE' | 'EXTRACTION' | 'EXPLAIN' | 'EXTENT' | 'EXTERNALLY' | 'FETCH' | 'FIRST' | 'FLUSH' | 'FORCE' | 'FOREIGN' | 'FORTRAN' | 'FOUND' | 'FARTHEST' | 'FOLLOWING' | 'FREELIST' | 'FEATURE_DISTANCE' | 'FREELISTS' | 'FUNCTION' | 'GO' | 'GOTO' | 'GROUPS' | 'INCLUDE' | 'INCLUDING' | 'INDICATOR' | 'INITRANS' | 'INSTANCE' | 'INT' | 'KEY' | 'KNN' | 'KNN_AVG_DISTANCE' | 'LANGUAGE' | 'LAYER' | 'LIMIT' | 'LINK' | 'LISTS' | 'LOCAL' | 'LOCKED' | 'LOG' | 'LOGFILE' | 'MANAGE' | 'MANUAL' | 'MATCHED' | 'MAX' | 'MAXDATAFILES' | 'MAXINSTANCES' | 'MAXLOGFILES' | 'MAXLOGHISTORY' | 'MAXLOGMEMBERS' | 'MAXTRANS' | 'MAXVALUE' | 'MERGE' | 'MIN' | 'MINEXTENTS' | 'MINVALUE' | 'MODULE' | 'MONTH' | 'MOUNT' | 'NEW' | 'NEXT' | 'NOARCHIVELOG' | 'NOCACHE' | 'NOCYCLE' | 'NOMAXVALUE' | 'NOMINVALUE' | 'NONE' | 'NOORDER' | 'NORESETLOGS' | 'NORMAL' | 'NOSORT' | 'NUMERIC' | 'OFF' | 'OLD' | 'ONLY' | 'OPEN' | 'OPTIMAL' | 'OWN' | 'OUTLIER' | 'OUTLIER_LINE' | 'OUTLIER_SCORE' | 'PACKAGE' | 'PARALLEL' | 'PCTINCREASE' | 'PCTUSED' | 'PLAN' | 'PLI' | 'PRECISION' | 'PRIMARY' | 'PRIVATE' | 'PRECEDING' | 'PROCEDURE' | 'PROFILE' | 'QUOTA' | 'READ' | 'REAL' | 'RECOVER' | 'REFERENCES' | 'REFERENCING' | 'REJECT' | 'RETURN' | 'RETURNING' | 'RESETLOGS' | 'RESTRICTED' | 'REUSE' | 'ROLE' | 'ROLES' | 'ROLLBACK' | 'RESPECT' | 'SAVEPOINT' | 'SECOND' | 'SESSIONTIMEZONE' | 'SCHEMA' | 'SCN' | 'SECTION' | 'SEGMENT' | 'SEQUENCE' | 'SHARED' | 'SKIP' | 'SNAPSHOT' | 'SOME' | 'SORT' | 'SQL' | 'SQLCODE' | 'SQLERROR' | 'SQLSTATE' | 'STATEMENT_ID' | 'STATISTICS' | 'STOP' | 'STORAGE' | 'SUM' | 'SWITCH' | 'SYSTEM' | 'SEED' | 'TABLES' | 'TABLESPACE' | 'TEMPORARY' | 'THREAD' | 'TIME' | 'TRACING' | 'TRANSACTION' | 'TRIGGERS' | 'TRUNCATE' | 'UNDER' | 'UNLIMITED' | 'UNTIL' | 'USE' | 'VALUE' | 'VERSIONS' | 'VIDEO_FEATURE_EXTRACTION' | 'VIDEO_SIMILARITY' | 'VIDEO_EXTRACTION' | 'WHEN' | 'WORK' | 'WRITE' | 'YEAR' | 'ZONE' | 'AUTOMATIC' | 'BFILE' | 'BINARY_DOUBLE' | 'BINARY_FLOAT' | 'BINARY_INTEGER' | 'BLOB' | 'BOOLEAN' | 'BYTE' | 'CAST' | 'CLOB' | 'CLUSTER_SET' | 'COLUMN_VALUE' | 'CONNECT_BY_ISCYCLE' | 'CONNECT_BY_ISLEAF' | 'CONNECT_BY_ROOT' | 'CORR' | 'COVAR_POP' | 'COVAR_SAMP' | 'CROSS' | 'CUBE' | 'CUME_DIST' | 'DECREMENT' | 'DENSE_RANK' | 'DIMENSION' | 'EMPTY' | 'EQUALS_PATH' | 'FIRST_VALUE' | 'FULL' | 'GROUPING' | 'IGNORE' | 'INFINITE' | 'INNER' | 'INTERVAL' | 'ITERATE' | 'KEEP' | 'LAG' | 'LAST' | 'LAST_VALUE' | 'LEAD' | 'LEFT' | 'MAIN' | 'MEASURES' | 'MEMBER' | 'MLSLABEL' | 'NAN' | 'NATIONAL' | 'NATURAL' | 'NAV' | 'NCHAR' | 'NCLOB' | 'NTILE' | 'NULLS' | 'NVARCHAR' | 'NVARCHAR2' | 'OBJECT_VALUE' | 'ORA_ROWSCN' | 'OVER' | 'PIVOT' | 'PLS_INTEGER' | 'POSITIVE' | 'PRESENT' | 'RANGE' | 'RANK' | 'RATIO_TO_REPORT' | 'REFERENCE' | 'REGEXP_LIKE' | 'REGR_AVGX' | 'REGR_AVGY' | 'REGR_COUNT' | 'REGR_INTERCEPT' | 'REGR_R2' | 'REGR_SLOPE' | 'REGR_SXX' | 'REGR_SXY' | 'REGR_SYY' | 'RIGHT' | 'ROLLUP' | 'ROW_NUMBER' | 'RULES' | 'SAMPLE' | 'SEARCH' | 'SEQUENTIAL' | 'SETS' | 'SIBLINGS' | 'SINGLE' | 'STDDEV' | 'STDDEV_POP' | 'STDDEV_SAMP' | 'SUBMULTISET' | 'SUBPARTITION' | 'THE' | 'TIMESTAMP' | 'TYPE' | 'UNBOUNDED' | 'UNDER_PATH' | 'UNPIVOT' | 'UPDATED' | 'UPSERT' | 'UROWID' | 'VARIANCE' | 'VARYING' | 'VAR_POP' | 'VAR_SAMP' | 'VERSIONS_XID' | 'XML' | 'XMLDATA' );
    def keyword(self, ):

        retval = self.keyword_return()
        retval.start = self.input.LT(1)
        keyword_StartIndex = self.input.index()
        root_0 = None

        set647 = None

        set647_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 559):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1153:2: ( 'A' | 'ADMIN' | 'AFTER' | 'ALLOCATE' | 'ANALYZE' | 'ARCHIVE' | 'ARCHIVELOG' | 'AT' | 'AUTHORIZATION' | 'AVG' | 'BACKUP' | 'BECOME' | 'BEFORE' | 'BEGIN' | 'BLOCK' | 'BODY' | 'BREADTH' | 'CACHE' | 'CANCEL' | 'CASCADE' | 'CHANGE' | 'CHARACTER' | 'CHECKPOINT' | 'CLOSE' | 'COBOL' | 'COMMIT' | 'COMPILE' | 'CONSTRAINT' | 'CONSTRAINTS' | 'CONTENTS' | 'CONTINUE' | 'CONTROLFILE' | 'COUNT' | 'CURSOR' | 'CYCLE' | 'DATABASE' | 'DATAFILE' | 'DAY' | 'DBA' | 'DBTIMEZONE' | 'DEC' | 'DECLARE' | 'DISABLE' | 'DISMOUNT' | 'DOUBLE' | 'DUMP' | 'DEPTH' | 'DISTANCE' | 'EACH' | 'ENABLE' | 'END' | 'ESCAPE' | 'EVENTS' | 'ERRORS' | 'EXCEPT' | 'EXCEPTIONS' | 'EXEC' | 'EXECUTE' | 'EXCLUDE' | 'EXTRACTION' | 'EXPLAIN' | 'EXTENT' | 'EXTERNALLY' | 'FETCH' | 'FIRST' | 'FLUSH' | 'FORCE' | 'FOREIGN' | 'FORTRAN' | 'FOUND' | 'FARTHEST' | 'FOLLOWING' | 'FREELIST' | 'FEATURE_DISTANCE' | 'FREELISTS' | 'FUNCTION' | 'GO' | 'GOTO' | 'GROUPS' | 'INCLUDE' | 'INCLUDING' | 'INDICATOR' | 'INITRANS' | 'INSTANCE' | 'INT' | 'KEY' | 'KNN' | 'KNN_AVG_DISTANCE' | 'LANGUAGE' | 'LAYER' | 'LIMIT' | 'LINK' | 'LISTS' | 'LOCAL' | 'LOCKED' | 'LOG' | 'LOGFILE' | 'MANAGE' | 'MANUAL' | 'MATCHED' | 'MAX' | 'MAXDATAFILES' | 'MAXINSTANCES' | 'MAXLOGFILES' | 'MAXLOGHISTORY' | 'MAXLOGMEMBERS' | 'MAXTRANS' | 'MAXVALUE' | 'MERGE' | 'MIN' | 'MINEXTENTS' | 'MINVALUE' | 'MODULE' | 'MONTH' | 'MOUNT' | 'NEW' | 'NEXT' | 'NOARCHIVELOG' | 'NOCACHE' | 'NOCYCLE' | 'NOMAXVALUE' | 'NOMINVALUE' | 'NONE' | 'NOORDER' | 'NORESETLOGS' | 'NORMAL' | 'NOSORT' | 'NUMERIC' | 'OFF' | 'OLD' | 'ONLY' | 'OPEN' | 'OPTIMAL' | 'OWN' | 'OUTLIER' | 'OUTLIER_LINE' | 'OUTLIER_SCORE' | 'PACKAGE' | 'PARALLEL' | 'PCTINCREASE' | 'PCTUSED' | 'PLAN' | 'PLI' | 'PRECISION' | 'PRIMARY' | 'PRIVATE' | 'PRECEDING' | 'PROCEDURE' | 'PROFILE' | 'QUOTA' | 'READ' | 'REAL' | 'RECOVER' | 'REFERENCES' | 'REFERENCING' | 'REJECT' | 'RETURN' | 'RETURNING' | 'RESETLOGS' | 'RESTRICTED' | 'REUSE' | 'ROLE' | 'ROLES' | 'ROLLBACK' | 'RESPECT' | 'SAVEPOINT' | 'SECOND' | 'SESSIONTIMEZONE' | 'SCHEMA' | 'SCN' | 'SECTION' | 'SEGMENT' | 'SEQUENCE' | 'SHARED' | 'SKIP' | 'SNAPSHOT' | 'SOME' | 'SORT' | 'SQL' | 'SQLCODE' | 'SQLERROR' | 'SQLSTATE' | 'STATEMENT_ID' | 'STATISTICS' | 'STOP' | 'STORAGE' | 'SUM' | 'SWITCH' | 'SYSTEM' | 'SEED' | 'TABLES' | 'TABLESPACE' | 'TEMPORARY' | 'THREAD' | 'TIME' | 'TRACING' | 'TRANSACTION' | 'TRIGGERS' | 'TRUNCATE' | 'UNDER' | 'UNLIMITED' | 'UNTIL' | 'USE' | 'VALUE' | 'VERSIONS' | 'VIDEO_FEATURE_EXTRACTION' | 'VIDEO_SIMILARITY' | 'VIDEO_EXTRACTION' | 'WHEN' | 'WORK' | 'WRITE' | 'YEAR' | 'ZONE' | 'AUTOMATIC' | 'BFILE' | 'BINARY_DOUBLE' | 'BINARY_FLOAT' | 'BINARY_INTEGER' | 'BLOB' | 'BOOLEAN' | 'BYTE' | 'CAST' | 'CLOB' | 'CLUSTER_SET' | 'COLUMN_VALUE' | 'CONNECT_BY_ISCYCLE' | 'CONNECT_BY_ISLEAF' | 'CONNECT_BY_ROOT' | 'CORR' | 'COVAR_POP' | 'COVAR_SAMP' | 'CROSS' | 'CUBE' | 'CUME_DIST' | 'DECREMENT' | 'DENSE_RANK' | 'DIMENSION' | 'EMPTY' | 'EQUALS_PATH' | 'FIRST_VALUE' | 'FULL' | 'GROUPING' | 'IGNORE' | 'INFINITE' | 'INNER' | 'INTERVAL' | 'ITERATE' | 'KEEP' | 'LAG' | 'LAST' | 'LAST_VALUE' | 'LEAD' | 'LEFT' | 'MAIN' | 'MEASURES' | 'MEMBER' | 'MLSLABEL' | 'NAN' | 'NATIONAL' | 'NATURAL' | 'NAV' | 'NCHAR' | 'NCLOB' | 'NTILE' | 'NULLS' | 'NVARCHAR' | 'NVARCHAR2' | 'OBJECT_VALUE' | 'ORA_ROWSCN' | 'OVER' | 'PIVOT' | 'PLS_INTEGER' | 'POSITIVE' | 'PRESENT' | 'RANGE' | 'RANK' | 'RATIO_TO_REPORT' | 'REFERENCE' | 'REGEXP_LIKE' | 'REGR_AVGX' | 'REGR_AVGY' | 'REGR_COUNT' | 'REGR_INTERCEPT' | 'REGR_R2' | 'REGR_SLOPE' | 'REGR_SXX' | 'REGR_SXY' | 'REGR_SYY' | 'RIGHT' | 'ROLLUP' | 'ROW_NUMBER' | 'RULES' | 'SAMPLE' | 'SEARCH' | 'SEQUENTIAL' | 'SETS' | 'SIBLINGS' | 'SINGLE' | 'STDDEV' | 'STDDEV_POP' | 'STDDEV_SAMP' | 'SUBMULTISET' | 'SUBPARTITION' | 'THE' | 'TIMESTAMP' | 'TYPE' | 'UNBOUNDED' | 'UNDER_PATH' | 'UNPIVOT' | 'UPDATED' | 'UPSERT' | 'UROWID' | 'VARIANCE' | 'VARYING' | 'VAR_POP' | 'VAR_SAMP' | 'VERSIONS_XID' | 'XML' | 'XMLDATA' )
                # /home/szr/subquery/SQL2XML/YSmart.g:
                pass 
                root_0 = self._adaptor.nil()

                set647 = self.input.LT(1)
                if self.input.LA(1) == 91 or (211 <= self.input.LA(1) <= 367) or (369 <= self.input.LA(1) <= 387) or (390 <= self.input.LA(1) <= 428) or (430 <= self.input.LA(1) <= 439) or (442 <= self.input.LA(1) <= 453) or self.input.LA(1) == 455 or (460 <= self.input.LA(1) <= 502) or (508 <= self.input.LA(1) <= 528) or (530 <= self.input.LA(1) <= 537) or (539 <= self.input.LA(1) <= 546):
                    self.input.consume()
                    if self._state.backtracking == 0:
                        self._adaptor.addChild(root_0, self._adaptor.createWithPayload(set647))
                    self._state.errorRecovery = False

                else:
                    if self._state.backtracking > 0:
                        raise BacktrackingFailed

                    mse = MismatchedSetException(None, self.input)
                    raise mse





                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 559, keyword_StartIndex, success)

            pass
        return retval

    # $ANTLR end "keyword"

    class quoted_string_return(ParserRuleReturnScope):
        def __init__(self):
            super(YSmartParser.quoted_string_return, self).__init__()

            self.tree = None




    # $ANTLR start "quoted_string"
    # /home/szr/subquery/SQL2XML/YSmart.g:1232:1: quoted_string : QUOTED_STRING ;
    def quoted_string(self, ):

        retval = self.quoted_string_return()
        retval.start = self.input.LT(1)
        quoted_string_StartIndex = self.input.index()
        root_0 = None

        QUOTED_STRING648 = None

        QUOTED_STRING648_tree = None

        success = False
        try:
            try:
                if self._state.backtracking > 0 and self.alreadyParsedRule(self.input, 560):
                    # for cached failed rules, alreadyParsedRule will raise an exception
                    success = True
                    return retval

                # /home/szr/subquery/SQL2XML/YSmart.g:1233:2: ( QUOTED_STRING )
                # /home/szr/subquery/SQL2XML/YSmart.g:1233:4: QUOTED_STRING
                pass 
                root_0 = self._adaptor.nil()

                QUOTED_STRING648=self.match(self.input, QUOTED_STRING, self.FOLLOW_QUOTED_STRING_in_quoted_string12476)
                if self._state.backtracking == 0:

                    QUOTED_STRING648_tree = self._adaptor.createWithPayload(QUOTED_STRING648)
                    self._adaptor.addChild(root_0, QUOTED_STRING648_tree)




                retval.stop = self.input.LT(-1)

                if self._state.backtracking == 0:

                    retval.tree = self._adaptor.rulePostProcessing(root_0)
                    self._adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop)


                success = True
            except RecognitionException, re:
                self.reportError(re)
                self.recover(self.input, re)
                retval.tree = self._adaptor.errorNode(self.input, retval.start, self.input.LT(-1), re)
        finally:
            if self._state.backtracking > 0:
                self.memoize(self.input, 560, quoted_string_StartIndex, success)

            pass
        return retval

    # $ANTLR end "quoted_string"

    # $ANTLR start "synpred13_YSmart"
    def synpred13_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:193:15: ( ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul )
        # /home/szr/subquery/SQL2XML/YSmart.g:193:15: ( PLUS | MINUS | DOUBLEVERTBAR ) expr_mul
        pass 
        if (PLUS <= self.input.LA(1) <= DOUBLEVERTBAR):
            self.input.consume()
            self._state.errorRecovery = False

        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            mse = MismatchedSetException(None, self.input)
            raise mse


        self._state.following.append(self.FOLLOW_expr_mul_in_synpred13_YSmart867)
        self.expr_mul()

        self._state.following.pop()


    # $ANTLR end "synpred13_YSmart"



    # $ANTLR start "synpred15_YSmart"
    def synpred15_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:196:16: ( ( ASTERISK | DIVIDE ) expr_sign )
        # /home/szr/subquery/SQL2XML/YSmart.g:196:16: ( ASTERISK | DIVIDE ) expr_sign
        pass 
        if self.input.LA(1) == ASTERISK or self.input.LA(1) == DIVIDE:
            self.input.consume()
            self._state.errorRecovery = False

        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            mse = MismatchedSetException(None, self.input)
            raise mse


        self._state.following.append(self.FOLLOW_expr_sign_in_synpred15_YSmart894)
        self.expr_sign()

        self._state.following.pop()


    # $ANTLR end "synpred15_YSmart"



    # $ANTLR start "synpred19_YSmart"
    def synpred19_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:199:31: ( k_connect_by_root )
        # /home/szr/subquery/SQL2XML/YSmart.g:199:31: k_connect_by_root
        pass 
        self._state.following.append(self.FOLLOW_k_connect_by_root_in_synpred19_YSmart922)
        self.k_connect_by_root()

        self._state.following.pop()


    # $ANTLR end "synpred19_YSmart"



    # $ANTLR start "synpred20_YSmart"
    def synpred20_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:202:16: ( EXPONENT expr_expr )
        # /home/szr/subquery/SQL2XML/YSmart.g:202:16: EXPONENT expr_expr
        pass 
        self.match(self.input, EXPONENT, self.FOLLOW_EXPONENT_in_synpred20_YSmart941)
        self._state.following.append(self.FOLLOW_expr_expr_in_synpred20_YSmart943)
        self.expr_expr()

        self._state.following.pop()


    # $ANTLR end "synpred20_YSmart"



    # $ANTLR start "synpred21_YSmart"
    def synpred21_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:205:4: ( datetime_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:205:4: datetime_expression
        pass 
        self._state.following.append(self.FOLLOW_datetime_expression_in_synpred21_YSmart956)
        self.datetime_expression()

        self._state.following.pop()


    # $ANTLR end "synpred21_YSmart"



    # $ANTLR start "synpred22_YSmart"
    def synpred22_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:206:4: ( interval_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:206:4: interval_expression
        pass 
        self._state.following.append(self.FOLLOW_interval_expression_in_synpred22_YSmart961)
        self.interval_expression()

        self._state.following.pop()


    # $ANTLR end "synpred22_YSmart"



    # $ANTLR start "synpred23_YSmart"
    def synpred23_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:207:4: ( expr_paren )
        # /home/szr/subquery/SQL2XML/YSmart.g:207:6: expr_paren
        pass 
        self._state.following.append(self.FOLLOW_expr_paren_in_synpred23_YSmart976)
        self.expr_paren()

        self._state.following.pop()


    # $ANTLR end "synpred23_YSmart"



    # $ANTLR start "synpred24_YSmart"
    def synpred24_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:208:4: ( cast_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:208:6: cast_expression
        pass 
        self._state.following.append(self.FOLLOW_cast_expression_in_synpred24_YSmart989)
        self.cast_expression()

        self._state.following.pop()


    # $ANTLR end "synpred24_YSmart"



    # $ANTLR start "synpred25_YSmart"
    def synpred25_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:209:4: ( function_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:209:6: function_expression
        pass 
        self._state.following.append(self.FOLLOW_function_expression_in_synpred25_YSmart1001)
        self.function_expression()

        self._state.following.pop()


    # $ANTLR end "synpred25_YSmart"



    # $ANTLR start "synpred26_YSmart"
    def synpred26_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:210:4: ( case_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:210:6: case_expression
        pass 
        self._state.following.append(self.FOLLOW_case_expression_in_synpred26_YSmart1014)
        self.case_expression()

        self._state.following.pop()


    # $ANTLR end "synpred26_YSmart"



    # $ANTLR start "synpred27_YSmart"
    def synpred27_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:211:4: ( simple_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:211:6: simple_expression
        pass 
        self._state.following.append(self.FOLLOW_simple_expression_in_synpred27_YSmart1027)
        self.simple_expression()

        self._state.following.pop()


    # $ANTLR end "synpred27_YSmart"



    # $ANTLR start "synpred28_YSmart"
    def synpred28_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:212:4: ( subquery )
        # /home/szr/subquery/SQL2XML/YSmart.g:212:6: subquery
        pass 
        self._state.following.append(self.FOLLOW_subquery_in_synpred28_YSmart1040)
        self.subquery()

        self._state.following.pop()


    # $ANTLR end "synpred28_YSmart"



    # $ANTLR start "synpred32_YSmart"
    def synpred32_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:235:13: ( simple_case_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:235:13: simple_case_expression
        pass 
        self._state.following.append(self.FOLLOW_simple_case_expression_in_synpred32_YSmart1158)
        self.simple_case_expression()

        self._state.following.pop()


    # $ANTLR end "synpred32_YSmart"



    # $ANTLR start "synpred42_YSmart"
    def synpred42_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:250:4: ( column_spec )
        # /home/szr/subquery/SQL2XML/YSmart.g:250:6: column_spec
        pass 
        self._state.following.append(self.FOLLOW_column_spec_in_synpred42_YSmart1274)
        self.column_spec()

        self._state.following.pop()


    # $ANTLR end "synpred42_YSmart"



    # $ANTLR start "synpred45_YSmart"
    def synpred45_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:263:11: ( function_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:263:11: function_expression
        pass 
        self._state.following.append(self.FOLLOW_function_expression_in_synpred45_YSmart1344)
        self.function_expression()

        self._state.following.pop()


    # $ANTLR end "synpred45_YSmart"



    # $ANTLR start "synpred46_YSmart"
    def synpred46_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:263:33: ( cast_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:263:33: cast_expression
        pass 
        self._state.following.append(self.FOLLOW_cast_expression_in_synpred46_YSmart1348)
        self.cast_expression()

        self._state.following.pop()


    # $ANTLR end "synpred46_YSmart"



    # $ANTLR start "synpred48_YSmart"
    def synpred48_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:264:41: ( quoted_string )
        # /home/szr/subquery/SQL2XML/YSmart.g:264:41: quoted_string
        pass 
        self._state.following.append(self.FOLLOW_quoted_string_in_synpred48_YSmart1377)
        self.quoted_string()

        self._state.following.pop()


    # $ANTLR end "synpred48_YSmart"



    # $ANTLR start "synpred49_YSmart"
    def synpred49_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:264:57: ( k_dbtimezone )
        # /home/szr/subquery/SQL2XML/YSmart.g:264:57: k_dbtimezone
        pass 
        self._state.following.append(self.FOLLOW_k_dbtimezone_in_synpred49_YSmart1381)
        self.k_dbtimezone()

        self._state.following.pop()


    # $ANTLR end "synpred49_YSmart"



    # $ANTLR start "synpred50_YSmart"
    def synpred50_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:264:72: ( k_sessiontimezone )
        # /home/szr/subquery/SQL2XML/YSmart.g:264:72: k_sessiontimezone
        pass 
        self._state.following.append(self.FOLLOW_k_sessiontimezone_in_synpred50_YSmart1385)
        self.k_sessiontimezone()

        self._state.following.pop()


    # $ANTLR end "synpred50_YSmart"



    # $ANTLR start "synpred51_YSmart"
    def synpred51_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:268:12: ( function_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:268:12: function_expression
        pass 
        self._state.following.append(self.FOLLOW_function_expression_in_synpred51_YSmart1407)
        self.function_expression()

        self._state.following.pop()


    # $ANTLR end "synpred51_YSmart"



    # $ANTLR start "synpred52_YSmart"
    def synpred52_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:268:34: ( cast_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:268:34: cast_expression
        pass 
        self._state.following.append(self.FOLLOW_cast_expression_in_synpred52_YSmart1411)
        self.cast_expression()

        self._state.following.pop()


    # $ANTLR end "synpred52_YSmart"



    # $ANTLR start "synpred53_YSmart"
    def synpred53_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:268:80: ( function_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:268:80: function_expression
        pass 
        self._state.following.append(self.FOLLOW_function_expression_in_synpred53_YSmart1423)
        self.function_expression()

        self._state.following.pop()


    # $ANTLR end "synpred53_YSmart"



    # $ANTLR start "synpred54_YSmart"
    def synpred54_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:268:102: ( cast_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:268:102: cast_expression
        pass 
        self._state.following.append(self.FOLLOW_cast_expression_in_synpred54_YSmart1427)
        self.cast_expression()

        self._state.following.pop()


    # $ANTLR end "synpred54_YSmart"



    # $ANTLR start "synpred61_YSmart"
    def synpred61_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:277:63: ( datatype )
        # /home/szr/subquery/SQL2XML/YSmart.g:277:63: datatype
        pass 
        self._state.following.append(self.FOLLOW_datatype_in_synpred61_YSmart1524)
        self.datatype()

        self._state.following.pop()


    # $ANTLR end "synpred61_YSmart"



    # $ANTLR start "synpred146_YSmart"
    def synpred146_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:337:4: ( sql_identifier )
        # /home/szr/subquery/SQL2XML/YSmart.g:337:4: sql_identifier
        pass 
        self._state.following.append(self.FOLLOW_sql_identifier_in_synpred146_YSmart2267)
        self.sql_identifier()

        self._state.following.pop()


    # $ANTLR end "synpred146_YSmart"



    # $ANTLR start "synpred172_YSmart"
    def synpred172_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:387:5: ( ( table_name ( t_alias )? kNN_join_clause ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:387:5: ( table_name ( t_alias )? kNN_join_clause )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:387:5: ( table_name ( t_alias )? kNN_join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:387:6: table_name ( t_alias )? kNN_join_clause
        pass 
        self._state.following.append(self.FOLLOW_table_name_in_synpred172_YSmart2497)
        self.table_name()

        self._state.following.pop()
        # /home/szr/subquery/SQL2XML/YSmart.g:387:17: ( t_alias )?
        alt220 = 2
        LA220_0 = self.input.LA(1)

        if ((VECTOR <= LA220_0 <= DOUBLEQUOTED_STRING) or LA220_0 == 178 or LA220_0 == 180 or (211 <= LA220_0 <= 367) or (369 <= LA220_0 <= 387) or (390 <= LA220_0 <= 428) or (430 <= LA220_0 <= 439) or (442 <= LA220_0 <= 453) or LA220_0 == 455 or (460 <= LA220_0 <= 502) or (508 <= LA220_0 <= 528) or (530 <= LA220_0 <= 537) or (539 <= LA220_0 <= 546)) :
            alt220 = 1
        elif (LA220_0 == 91) :
            LA220_2 = self.input.LA(2)

            if (LA220_2 == 91) :
                alt220 = 1
        if alt220 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:0:0: t_alias
            pass 
            self._state.following.append(self.FOLLOW_t_alias_in_synpred172_YSmart2499)
            self.t_alias()

            self._state.following.pop()



        self._state.following.append(self.FOLLOW_kNN_join_clause_in_synpred172_YSmart2502)
        self.kNN_join_clause()

        self._state.following.pop()





    # $ANTLR end "synpred172_YSmart"



    # $ANTLR start "synpred173_YSmart"
    def synpred173_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:387:43: ( join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:387:43: join_clause
        pass 
        self._state.following.append(self.FOLLOW_join_clause_in_synpred173_YSmart2505)
        self.join_clause()

        self._state.following.pop()


    # $ANTLR end "synpred173_YSmart"



    # $ANTLR start "synpred174_YSmart"
    def synpred174_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:387:55: ( ( LPAREN join_clause RPAREN ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:387:55: ( LPAREN join_clause RPAREN )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:387:55: ( LPAREN join_clause RPAREN )
        # /home/szr/subquery/SQL2XML/YSmart.g:387:56: LPAREN join_clause RPAREN
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred174_YSmart2508)
        self._state.following.append(self.FOLLOW_join_clause_in_synpred174_YSmart2510)
        self.join_clause()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred174_YSmart2512)





    # $ANTLR end "synpred174_YSmart"



    # $ANTLR start "synpred176_YSmart"
    def synpred176_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:388:12: ( ( table_name ( t_alias )? kNN_join_clause ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:388:12: ( table_name ( t_alias )? kNN_join_clause )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:388:12: ( table_name ( t_alias )? kNN_join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:388:13: table_name ( t_alias )? kNN_join_clause
        pass 
        self._state.following.append(self.FOLLOW_table_name_in_synpred176_YSmart2526)
        self.table_name()

        self._state.following.pop()
        # /home/szr/subquery/SQL2XML/YSmart.g:388:24: ( t_alias )?
        alt221 = 2
        LA221_0 = self.input.LA(1)

        if ((VECTOR <= LA221_0 <= DOUBLEQUOTED_STRING) or LA221_0 == 178 or LA221_0 == 180 or (211 <= LA221_0 <= 367) or (369 <= LA221_0 <= 387) or (390 <= LA221_0 <= 428) or (430 <= LA221_0 <= 439) or (442 <= LA221_0 <= 453) or LA221_0 == 455 or (460 <= LA221_0 <= 502) or (508 <= LA221_0 <= 528) or (530 <= LA221_0 <= 537) or (539 <= LA221_0 <= 546)) :
            alt221 = 1
        elif (LA221_0 == 91) :
            LA221_2 = self.input.LA(2)

            if (LA221_2 == 91) :
                alt221 = 1
        if alt221 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:0:0: t_alias
            pass 
            self._state.following.append(self.FOLLOW_t_alias_in_synpred176_YSmart2528)
            self.t_alias()

            self._state.following.pop()



        self._state.following.append(self.FOLLOW_kNN_join_clause_in_synpred176_YSmart2531)
        self.kNN_join_clause()

        self._state.following.pop()





    # $ANTLR end "synpred176_YSmart"



    # $ANTLR start "synpred177_YSmart"
    def synpred177_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:388:50: ( join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:388:50: join_clause
        pass 
        self._state.following.append(self.FOLLOW_join_clause_in_synpred177_YSmart2534)
        self.join_clause()

        self._state.following.pop()


    # $ANTLR end "synpred177_YSmart"



    # $ANTLR start "synpred178_YSmart"
    def synpred178_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:388:62: ( ( LPAREN join_clause RPAREN ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:388:62: ( LPAREN join_clause RPAREN )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:388:62: ( LPAREN join_clause RPAREN )
        # /home/szr/subquery/SQL2XML/YSmart.g:388:63: LPAREN join_clause RPAREN
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred178_YSmart2537)
        self._state.following.append(self.FOLLOW_join_clause_in_synpred178_YSmart2539)
        self.join_clause()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred178_YSmart2541)





    # $ANTLR end "synpred178_YSmart"



    # $ANTLR start "synpred181_YSmart"
    def synpred181_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:396:34: ( t_alias )
        # /home/szr/subquery/SQL2XML/YSmart.g:396:34: t_alias
        pass 
        self._state.following.append(self.FOLLOW_t_alias_in_synpred181_YSmart2597)
        self.t_alias()

        self._state.following.pop()


    # $ANTLR end "synpred181_YSmart"



    # $ANTLR start "synpred183_YSmart"
    def synpred183_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:397:4: ( subquery t_alias )
        # /home/szr/subquery/SQL2XML/YSmart.g:397:4: subquery t_alias
        pass 
        self._state.following.append(self.FOLLOW_subquery_in_synpred183_YSmart2603)
        self.subquery()

        self._state.following.pop()
        self._state.following.append(self.FOLLOW_t_alias_in_synpred183_YSmart2605)
        self.t_alias()

        self._state.following.pop()


    # $ANTLR end "synpred183_YSmart"



    # $ANTLR start "synpred184_YSmart"
    def synpred184_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:401:21: ( inner_cross_join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:401:21: inner_cross_join_clause
        pass 
        self._state.following.append(self.FOLLOW_inner_cross_join_clause_in_synpred184_YSmart2635)
        self.inner_cross_join_clause()

        self._state.following.pop()


    # $ANTLR end "synpred184_YSmart"



    # $ANTLR start "synpred185_YSmart"
    def synpred185_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:401:45: ( outer_join_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:401:45: outer_join_clause
        pass 
        self._state.following.append(self.FOLLOW_outer_join_clause_in_synpred185_YSmart2637)
        self.outer_join_clause()

        self._state.following.pop()


    # $ANTLR end "synpred185_YSmart"



    # $ANTLR start "synpred201_YSmart"
    def synpred201_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:463:4: ( rollup_cube_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:463:4: rollup_cube_clause
        pass 
        self._state.following.append(self.FOLLOW_rollup_cube_clause_in_synpred201_YSmart3023)
        self.rollup_cube_clause()

        self._state.following.pop()


    # $ANTLR end "synpred201_YSmart"



    # $ANTLR start "synpred202_YSmart"
    def synpred202_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:464:4: ( grouping_sets_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:464:4: grouping_sets_clause
        pass 
        self._state.following.append(self.FOLLOW_grouping_sets_clause_in_synpred202_YSmart3028)
        self.grouping_sets_clause()

        self._state.following.pop()


    # $ANTLR end "synpred202_YSmart"



    # $ANTLR start "synpred205_YSmart"
    def synpred205_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:477:4: ( rollup_cube_clause )
        # /home/szr/subquery/SQL2XML/YSmart.g:477:4: rollup_cube_clause
        pass 
        self._state.following.append(self.FOLLOW_rollup_cube_clause_in_synpred205_YSmart3104)
        self.rollup_cube_clause()

        self._state.following.pop()


    # $ANTLR end "synpred205_YSmart"



    # $ANTLR start "synpred207_YSmart"
    def synpred207_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:483:4: ( ( condition_or_part_first ( condition_or_part_next )+ ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:483:4: ( condition_or_part_first ( condition_or_part_next )+ )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:483:4: ( condition_or_part_first ( condition_or_part_next )+ )
        # /home/szr/subquery/SQL2XML/YSmart.g:483:5: condition_or_part_first ( condition_or_part_next )+
        pass 
        self._state.following.append(self.FOLLOW_condition_or_part_first_in_synpred207_YSmart3129)
        self.condition_or_part_first()

        self._state.following.pop()
        # /home/szr/subquery/SQL2XML/YSmart.g:483:29: ( condition_or_part_next )+
        cnt228 = 0
        while True: #loop228
            alt228 = 2
            LA228_0 = self.input.LA(1)

            if (LA228_0 == 167) :
                alt228 = 1


            if alt228 == 1:
                # /home/szr/subquery/SQL2XML/YSmart.g:0:0: condition_or_part_next
                pass 
                self._state.following.append(self.FOLLOW_condition_or_part_next_in_synpred207_YSmart3131)
                self.condition_or_part_next()

                self._state.following.pop()


            else:
                if cnt228 >= 1:
                    break #loop228

                if self._state.backtracking > 0:
                    raise BacktrackingFailed

                eee = EarlyExitException(228, self.input)
                raise eee

            cnt228 += 1





    # $ANTLR end "synpred207_YSmart"



    # $ANTLR start "synpred209_YSmart"
    def synpred209_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:493:7: ( ( condition_and_part_first ( condition_and_part_next )+ ) )
        # /home/szr/subquery/SQL2XML/YSmart.g:493:7: ( condition_and_part_first ( condition_and_part_next )+ )
        pass 
        # /home/szr/subquery/SQL2XML/YSmart.g:493:7: ( condition_and_part_first ( condition_and_part_next )+ )
        # /home/szr/subquery/SQL2XML/YSmart.g:493:8: condition_and_part_first ( condition_and_part_next )+
        pass 
        self._state.following.append(self.FOLLOW_condition_and_part_first_in_synpred209_YSmart3205)
        self.condition_and_part_first()

        self._state.following.pop()
        # /home/szr/subquery/SQL2XML/YSmart.g:493:33: ( condition_and_part_next )+
        cnt229 = 0
        while True: #loop229
            alt229 = 2
            LA229_0 = self.input.LA(1)

            if (LA229_0 == 97) :
                alt229 = 1


            if alt229 == 1:
                # /home/szr/subquery/SQL2XML/YSmart.g:0:0: condition_and_part_next
                pass 
                self._state.following.append(self.FOLLOW_condition_and_part_next_in_synpred209_YSmart3207)
                self.condition_and_part_next()

                self._state.following.pop()


            else:
                if cnt229 >= 1:
                    break #loop229

                if self._state.backtracking > 0:
                    raise BacktrackingFailed

                eee = EarlyExitException(229, self.input)
                raise eee

            cnt229 += 1





    # $ANTLR end "synpred209_YSmart"



    # $ANTLR start "synpred212_YSmart"
    def synpred212_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:508:4: ( condition_is )
        # /home/szr/subquery/SQL2XML/YSmart.g:508:4: condition_is
        pass 
        self._state.following.append(self.FOLLOW_condition_is_in_synpred212_YSmart3312)
        self.condition_is()

        self._state.following.pop()


    # $ANTLR end "synpred212_YSmart"



    # $ANTLR start "synpred213_YSmart"
    def synpred213_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:509:4: ( condition_comparison )
        # /home/szr/subquery/SQL2XML/YSmart.g:509:4: condition_comparison
        pass 
        self._state.following.append(self.FOLLOW_condition_comparison_in_synpred213_YSmart3317)
        self.condition_comparison()

        self._state.following.pop()


    # $ANTLR end "synpred213_YSmart"



    # $ANTLR start "synpred214_YSmart"
    def synpred214_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:510:4: ( condition_group_comparison )
        # /home/szr/subquery/SQL2XML/YSmart.g:510:4: condition_group_comparison
        pass 
        self._state.following.append(self.FOLLOW_condition_group_comparison_in_synpred214_YSmart3322)
        self.condition_group_comparison()

        self._state.following.pop()


    # $ANTLR end "synpred214_YSmart"



    # $ANTLR start "synpred215_YSmart"
    def synpred215_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:511:4: ( condition_in )
        # /home/szr/subquery/SQL2XML/YSmart.g:511:4: condition_in
        pass 
        self._state.following.append(self.FOLLOW_condition_in_in_synpred215_YSmart3327)
        self.condition_in()

        self._state.following.pop()


    # $ANTLR end "synpred215_YSmart"



    # $ANTLR start "synpred216_YSmart"
    def synpred216_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:512:4: ( condition_is_a_set )
        # /home/szr/subquery/SQL2XML/YSmart.g:512:4: condition_is_a_set
        pass 
        self._state.following.append(self.FOLLOW_condition_is_a_set_in_synpred216_YSmart3332)
        self.condition_is_a_set()

        self._state.following.pop()


    # $ANTLR end "synpred216_YSmart"



    # $ANTLR start "synpred217_YSmart"
    def synpred217_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:513:4: ( condition_is_any )
        # /home/szr/subquery/SQL2XML/YSmart.g:513:4: condition_is_any
        pass 
        self._state.following.append(self.FOLLOW_condition_is_any_in_synpred217_YSmart3337)
        self.condition_is_any()

        self._state.following.pop()


    # $ANTLR end "synpred217_YSmart"



    # $ANTLR start "synpred218_YSmart"
    def synpred218_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:514:4: ( condition_is_empty )
        # /home/szr/subquery/SQL2XML/YSmart.g:514:4: condition_is_empty
        pass 
        self._state.following.append(self.FOLLOW_condition_is_empty_in_synpred218_YSmart3342)
        self.condition_is_empty()

        self._state.following.pop()


    # $ANTLR end "synpred218_YSmart"



    # $ANTLR start "synpred219_YSmart"
    def synpred219_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:515:4: ( condition_is_of_type )
        # /home/szr/subquery/SQL2XML/YSmart.g:515:4: condition_is_of_type
        pass 
        self._state.following.append(self.FOLLOW_condition_is_of_type_in_synpred219_YSmart3347)
        self.condition_is_of_type()

        self._state.following.pop()


    # $ANTLR end "synpred219_YSmart"



    # $ANTLR start "synpred220_YSmart"
    def synpred220_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:516:4: ( condition_is_present )
        # /home/szr/subquery/SQL2XML/YSmart.g:516:4: condition_is_present
        pass 
        self._state.following.append(self.FOLLOW_condition_is_present_in_synpred220_YSmart3352)
        self.condition_is_present()

        self._state.following.pop()


    # $ANTLR end "synpred220_YSmart"



    # $ANTLR start "synpred221_YSmart"
    def synpred221_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:517:4: ( condition_like )
        # /home/szr/subquery/SQL2XML/YSmart.g:517:4: condition_like
        pass 
        self._state.following.append(self.FOLLOW_condition_like_in_synpred221_YSmart3357)
        self.condition_like()

        self._state.following.pop()


    # $ANTLR end "synpred221_YSmart"



    # $ANTLR start "synpred222_YSmart"
    def synpred222_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:518:4: ( condition_memeber )
        # /home/szr/subquery/SQL2XML/YSmart.g:518:4: condition_memeber
        pass 
        self._state.following.append(self.FOLLOW_condition_memeber_in_synpred222_YSmart3362)
        self.condition_memeber()

        self._state.following.pop()


    # $ANTLR end "synpred222_YSmart"



    # $ANTLR start "synpred223_YSmart"
    def synpred223_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:519:4: ( condition_between )
        # /home/szr/subquery/SQL2XML/YSmart.g:519:4: condition_between
        pass 
        self._state.following.append(self.FOLLOW_condition_between_in_synpred223_YSmart3367)
        self.condition_between()

        self._state.following.pop()


    # $ANTLR end "synpred223_YSmart"



    # $ANTLR start "synpred224_YSmart"
    def synpred224_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:520:4: ( condition_regexp_like )
        # /home/szr/subquery/SQL2XML/YSmart.g:520:4: condition_regexp_like
        pass 
        self._state.following.append(self.FOLLOW_condition_regexp_like_in_synpred224_YSmart3372)
        self.condition_regexp_like()

        self._state.following.pop()


    # $ANTLR end "synpred224_YSmart"



    # $ANTLR start "synpred225_YSmart"
    def synpred225_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:521:4: ( condition_submultiset )
        # /home/szr/subquery/SQL2XML/YSmart.g:521:4: condition_submultiset
        pass 
        self._state.following.append(self.FOLLOW_condition_submultiset_in_synpred225_YSmart3377)
        self.condition_submultiset()

        self._state.following.pop()


    # $ANTLR end "synpred225_YSmart"



    # $ANTLR start "synpred226_YSmart"
    def synpred226_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:522:4: ( condition_equals_path )
        # /home/szr/subquery/SQL2XML/YSmart.g:522:4: condition_equals_path
        pass 
        self._state.following.append(self.FOLLOW_condition_equals_path_in_synpred226_YSmart3382)
        self.condition_equals_path()

        self._state.following.pop()


    # $ANTLR end "synpred226_YSmart"



    # $ANTLR start "synpred227_YSmart"
    def synpred227_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:523:4: ( condition_under_path )
        # /home/szr/subquery/SQL2XML/YSmart.g:523:4: condition_under_path
        pass 
        self._state.following.append(self.FOLLOW_condition_under_path_in_synpred227_YSmart3387)
        self.condition_under_path()

        self._state.following.pop()


    # $ANTLR end "synpred227_YSmart"



    # $ANTLR start "synpred234_YSmart"
    def synpred234_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:534:4: ( LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) subquery ( outer_join_sign )? )
        # /home/szr/subquery/SQL2XML/YSmart.g:534:4: LPAREN sql_expressions RPAREN ( outer_join_sign )? ( EQ | NOT_EQ ) subquery ( outer_join_sign )?
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred234_YSmart3448)
        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred234_YSmart3450)
        self.sql_expressions()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred234_YSmart3452)
        # /home/szr/subquery/SQL2XML/YSmart.g:534:34: ( outer_join_sign )?
        alt230 = 2
        LA230_0 = self.input.LA(1)

        if (LA230_0 == LPAREN) :
            alt230 = 1
        if alt230 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:534:36: outer_join_sign
            pass 
            self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred234_YSmart3456)
            self.outer_join_sign()

            self._state.following.pop()



        if (EQ <= self.input.LA(1) <= NOT_EQ):
            self.input.consume()
            self._state.errorRecovery = False

        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            mse = MismatchedSetException(None, self.input)
            raise mse


        self._state.following.append(self.FOLLOW_subquery_in_synpred234_YSmart3471)
        self.subquery()

        self._state.following.pop()
        # /home/szr/subquery/SQL2XML/YSmart.g:534:80: ( outer_join_sign )?
        alt231 = 2
        LA231_0 = self.input.LA(1)

        if (LA231_0 == LPAREN) :
            alt231 = 1
        if alt231 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:534:82: outer_join_sign
            pass 
            self._state.following.append(self.FOLLOW_outer_join_sign_in_synpred234_YSmart3475)
            self.outer_join_sign()

            self._state.following.pop()





    # $ANTLR end "synpred234_YSmart"



    # $ANTLR start "synpred235_YSmart"
    def synpred235_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:535:6: ( k_prior )
        # /home/szr/subquery/SQL2XML/YSmart.g:535:6: k_prior
        pass 
        self._state.following.append(self.FOLLOW_k_prior_in_synpred235_YSmart3485)
        self.k_prior()

        self._state.following.pop()


    # $ANTLR end "synpred235_YSmart"



    # $ANTLR start "synpred242_YSmart"
    def synpred242_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:535:95: ( k_prior )
        # /home/szr/subquery/SQL2XML/YSmart.g:535:95: k_prior
        pass 
        self._state.following.append(self.FOLLOW_k_prior_in_synpred242_YSmart3527)
        self.k_prior()

        self._state.following.pop()


    # $ANTLR end "synpred242_YSmart"



    # $ANTLR start "synpred243_YSmart"
    def synpred243_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:535:108: ( sql_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:535:108: sql_expression
        pass 
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred243_YSmart3534)
        self.sql_expression()

        self._state.following.pop()


    # $ANTLR end "synpred243_YSmart"



    # $ANTLR start "synpred249_YSmart"
    def synpred249_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:538:4: ( LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( k_any | k_some | k_all ) LPAREN ( grouping_expression_list | select_statement ) RPAREN )
        # /home/szr/subquery/SQL2XML/YSmart.g:538:4: LPAREN sql_expressions RPAREN ( EQ | NOT_EQ ) ( k_any | k_some | k_all ) LPAREN ( grouping_expression_list | select_statement ) RPAREN
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred249_YSmart3561)
        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred249_YSmart3563)
        self.sql_expressions()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred249_YSmart3565)
        if (EQ <= self.input.LA(1) <= NOT_EQ):
            self.input.consume()
            self._state.errorRecovery = False

        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            mse = MismatchedSetException(None, self.input)
            raise mse


        # /home/szr/subquery/SQL2XML/YSmart.g:538:50: ( k_any | k_some | k_all )
        alt232 = 3
        LA232 = self.input.LA(1)
        if LA232 == 98:
            alt232 = 1
        elif LA232 == 362:
            alt232 = 2
        elif LA232 == 95:
            alt232 = 3
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException("", 232, 0, self.input)

            raise nvae

        if alt232 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:538:52: k_any
            pass 
            self._state.following.append(self.FOLLOW_k_any_in_synpred249_YSmart3579)
            self.k_any()

            self._state.following.pop()


        elif alt232 == 2:
            # /home/szr/subquery/SQL2XML/YSmart.g:538:60: k_some
            pass 
            self._state.following.append(self.FOLLOW_k_some_in_synpred249_YSmart3583)
            self.k_some()

            self._state.following.pop()


        elif alt232 == 3:
            # /home/szr/subquery/SQL2XML/YSmart.g:538:69: k_all
            pass 
            self._state.following.append(self.FOLLOW_k_all_in_synpred249_YSmart3587)
            self.k_all()

            self._state.following.pop()



        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred249_YSmart3591)
        # /home/szr/subquery/SQL2XML/YSmart.g:538:84: ( grouping_expression_list | select_statement )
        alt233 = 2
        LA233_0 = self.input.LA(1)

        if ((PLUS <= LA233_0 <= MINUS) or LA233_0 == LPAREN or LA233_0 == NUMBER or (VECTOR <= LA233_0 <= DOUBLEQUOTED_STRING) or LA233_0 == QUOTED_STRING or LA233_0 == 91 or LA233_0 == 105 or LA233_0 == 125 or LA233_0 == 144 or LA233_0 == 160 or LA233_0 == 170 or LA233_0 == 178 or LA233_0 == 180 or LA233_0 == 192 or LA233_0 == 197 or (211 <= LA233_0 <= 367) or (369 <= LA233_0 <= 387) or (390 <= LA233_0 <= 428) or (430 <= LA233_0 <= 439) or (442 <= LA233_0 <= 453) or LA233_0 == 455 or (460 <= LA233_0 <= 528) or (530 <= LA233_0 <= 537) or (539 <= LA233_0 <= 546)) :
            alt233 = 1
        elif (LA233_0 == 182) :
            alt233 = 2
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException("", 233, 0, self.input)

            raise nvae

        if alt233 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:538:86: grouping_expression_list
            pass 
            self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred249_YSmart3595)
            self.grouping_expression_list()

            self._state.following.pop()


        elif alt233 == 2:
            # /home/szr/subquery/SQL2XML/YSmart.g:538:113: select_statement
            pass 
            self._state.following.append(self.FOLLOW_select_statement_in_synpred249_YSmart3599)
            self.select_statement()

            self._state.following.pop()



        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred249_YSmart3603)


    # $ANTLR end "synpred249_YSmart"



    # $ANTLR start "synpred260_YSmart"
    def synpred260_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:542:4: ( LPAREN sql_expressions RPAREN ( k_not )? k_in LPAREN ( grouping_expression_list | select_statement ) RPAREN )
        # /home/szr/subquery/SQL2XML/YSmart.g:542:4: LPAREN sql_expressions RPAREN ( k_not )? k_in LPAREN ( grouping_expression_list | select_statement ) RPAREN
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred260_YSmart3672)
        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred260_YSmart3674)
        self.sql_expressions()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred260_YSmart3676)
        # /home/szr/subquery/SQL2XML/YSmart.g:542:34: ( k_not )?
        alt234 = 2
        LA234_0 = self.input.LA(1)

        if (LA234_0 == 157) :
            alt234 = 1
        if alt234 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:542:36: k_not
            pass 
            self._state.following.append(self.FOLLOW_k_not_in_synpred260_YSmart3680)
            self.k_not()

            self._state.following.pop()



        self._state.following.append(self.FOLLOW_k_in_in_synpred260_YSmart3685)
        self.k_in()

        self._state.following.pop()
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred260_YSmart3687)
        # /home/szr/subquery/SQL2XML/YSmart.g:542:57: ( grouping_expression_list | select_statement )
        alt235 = 2
        LA235_0 = self.input.LA(1)

        if ((PLUS <= LA235_0 <= MINUS) or LA235_0 == LPAREN or LA235_0 == NUMBER or (VECTOR <= LA235_0 <= DOUBLEQUOTED_STRING) or LA235_0 == QUOTED_STRING or LA235_0 == 91 or LA235_0 == 105 or LA235_0 == 125 or LA235_0 == 144 or LA235_0 == 160 or LA235_0 == 170 or LA235_0 == 178 or LA235_0 == 180 or LA235_0 == 192 or LA235_0 == 197 or (211 <= LA235_0 <= 367) or (369 <= LA235_0 <= 387) or (390 <= LA235_0 <= 428) or (430 <= LA235_0 <= 439) or (442 <= LA235_0 <= 453) or LA235_0 == 455 or (460 <= LA235_0 <= 528) or (530 <= LA235_0 <= 537) or (539 <= LA235_0 <= 546)) :
            alt235 = 1
        elif (LA235_0 == 182) :
            alt235 = 2
        else:
            if self._state.backtracking > 0:
                raise BacktrackingFailed

            nvae = NoViableAltException("", 235, 0, self.input)

            raise nvae

        if alt235 == 1:
            # /home/szr/subquery/SQL2XML/YSmart.g:542:59: grouping_expression_list
            pass 
            self._state.following.append(self.FOLLOW_grouping_expression_list_in_synpred260_YSmart3691)
            self.grouping_expression_list()

            self._state.following.pop()


        elif alt235 == 2:
            # /home/szr/subquery/SQL2XML/YSmart.g:542:86: select_statement
            pass 
            self._state.following.append(self.FOLLOW_select_statement_in_synpred260_YSmart3695)
            self.select_statement()

            self._state.following.pop()



        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred260_YSmart3699)


    # $ANTLR end "synpred260_YSmart"



    # $ANTLR start "synpred284_YSmart"
    def synpred284_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:609:6: ( schema_name DOT )
        # /home/szr/subquery/SQL2XML/YSmart.g:609:6: schema_name DOT
        pass 
        self._state.following.append(self.FOLLOW_schema_name_in_synpred284_YSmart4173)
        self.schema_name()

        self._state.following.pop()
        self.match(self.input, DOT, self.FOLLOW_DOT_in_synpred284_YSmart4175)


    # $ANTLR end "synpred284_YSmart"



    # $ANTLR start "synpred285_YSmart"
    def synpred285_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:609:26: ( table_name DOT )
        # /home/szr/subquery/SQL2XML/YSmart.g:609:26: table_name DOT
        pass 
        self._state.following.append(self.FOLLOW_table_name_in_synpred285_YSmart4181)
        self.table_name()

        self._state.following.pop()
        self.match(self.input, DOT, self.FOLLOW_DOT_in_synpred285_YSmart4183)


    # $ANTLR end "synpred285_YSmart"



    # $ANTLR start "synpred287_YSmart"
    def synpred287_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:612:21: ( COMMA sql_expression )
        # /home/szr/subquery/SQL2XML/YSmart.g:612:21: COMMA sql_expression
        pass 
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred287_YSmart4208)
        self._state.following.append(self.FOLLOW_sql_expression_in_synpred287_YSmart4210)
        self.sql_expression()

        self._state.following.pop()


    # $ANTLR end "synpred287_YSmart"



    # $ANTLR start "synpred288_YSmart"
    def synpred288_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:615:22: ( COMMA expression_list )
        # /home/szr/subquery/SQL2XML/YSmart.g:615:22: COMMA expression_list
        pass 
        self.match(self.input, COMMA, self.FOLLOW_COMMA_in_synpred288_YSmart4227)
        self._state.following.append(self.FOLLOW_expression_list_in_synpred288_YSmart4229)
        self.expression_list()

        self._state.following.pop()


    # $ANTLR end "synpred288_YSmart"



    # $ANTLR start "synpred289_YSmart"
    def synpred289_YSmart_fragment(self, ):
        # /home/szr/subquery/SQL2XML/YSmart.g:618:4: ( LPAREN sql_expressions RPAREN )
        # /home/szr/subquery/SQL2XML/YSmart.g:618:4: LPAREN sql_expressions RPAREN
        pass 
        self.match(self.input, LPAREN, self.FOLLOW_LPAREN_in_synpred289_YSmart4242)
        self._state.following.append(self.FOLLOW_sql_expressions_in_synpred289_YSmart4244)
        self.sql_expressions()

        self._state.following.pop()
        self.match(self.input, RPAREN, self.FOLLOW_RPAREN_in_synpred289_YSmart4246)


    # $ANTLR end "synpred289_YSmart"




    # Delegated rules

    def synpred183_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred183_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred185_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred185_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred184_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred184_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred181_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred181_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred201_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred201_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred13_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred13_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred15_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred15_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred51_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred51_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred50_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred50_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred52_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred52_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred53_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred53_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred32_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred32_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred202_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred202_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred205_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred205_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred224_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred224_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred54_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred54_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred226_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred226_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred223_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred223_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred225_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred225_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred227_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred227_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred221_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred221_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred222_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred222_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred220_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred220_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred218_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred218_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred209_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred209_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred235_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred235_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred260_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred260_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred207_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred207_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred242_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred242_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred19_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred19_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred146_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred146_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred284_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred284_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred288_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred288_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred174_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred174_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred20_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred20_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred176_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred176_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred22_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred22_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred23_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred23_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred172_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred172_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred21_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred21_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred177_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred177_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred178_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred178_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred173_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred173_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred26_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred26_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred212_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred212_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred25_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred25_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred27_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred27_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred213_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred213_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred24_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred24_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred214_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred214_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred28_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred28_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred61_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred61_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred215_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred215_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred216_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred216_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred217_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred217_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred48_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred48_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred42_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred42_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred49_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred49_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred45_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred45_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred46_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred46_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred219_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred219_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred243_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred243_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred234_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred234_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred249_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred249_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred285_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred285_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred289_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred289_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success

    def synpred287_YSmart(self):
        self._state.backtracking += 1
        start = self.input.mark()
        try:
            self.synpred287_YSmart_fragment()
        except BacktrackingFailed:
            success = False
        else:
            success = True
        self.input.rewind(start)
        self._state.backtracking -= 1
        return success



    # lookup tables for DFA #7

    DFA7_eot = DFA.unpack(
        u"\23\uffff"
        )

    DFA7_eof = DFA.unpack(
        u"\2\uffff\4\6\1\uffff\12\6\2\uffff"
        )

    DFA7_min = DFA.unpack(
        u"\1\55\1\uffff\4\54\1\uffff\12\54\1\55\1\uffff"
        )

    DFA7_max = DFA.unpack(
        u"\1\u0222\1\uffff\4\u0222\1\uffff\13\u0222\1\uffff"
        )

    DFA7_accept = DFA.unpack(
        u"\1\uffff\1\1\4\uffff\1\3\13\uffff\1\2"
        )

    DFA7_special = DFA.unpack(
        u"\23\uffff"
        )

            
    DFA7_transition = [
        DFA.unpack(u"\1\1\1\uffff\2\6\3\uffff\1\6\7\uffff\1\6\1\uffff\4\2"
        u"\6\uffff\1\6\22\uffff\1\20\15\uffff\1\6\23\uffff\1\6\22\uffff\1"
        u"\6\17\uffff\1\6\11\uffff\1\6\7\uffff\1\4\1\uffff\1\5\13\uffff\1"
        u"\6\4\uffff\1\6\15\uffff\u0099\20\1\10\3\20\1\uffff\23\20\2\uffff"
        u"\15\20\1\7\2\20\1\14\1\12\1\11\1\3\23\20\1\uffff\12\20\2\uffff"
        u"\12\20\1\15\1\16\1\uffff\1\20\4\uffff\53\20\5\6\1\13\1\20\1\17"
        u"\22\20\1\uffff\10\20\1\uffff\10\20"),
        DFA.unpack(u""),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\7\uffff\1\6\1\uffff\4\6\6\uffff\1\6\22"
        u"\uffff\1\6\10\uffff\1\6\4\uffff\1\6\23\uffff\1\6\3\uffff\1\6\16"
        u"\uffff\1\6\17\uffff\1\6\21\uffff\1\6\1\uffff\1\6\13\uffff\1\6\4"
        u"\uffff\1\6\15\uffff\u009d\6\1\uffff\23\6\2\uffff\47\6\1\uffff\12"
        u"\6\2\uffff\14\6\1\uffff\1\6\4\uffff\105\6\1\uffff\10\6\1\uffff"
        u"\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u""),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\2\uffff\5\6\2\uffff\4\6\31\uffff\1\6"
        u"\10\uffff\1\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d"
        u"\6\1\uffff\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff"
        u"\1\6\4\uffff\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\2\6\1\21\6\6\11\uffff\4\6\31\uffff\1\6\10\uffff\1"
        u"\6\34\uffff\1\6\60\uffff\1\6\1\uffff\1\6\36\uffff\u009d\6\1\uffff"
        u"\23\6\2\uffff\47\6\1\uffff\12\6\2\uffff\14\6\1\uffff\1\6\4\uffff"
        u"\53\6\5\uffff\25\6\1\uffff\10\6\1\uffff\10\6"),
        DFA.unpack(u"\1\22\20\uffff\4\6\31\uffff\1\6\126\uffff\1\6\1\uffff"
        u"\1\6\36\uffff\u009d\6\1\uffff\23\6\2\uffff\47\6\1\uffff\12\6\2"
        u"\uffff\14\6\1\uffff\1\6\4\uffff\53\6\5\uffff\25\6\1\uffff\10\6"
        u"\1\uffff\10\6"),
        DFA.unpack(u"")
    ]

    # class definition for DFA #7

    class DFA7(DFA):
        pass


    # lookup tables for DFA #11

    DFA11_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA11_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA11_min = DFA.unpack(
        u"\1\57\3\uffff\1\0\34\uffff"
        )

    DFA11_max = DFA.unpack(
        u"\1\u0222\3\uffff\1\0\34\uffff"
        )

    DFA11_accept = DFA.unpack(
        u"\1\uffff\1\1\1\2\1\3\1\uffff\1\5\32\uffff\1\4"
        )

    DFA11_special = DFA.unpack(
        u"\4\uffff\1\0\34\uffff"
        )

            
    DFA11_transition = [
        DFA.unpack(u"\1\1\1\2\3\uffff\1\5\7\uffff\1\5\1\uffff\4\5\6\uffff"
        u"\1\5\22\uffff\1\5\15\uffff\1\5\23\uffff\1\5\22\uffff\1\5\17\uffff"
        u"\1\5\11\uffff\1\3\7\uffff\1\5\1\uffff\1\5\13\uffff\1\5\4\uffff"
        u"\1\5\15\uffff\u009d\5\1\uffff\23\5\2\uffff\23\5\1\4\23\5\1\uffff"
        u"\12\5\2\uffff\14\5\1\uffff\1\5\4\uffff\105\5\1\uffff\10\5\1\uffff"
        u"\10\5"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #11

    class DFA11(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA11_4 = input.LA(1)

                 
                index11_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred19_YSmart()):
                    s = 32

                elif (True):
                    s = 5

                 
                input.seek(index11_4)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 11, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #13

    DFA13_eot = DFA.unpack(
        u"\43\uffff"
        )

    DFA13_eof = DFA.unpack(
        u"\43\uffff"
        )

    DFA13_min = DFA.unpack(
        u"\1\64\32\0\10\uffff"
        )

    DFA13_max = DFA.unpack(
        u"\1\u0222\32\0\10\uffff"
        )

    DFA13_accept = DFA.unpack(
        u"\33\uffff\1\6\1\1\1\5\1\7\1\4\1\2\1\3\1\10"
        )

    DFA13_special = DFA.unpack(
        u"\1\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1\14\1\15"
        u"\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30\1\31\1"
        u"\32\10\uffff"
        )

            
    DFA13_transition = [
        DFA.unpack(u"\1\32\7\uffff\1\31\1\uffff\4\1\6\uffff\1\30\22\uffff"
        u"\1\27\15\uffff\1\33\23\uffff\1\7\22\uffff\1\13\17\uffff\1\11\21"
        u"\uffff\1\3\1\uffff\1\4\13\uffff\1\12\4\uffff\1\6\15\uffff\u0099"
        u"\27\1\5\3\27\1\uffff\23\27\2\uffff\15\27\1\2\2\27\1\22\1\14\1\10"
        u"\24\27\1\uffff\12\27\2\uffff\12\27\1\24\1\25\1\uffff\1\27\4\uffff"
        u"\53\27\1\21\1\20\1\23\1\17\1\16\1\15\1\27\1\26\22\27\1\uffff\10"
        u"\27\1\uffff\10\27"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #13

    class DFA13(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA13_0 = input.LA(1)

                 
                index13_0 = input.index()
                input.rewind()
                s = -1
                if ((VECTOR <= LA13_0 <= DOUBLEQUOTED_STRING)):
                    s = 1

                elif (LA13_0 == 403):
                    s = 2

                elif (LA13_0 == 178):
                    s = 3

                elif (LA13_0 == 180):
                    s = 4

                elif (LA13_0 == 364):
                    s = 5

                elif (LA13_0 == 197):
                    s = 6

                elif (LA13_0 == 125):
                    s = 7

                elif (LA13_0 == 408):
                    s = 8

                elif (LA13_0 == 160):
                    s = 9

                elif (LA13_0 == 192):
                    s = 10

                elif (LA13_0 == 144):
                    s = 11

                elif (LA13_0 == 407):
                    s = 12

                elif (LA13_0 == 508):
                    s = 13

                elif (LA13_0 == 507):
                    s = 14

                elif (LA13_0 == 506):
                    s = 15

                elif (LA13_0 == 504):
                    s = 16

                elif (LA13_0 == 503):
                    s = 17

                elif (LA13_0 == 406):
                    s = 18

                elif (LA13_0 == 505):
                    s = 19

                elif (LA13_0 == 452):
                    s = 20

                elif (LA13_0 == 453):
                    s = 21

                elif (LA13_0 == 510):
                    s = 22

                elif (LA13_0 == 91 or (211 <= LA13_0 <= 363) or (365 <= LA13_0 <= 367) or (369 <= LA13_0 <= 387) or (390 <= LA13_0 <= 402) or (404 <= LA13_0 <= 405) or (409 <= LA13_0 <= 428) or (430 <= LA13_0 <= 439) or (442 <= LA13_0 <= 451) or LA13_0 == 455 or (460 <= LA13_0 <= 502) or LA13_0 == 509 or (511 <= LA13_0 <= 528) or (530 <= LA13_0 <= 537) or (539 <= LA13_0 <= 546)):
                    s = 23

                elif (LA13_0 == QUOTED_STRING):
                    s = 24

                elif (LA13_0 == NUMBER):
                    s = 25

                elif (LA13_0 == LPAREN):
                    s = 26

                elif (LA13_0 == 105) and (self.synpred26_YSmart()):
                    s = 27

                 
                input.seek(index13_0)
                if s >= 0:
                    return s
            elif s == 1: 
                LA13_1 = input.LA(1)

                 
                index13_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_1)
                if s >= 0:
                    return s
            elif s == 2: 
                LA13_2 = input.LA(1)

                 
                index13_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred24_YSmart()):
                    s = 31

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_2)
                if s >= 0:
                    return s
            elif s == 3: 
                LA13_3 = input.LA(1)

                 
                index13_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_3)
                if s >= 0:
                    return s
            elif s == 4: 
                LA13_4 = input.LA(1)

                 
                index13_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_4)
                if s >= 0:
                    return s
            elif s == 5: 
                LA13_5 = input.LA(1)

                 
                index13_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_5)
                if s >= 0:
                    return s
            elif s == 6: 
                LA13_6 = input.LA(1)

                 
                index13_6 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_6)
                if s >= 0:
                    return s
            elif s == 7: 
                LA13_7 = input.LA(1)

                 
                index13_7 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_7)
                if s >= 0:
                    return s
            elif s == 8: 
                LA13_8 = input.LA(1)

                 
                index13_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_8)
                if s >= 0:
                    return s
            elif s == 9: 
                LA13_9 = input.LA(1)

                 
                index13_9 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_9)
                if s >= 0:
                    return s
            elif s == 10: 
                LA13_10 = input.LA(1)

                 
                index13_10 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_10)
                if s >= 0:
                    return s
            elif s == 11: 
                LA13_11 = input.LA(1)

                 
                index13_11 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_11)
                if s >= 0:
                    return s
            elif s == 12: 
                LA13_12 = input.LA(1)

                 
                index13_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_12)
                if s >= 0:
                    return s
            elif s == 13: 
                LA13_13 = input.LA(1)

                 
                index13_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_13)
                if s >= 0:
                    return s
            elif s == 14: 
                LA13_14 = input.LA(1)

                 
                index13_14 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_14)
                if s >= 0:
                    return s
            elif s == 15: 
                LA13_15 = input.LA(1)

                 
                index13_15 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_15)
                if s >= 0:
                    return s
            elif s == 16: 
                LA13_16 = input.LA(1)

                 
                index13_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_16)
                if s >= 0:
                    return s
            elif s == 17: 
                LA13_17 = input.LA(1)

                 
                index13_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_17)
                if s >= 0:
                    return s
            elif s == 18: 
                LA13_18 = input.LA(1)

                 
                index13_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_18)
                if s >= 0:
                    return s
            elif s == 19: 
                LA13_19 = input.LA(1)

                 
                index13_19 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_19)
                if s >= 0:
                    return s
            elif s == 20: 
                LA13_20 = input.LA(1)

                 
                index13_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_20)
                if s >= 0:
                    return s
            elif s == 21: 
                LA13_21 = input.LA(1)

                 
                index13_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_21)
                if s >= 0:
                    return s
            elif s == 22: 
                LA13_22 = input.LA(1)

                 
                index13_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_22)
                if s >= 0:
                    return s
            elif s == 23: 
                LA13_23 = input.LA(1)

                 
                index13_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred25_YSmart()):
                    s = 29

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_23)
                if s >= 0:
                    return s
            elif s == 24: 
                LA13_24 = input.LA(1)

                 
                index13_24 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_24)
                if s >= 0:
                    return s
            elif s == 25: 
                LA13_25 = input.LA(1)

                 
                index13_25 = input.index()
                input.rewind()
                s = -1
                if (self.synpred21_YSmart()):
                    s = 28

                elif (self.synpred27_YSmart()):
                    s = 30

                 
                input.seek(index13_25)
                if s >= 0:
                    return s
            elif s == 26: 
                LA13_26 = input.LA(1)

                 
                index13_26 = input.index()
                input.rewind()
                s = -1
                if (self.synpred22_YSmart()):
                    s = 32

                elif (self.synpred23_YSmart()):
                    s = 33

                elif (self.synpred28_YSmart()):
                    s = 34

                 
                input.seek(index13_26)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 13, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #17

    DFA17_eot = DFA.unpack(
        u"\42\uffff"
        )

    DFA17_eof = DFA.unpack(
        u"\42\uffff"
        )

    DFA17_min = DFA.unpack(
        u"\1\57\32\uffff\1\0\6\uffff"
        )

    DFA17_max = DFA.unpack(
        u"\1\u0222\32\uffff\1\0\6\uffff"
        )

    DFA17_accept = DFA.unpack(
        u"\1\uffff\1\1\37\uffff\1\2"
        )

    DFA17_special = DFA.unpack(
        u"\33\uffff\1\0\6\uffff"
        )

            
    DFA17_transition = [
        DFA.unpack(u"\2\1\3\uffff\1\1\7\uffff\1\1\1\uffff\4\1\6\uffff\1\1"
        u"\22\uffff\1\1\15\uffff\1\1\23\uffff\1\1\22\uffff\1\1\17\uffff\1"
        u"\1\11\uffff\1\1\7\uffff\1\1\1\uffff\1\1\13\uffff\1\1\4\uffff\1"
        u"\1\15\uffff\u009d\1\1\uffff\23\1\2\uffff\1\33\46\1\1\uffff\12\1"
        u"\2\uffff\14\1\1\uffff\1\1\4\uffff\105\1\1\uffff\10\1\1\uffff\10"
        u"\1"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #17

    class DFA17(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA17_27 = input.LA(1)

                 
                index17_27 = input.index()
                input.rewind()
                s = -1
                if (self.synpred32_YSmart()):
                    s = 1

                elif (True):
                    s = 33

                 
                input.seek(index17_27)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 17, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #21

    DFA21_eot = DFA.unpack(
        u"\112\uffff"
        )

    DFA21_eof = DFA.unpack(
        u"\2\uffff\1\44\107\uffff"
        )

    DFA21_min = DFA.unpack(
        u"\1\74\1\uffff\1\53\107\uffff"
        )

    DFA21_max = DFA.unpack(
        u"\1\u0222\1\uffff\1\u0222\107\uffff"
        )

    DFA21_accept = DFA.unpack(
        u"\1\uffff\1\1\1\uffff\23\3\1\4\1\5\1\2\61\3"
        )

    DFA21_special = DFA.unpack(
        u"\1\0\1\uffff\1\1\107\uffff"
        )

            
    DFA21_transition = [
        DFA.unpack(u"\1\27\1\uffff\4\3\6\uffff\1\26\22\uffff\1\25\41\uffff"
        u"\1\1\22\uffff\1\11\17\uffff\1\7\21\uffff\1\5\1\uffff\1\6\13\uffff"
        u"\1\10\4\uffff\1\1\15\uffff\u0099\25\1\2\3\25\1\uffff\23\25\2\uffff"
        u"\20\25\1\20\1\12\1\4\24\25\1\uffff\12\25\2\uffff\12\25\1\22\1\23"
        u"\1\uffff\1\25\4\uffff\53\25\1\17\1\16\1\21\1\15\1\14\1\13\1\25"
        u"\1\24\22\25\1\uffff\10\25\1\uffff\10\25"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\64\1\42\1\33\1\31\1\111\1\34\1\111\1\33\1\32\1\53"
        u"\1\45\1\uffff\5\30\2\uffff\4\36\6\54\23\uffff\1\110\5\uffff\1\55"
        u"\2\uffff\1\35\1\105\1\uffff\1\104\17\uffff\1\106\2\uffff\1\50\6"
        u"\uffff\1\43\1\uffff\1\60\1\61\2\uffff\1\75\7\uffff\1\52\1\uffff"
        u"\1\76\1\100\1\101\1\77\10\uffff\1\74\11\uffff\1\56\1\62\11\uffff"
        u"\1\40\1\uffff\1\41\15\uffff\1\47\16\uffff\1\57\1\uffff\1\110\1"
        u"\107\55\110\1\46\1\73\154\110\1\uffff\23\110\2\uffff\1\37\26\110"
        u"\1\65\10\110\1\70\3\110\1\63\2\110\1\66\5\110\1\71\2\110\1\102"
        u"\1\110\2\uffff\2\110\1\67\4\110\1\103\4\110\1\uffff\1\110\4\uffff"
        u"\21\110\1\72\31\110\5\uffff\5\110\1\51\17\110\1\uffff\10\110\1"
        u"\uffff\10\110"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #21

    class DFA21(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA21_0 = input.LA(1)

                 
                index21_0 = input.index()
                input.rewind()
                s = -1
                if (LA21_0 == 125 or LA21_0 == 197):
                    s = 1

                elif (LA21_0 == 364):
                    s = 2

                elif ((VECTOR <= LA21_0 <= DOUBLEQUOTED_STRING)) and (self.synpred42_YSmart()):
                    s = 3

                elif (LA21_0 == 408) and (self.synpred42_YSmart()):
                    s = 4

                elif (LA21_0 == 178) and (self.synpred42_YSmart()):
                    s = 5

                elif (LA21_0 == 180) and (self.synpred42_YSmart()):
                    s = 6

                elif (LA21_0 == 160) and (self.synpred42_YSmart()):
                    s = 7

                elif (LA21_0 == 192) and (self.synpred42_YSmart()):
                    s = 8

                elif (LA21_0 == 144) and (self.synpred42_YSmart()):
                    s = 9

                elif (LA21_0 == 407) and (self.synpred42_YSmart()):
                    s = 10

                elif (LA21_0 == 508) and (self.synpred42_YSmart()):
                    s = 11

                elif (LA21_0 == 507) and (self.synpred42_YSmart()):
                    s = 12

                elif (LA21_0 == 506) and (self.synpred42_YSmart()):
                    s = 13

                elif (LA21_0 == 504) and (self.synpred42_YSmart()):
                    s = 14

                elif (LA21_0 == 503) and (self.synpred42_YSmart()):
                    s = 15

                elif (LA21_0 == 406) and (self.synpred42_YSmart()):
                    s = 16

                elif (LA21_0 == 505) and (self.synpred42_YSmart()):
                    s = 17

                elif (LA21_0 == 452) and (self.synpred42_YSmart()):
                    s = 18

                elif (LA21_0 == 453) and (self.synpred42_YSmart()):
                    s = 19

                elif (LA21_0 == 510) and (self.synpred42_YSmart()):
                    s = 20

                elif (LA21_0 == 91 or (211 <= LA21_0 <= 363) or (365 <= LA21_0 <= 367) or (369 <= LA21_0 <= 387) or (390 <= LA21_0 <= 405) or (409 <= LA21_0 <= 428) or (430 <= LA21_0 <= 439) or (442 <= LA21_0 <= 451) or LA21_0 == 455 or (460 <= LA21_0 <= 502) or LA21_0 == 509 or (511 <= LA21_0 <= 528) or (530 <= LA21_0 <= 537) or (539 <= LA21_0 <= 546)) and (self.synpred42_YSmart()):
                    s = 21

                elif (LA21_0 == QUOTED_STRING):
                    s = 22

                elif (LA21_0 == NUMBER):
                    s = 23

                 
                input.seek(index21_0)
                if s >= 0:
                    return s
            elif s == 1: 
                LA21_2 = input.LA(1)

                 
                index21_2 = input.index()
                input.rewind()
                s = -1
                if ((FOUND_ATTR <= LA21_2 <= BULK_ROWCOUNT_ATTR)):
                    s = 24

                elif (LA21_2 == DOT) and (self.synpred42_YSmart()):
                    s = 25

                elif (LA21_2 == EXPONENT) and (self.synpred42_YSmart()):
                    s = 26

                elif (LA21_2 == ASTERISK or LA21_2 == DIVIDE) and (self.synpred42_YSmart()):
                    s = 27

                elif (LA21_2 == MINUS) and (self.synpred42_YSmart()):
                    s = 28

                elif (LA21_2 == 100) and (self.synpred42_YSmart()):
                    s = 29

                elif ((VECTOR <= LA21_2 <= DOUBLEQUOTED_STRING)) and (self.synpred42_YSmart()):
                    s = 30

                elif (LA21_2 == 390) and (self.synpred42_YSmart()):
                    s = 31

                elif (LA21_2 == 178) and (self.synpred42_YSmart()):
                    s = 32

                elif (LA21_2 == 180) and (self.synpred42_YSmart()):
                    s = 33

                elif (LA21_2 == COMMA) and (self.synpred42_YSmart()):
                    s = 34

                elif (LA21_2 == 129) and (self.synpred42_YSmart()):
                    s = 35

                elif (LA21_2 == EOF) and (self.synpred42_YSmart()):
                    s = 36

                elif (LA21_2 == RPAREN) and (self.synpred42_YSmart()):
                    s = 37

                elif (LA21_2 == 258) and (self.synpred42_YSmart()):
                    s = 38

                elif (LA21_2 == 194) and (self.synpred42_YSmart()):
                    s = 39

                elif (LA21_2 == 122) and (self.synpred42_YSmart()):
                    s = 40

                elif (LA21_2 == 513) and (self.synpred42_YSmart()):
                    s = 41

                elif (LA21_2 == 143) and (self.synpred42_YSmart()):
                    s = 42

                elif (LA21_2 == LPAREN) and (self.synpred42_YSmart()):
                    s = 43

                elif ((EQ <= LA21_2 <= LEQ)) and (self.synpred42_YSmart()):
                    s = 44

                elif (LA21_2 == 97) and (self.synpred42_YSmart()):
                    s = 45

                elif (LA21_2 == 167) and (self.synpred42_YSmart()):
                    s = 46

                elif (LA21_2 == 209) and (self.synpred42_YSmart()):
                    s = 47

                elif (LA21_2 == 131) and (self.synpred42_YSmart()):
                    s = 48

                elif (LA21_2 == 132) and (self.synpred42_YSmart()):
                    s = 49

                elif (LA21_2 == 168) and (self.synpred42_YSmart()):
                    s = 50

                elif (LA21_2 == 426) and (self.synpred42_YSmart()):
                    s = 51

                elif (LA21_2 == SEMI) and (self.synpred42_YSmart()):
                    s = 52

                elif (LA21_2 == 413) and (self.synpred42_YSmart()):
                    s = 53

                elif (LA21_2 == 429) and (self.synpred42_YSmart()):
                    s = 54

                elif (LA21_2 == 444) and (self.synpred42_YSmart()):
                    s = 55

                elif (LA21_2 == 422) and (self.synpred42_YSmart()):
                    s = 56

                elif (LA21_2 == 435) and (self.synpred42_YSmart()):
                    s = 57

                elif (LA21_2 == 477) and (self.synpred42_YSmart()):
                    s = 58

                elif (LA21_2 == 259) and (self.synpred42_YSmart()):
                    s = 59

                elif (LA21_2 == 157) and (self.synpred42_YSmart()):
                    s = 60

                elif (LA21_2 == 135) and (self.synpred42_YSmart()):
                    s = 61

                elif (LA21_2 == 145) and (self.synpred42_YSmart()):
                    s = 62

                elif (LA21_2 == 148) and (self.synpred42_YSmart()):
                    s = 63

                elif (LA21_2 == 146) and (self.synpred42_YSmart()):
                    s = 64

                elif (LA21_2 == 147) and (self.synpred42_YSmart()):
                    s = 65

                elif (LA21_2 == 438) and (self.synpred42_YSmart()):
                    s = 66

                elif (LA21_2 == 449) and (self.synpred42_YSmart()):
                    s = 67

                elif (LA21_2 == 103) and (self.synpred42_YSmart()):
                    s = 68

                elif (LA21_2 == 101) and (self.synpred42_YSmart()):
                    s = 69

                elif (LA21_2 == 119) and (self.synpred42_YSmart()):
                    s = 70

                elif (LA21_2 == 212) and (self.synpred42_YSmart()):
                    s = 71

                elif (LA21_2 == 91 or LA21_2 == 211 or (213 <= LA21_2 <= 257) or (260 <= LA21_2 <= 367) or (369 <= LA21_2 <= 387) or (391 <= LA21_2 <= 412) or (414 <= LA21_2 <= 421) or (423 <= LA21_2 <= 425) or (427 <= LA21_2 <= 428) or (430 <= LA21_2 <= 434) or (436 <= LA21_2 <= 437) or LA21_2 == 439 or (442 <= LA21_2 <= 443) or (445 <= LA21_2 <= 448) or (450 <= LA21_2 <= 453) or LA21_2 == 455 or (460 <= LA21_2 <= 476) or (478 <= LA21_2 <= 502) or (508 <= LA21_2 <= 512) or (514 <= LA21_2 <= 528) or (530 <= LA21_2 <= 537) or (539 <= LA21_2 <= 546)) and (self.synpred42_YSmart()):
                    s = 72

                elif (LA21_2 == PLUS or LA21_2 == DOUBLEVERTBAR) and (self.synpred42_YSmart()):
                    s = 73

                 
                input.seek(index21_2)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 21, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #23

    DFA23_eot = DFA.unpack(
        u"\34\uffff"
        )

    DFA23_eof = DFA.unpack(
        u"\34\uffff"
        )

    DFA23_min = DFA.unpack(
        u"\1\74\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4\uffff"
        )

    DFA23_max = DFA.unpack(
        u"\1\u0222\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4"
        u"\uffff"
        )

    DFA23_accept = DFA.unpack(
        u"\6\uffff\1\3\23\uffff\1\1\1\2"
        )

    DFA23_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\2\uffff\1\5\3\uffff\1\6\1\7\4\uffff"
        u"\1\10\1\uffff\1\11\1\12\1\13\1\14\4\uffff"
        )

            
    DFA23_transition = [
        DFA.unpack(u"\1\6\1\uffff\4\1\6\uffff\1\6\22\uffff\1\27\41\uffff"
        u"\1\6\22\uffff\1\6\17\uffff\1\6\21\uffff\1\3\1\uffff\1\4\13\uffff"
        u"\1\6\4\uffff\1\6\15\uffff\u0099\27\1\5\3\27\1\uffff\23\27\2\uffff"
        u"\15\27\1\2\2\27\1\22\1\14\1\10\24\27\1\uffff\12\27\2\uffff\12\27"
        u"\1\24\1\25\1\uffff\1\27\4\uffff\53\27\5\6\1\15\1\27\1\26\22\27"
        u"\1\uffff\10\27\1\uffff\10\27"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #23

    class DFA23(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA23_1 = input.LA(1)

                 
                index23_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA23_2 = input.LA(1)

                 
                index23_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (self.synpred46_YSmart()):
                    s = 27

                elif (True):
                    s = 6

                 
                input.seek(index23_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA23_3 = input.LA(1)

                 
                index23_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA23_4 = input.LA(1)

                 
                index23_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA23_5 = input.LA(1)

                 
                index23_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_5)
                if s >= 0:
                    return s
            elif s == 5: 
                LA23_8 = input.LA(1)

                 
                index23_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_8)
                if s >= 0:
                    return s
            elif s == 6: 
                LA23_12 = input.LA(1)

                 
                index23_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_12)
                if s >= 0:
                    return s
            elif s == 7: 
                LA23_13 = input.LA(1)

                 
                index23_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_13)
                if s >= 0:
                    return s
            elif s == 8: 
                LA23_18 = input.LA(1)

                 
                index23_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_18)
                if s >= 0:
                    return s
            elif s == 9: 
                LA23_20 = input.LA(1)

                 
                index23_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_20)
                if s >= 0:
                    return s
            elif s == 10: 
                LA23_21 = input.LA(1)

                 
                index23_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_21)
                if s >= 0:
                    return s
            elif s == 11: 
                LA23_22 = input.LA(1)

                 
                index23_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_22)
                if s >= 0:
                    return s
            elif s == 12: 
                LA23_23 = input.LA(1)

                 
                index23_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred45_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index23_23)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 23, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #26

    DFA26_eot = DFA.unpack(
        u"\34\uffff"
        )

    DFA26_eof = DFA.unpack(
        u"\34\uffff"
        )

    DFA26_min = DFA.unpack(
        u"\1\74\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4\uffff"
        )

    DFA26_max = DFA.unpack(
        u"\1\u0222\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4"
        u"\uffff"
        )

    DFA26_accept = DFA.unpack(
        u"\6\uffff\1\3\23\uffff\1\1\1\2"
        )

    DFA26_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\2\uffff\1\5\3\uffff\1\6\1\7\4\uffff"
        u"\1\10\1\uffff\1\11\1\12\1\13\1\14\4\uffff"
        )

            
    DFA26_transition = [
        DFA.unpack(u"\1\6\1\uffff\4\1\6\uffff\1\6\22\uffff\1\27\41\uffff"
        u"\1\6\22\uffff\1\6\17\uffff\1\6\21\uffff\1\3\1\uffff\1\4\13\uffff"
        u"\1\6\4\uffff\1\6\15\uffff\u0099\27\1\5\3\27\1\uffff\23\27\2\uffff"
        u"\15\27\1\2\2\27\1\22\1\14\1\10\24\27\1\uffff\12\27\2\uffff\12\27"
        u"\1\24\1\25\1\uffff\1\27\4\uffff\53\27\5\6\1\15\1\27\1\26\22\27"
        u"\1\uffff\10\27\1\uffff\10\27"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #26

    class DFA26(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA26_1 = input.LA(1)

                 
                index26_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA26_2 = input.LA(1)

                 
                index26_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (self.synpred52_YSmart()):
                    s = 27

                elif (True):
                    s = 6

                 
                input.seek(index26_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA26_3 = input.LA(1)

                 
                index26_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA26_4 = input.LA(1)

                 
                index26_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA26_5 = input.LA(1)

                 
                index26_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_5)
                if s >= 0:
                    return s
            elif s == 5: 
                LA26_8 = input.LA(1)

                 
                index26_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_8)
                if s >= 0:
                    return s
            elif s == 6: 
                LA26_12 = input.LA(1)

                 
                index26_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_12)
                if s >= 0:
                    return s
            elif s == 7: 
                LA26_13 = input.LA(1)

                 
                index26_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_13)
                if s >= 0:
                    return s
            elif s == 8: 
                LA26_18 = input.LA(1)

                 
                index26_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_18)
                if s >= 0:
                    return s
            elif s == 9: 
                LA26_20 = input.LA(1)

                 
                index26_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_20)
                if s >= 0:
                    return s
            elif s == 10: 
                LA26_21 = input.LA(1)

                 
                index26_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_21)
                if s >= 0:
                    return s
            elif s == 11: 
                LA26_22 = input.LA(1)

                 
                index26_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_22)
                if s >= 0:
                    return s
            elif s == 12: 
                LA26_23 = input.LA(1)

                 
                index26_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred51_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index26_23)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 26, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #27

    DFA27_eot = DFA.unpack(
        u"\34\uffff"
        )

    DFA27_eof = DFA.unpack(
        u"\34\uffff"
        )

    DFA27_min = DFA.unpack(
        u"\1\74\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4\uffff"
        )

    DFA27_max = DFA.unpack(
        u"\1\u0222\5\0\2\uffff\1\0\3\uffff\2\0\4\uffff\1\0\1\uffff\4\0\4"
        u"\uffff"
        )

    DFA27_accept = DFA.unpack(
        u"\6\uffff\1\3\23\uffff\1\1\1\2"
        )

    DFA27_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\2\uffff\1\5\3\uffff\1\6\1\7\4\uffff"
        u"\1\10\1\uffff\1\11\1\12\1\13\1\14\4\uffff"
        )

            
    DFA27_transition = [
        DFA.unpack(u"\1\6\1\uffff\4\1\6\uffff\1\6\22\uffff\1\27\41\uffff"
        u"\1\6\22\uffff\1\6\17\uffff\1\6\21\uffff\1\3\1\uffff\1\4\13\uffff"
        u"\1\6\4\uffff\1\6\15\uffff\u0099\27\1\5\3\27\1\uffff\23\27\2\uffff"
        u"\15\27\1\2\2\27\1\22\1\14\1\10\24\27\1\uffff\12\27\2\uffff\12\27"
        u"\1\24\1\25\1\uffff\1\27\4\uffff\53\27\5\6\1\15\1\27\1\26\22\27"
        u"\1\uffff\10\27\1\uffff\10\27"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #27

    class DFA27(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA27_1 = input.LA(1)

                 
                index27_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA27_2 = input.LA(1)

                 
                index27_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (self.synpred54_YSmart()):
                    s = 27

                elif (True):
                    s = 6

                 
                input.seek(index27_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA27_3 = input.LA(1)

                 
                index27_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA27_4 = input.LA(1)

                 
                index27_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA27_5 = input.LA(1)

                 
                index27_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_5)
                if s >= 0:
                    return s
            elif s == 5: 
                LA27_8 = input.LA(1)

                 
                index27_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_8)
                if s >= 0:
                    return s
            elif s == 6: 
                LA27_12 = input.LA(1)

                 
                index27_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_12)
                if s >= 0:
                    return s
            elif s == 7: 
                LA27_13 = input.LA(1)

                 
                index27_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_13)
                if s >= 0:
                    return s
            elif s == 8: 
                LA27_18 = input.LA(1)

                 
                index27_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_18)
                if s >= 0:
                    return s
            elif s == 9: 
                LA27_20 = input.LA(1)

                 
                index27_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_20)
                if s >= 0:
                    return s
            elif s == 10: 
                LA27_21 = input.LA(1)

                 
                index27_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_21)
                if s >= 0:
                    return s
            elif s == 11: 
                LA27_22 = input.LA(1)

                 
                index27_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_22)
                if s >= 0:
                    return s
            elif s == 12: 
                LA27_23 = input.LA(1)

                 
                index27_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred53_YSmart()):
                    s = 26

                elif (True):
                    s = 6

                 
                input.seek(index27_23)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 27, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #34

    DFA34_eot = DFA.unpack(
        u"\36\uffff"
        )

    DFA34_eof = DFA.unpack(
        u"\36\uffff"
        )

    DFA34_min = DFA.unpack(
        u"\1\76\5\0\1\uffff\3\0\1\65\4\0\1\65\4\0\1\65\10\0\1\uffff"
        )

    DFA34_max = DFA.unpack(
        u"\1\u0222\5\0\1\uffff\3\0\1\u0189\4\0\1\u014e\4\0\1\u00e7\10\0\1"
        u"\uffff"
        )

    DFA34_accept = DFA.unpack(
        u"\6\uffff\1\1\26\uffff\1\2"
        )

    DFA34_special = DFA.unpack(
        u"\1\uffff\1\1\1\27\1\22\1\16\1\3\1\uffff\1\11\1\4\1\0\1\uffff\1"
        u"\13\1\20\1\24\1\25\1\uffff\1\10\1\14\1\2\1\15\1\uffff\1\17\1\26"
        u"\1\12\1\6\1\23\1\7\1\5\1\21\1\uffff"
        )

            
    DFA34_transition = [
        DFA.unpack(u"\4\35\31\uffff\1\35\16\uffff\1\6\10\uffff\2\6\12\uffff"
        u"\1\6\14\uffff\1\6\11\uffff\1\6\12\uffff\1\6\13\uffff\1\6\4\uffff"
        u"\1\33\1\uffff\1\35\6\uffff\1\6\21\uffff\2\6\4\uffff\24\35\1\20"
        u"\22\35\1\10\3\35\1\17\35\35\1\15\44\35\1\7\23\35\1\16\32\35\1\uffff"
        u"\12\35\1\13\10\35\2\uffff\6\35\1\32\1\3\1\2\1\1\1\27\1\11\2\35"
        u"\1\30\26\35\1\12\1\35\1\uffff\11\35\1\25\2\uffff\1\35\1\24\1\4"
        u"\1\35\1\21\1\31\2\35\1\22\1\23\2\35\1\uffff\1\35\4\uffff\1\35\1"
        u"\26\1\5\35\35\1\14\5\35\1\34\4\35\5\uffff\25\35\1\uffff\10\35\1"
        u"\uffff\10\35"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\35\u00c1\uffff\1\6\u0091\uffff\1\6"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\35\u0118\uffff\1\6"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\35\64\uffff\1\6\174\uffff\1\6"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"")
    ]

    # class definition for DFA #34

    class DFA34(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA34_9 = input.LA(1)

                 
                index34_9 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_9)
                if s >= 0:
                    return s
            elif s == 1: 
                LA34_1 = input.LA(1)

                 
                index34_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_1)
                if s >= 0:
                    return s
            elif s == 2: 
                LA34_18 = input.LA(1)

                 
                index34_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_18)
                if s >= 0:
                    return s
            elif s == 3: 
                LA34_5 = input.LA(1)

                 
                index34_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_5)
                if s >= 0:
                    return s
            elif s == 4: 
                LA34_8 = input.LA(1)

                 
                index34_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_8)
                if s >= 0:
                    return s
            elif s == 5: 
                LA34_27 = input.LA(1)

                 
                index34_27 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_27)
                if s >= 0:
                    return s
            elif s == 6: 
                LA34_24 = input.LA(1)

                 
                index34_24 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_24)
                if s >= 0:
                    return s
            elif s == 7: 
                LA34_26 = input.LA(1)

                 
                index34_26 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_26)
                if s >= 0:
                    return s
            elif s == 8: 
                LA34_16 = input.LA(1)

                 
                index34_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_16)
                if s >= 0:
                    return s
            elif s == 9: 
                LA34_7 = input.LA(1)

                 
                index34_7 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_7)
                if s >= 0:
                    return s
            elif s == 10: 
                LA34_23 = input.LA(1)

                 
                index34_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_23)
                if s >= 0:
                    return s
            elif s == 11: 
                LA34_11 = input.LA(1)

                 
                index34_11 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_11)
                if s >= 0:
                    return s
            elif s == 12: 
                LA34_17 = input.LA(1)

                 
                index34_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_17)
                if s >= 0:
                    return s
            elif s == 13: 
                LA34_19 = input.LA(1)

                 
                index34_19 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_19)
                if s >= 0:
                    return s
            elif s == 14: 
                LA34_4 = input.LA(1)

                 
                index34_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_4)
                if s >= 0:
                    return s
            elif s == 15: 
                LA34_21 = input.LA(1)

                 
                index34_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_21)
                if s >= 0:
                    return s
            elif s == 16: 
                LA34_12 = input.LA(1)

                 
                index34_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_12)
                if s >= 0:
                    return s
            elif s == 17: 
                LA34_28 = input.LA(1)

                 
                index34_28 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_28)
                if s >= 0:
                    return s
            elif s == 18: 
                LA34_3 = input.LA(1)

                 
                index34_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_3)
                if s >= 0:
                    return s
            elif s == 19: 
                LA34_25 = input.LA(1)

                 
                index34_25 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_25)
                if s >= 0:
                    return s
            elif s == 20: 
                LA34_13 = input.LA(1)

                 
                index34_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_13)
                if s >= 0:
                    return s
            elif s == 21: 
                LA34_14 = input.LA(1)

                 
                index34_14 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_14)
                if s >= 0:
                    return s
            elif s == 22: 
                LA34_22 = input.LA(1)

                 
                index34_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_22)
                if s >= 0:
                    return s
            elif s == 23: 
                LA34_2 = input.LA(1)

                 
                index34_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred61_YSmart()):
                    s = 6

                elif (True):
                    s = 29

                 
                input.seek(index34_2)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 34, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #74

    DFA74_eot = DFA.unpack(
        u"\45\uffff"
        )

    DFA74_eof = DFA.unpack(
        u"\45\uffff"
        )

    DFA74_min = DFA.unpack(
        u"\1\152\12\uffff\1\u00f7\31\uffff"
        )

    DFA74_max = DFA.unpack(
        u"\1\u01f2\12\uffff\1\u0189\31\uffff"
        )

    DFA74_accept = DFA.unpack(
        u"\1\uffff\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\uffff\1\15"
        u"\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30\1\31\1"
        u"\32\1\33\1\34\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\13\1\14"
        )

    DFA74_special = DFA.unpack(
        u"\45\uffff"
        )

            
    DFA74_transition = [
        DFA.unpack(u"\1\23\10\uffff\1\12\1\6\12\uffff\1\20\14\uffff\1\15"
        u"\11\uffff\1\7\12\uffff\1\6\13\uffff\1\10\4\uffff\1\41\10\uffff"
        u"\1\17\21\uffff\1\24\1\25\30\uffff\1\26\22\uffff\1\6\3\uffff\1\22"
        u"\35\uffff\1\16\44\uffff\1\6\23\uffff\1\21\45\uffff\1\14\20\uffff"
        u"\1\40\1\3\1\2\1\1\1\35\1\11\2\uffff\1\36\26\uffff\1\13\13\uffff"
        u"\1\33\3\uffff\1\32\1\4\1\uffff\1\27\1\37\2\uffff\1\30\1\31\11\uffff"
        u"\1\34\1\5\35\uffff\1\14\5\uffff\1\42"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\43\u0091\uffff\1\44"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #74

    class DFA74(DFA):
        pass


    # lookup tables for DFA #79

    DFA79_eot = DFA.unpack(
        u"\25\uffff"
        )

    DFA79_eof = DFA.unpack(
        u"\1\uffff\1\16\12\uffff\1\16\2\uffff\4\24\2\uffff"
        )

    DFA79_min = DFA.unpack(
        u"\1\76\1\53\3\56\1\uffff\6\56\1\53\1\76\1\uffff\4\53\2\uffff"
        )

    DFA79_max = DFA.unpack(
        u"\2\u0222\3\56\1\uffff\6\56\2\u0222\1\uffff\4\u0222\2\uffff"
        )

    DFA79_accept = DFA.unpack(
        u"\5\uffff\1\4\10\uffff\1\3\4\uffff\1\1\1\2"
        )

    DFA79_special = DFA.unpack(
        u"\2\uffff\1\5\1\3\1\6\1\uffff\1\2\1\7\1\10\1\1\1\4\1\0\11\uffff"
        )

            
    DFA79_transition = [
        DFA.unpack(u"\4\1\31\uffff\1\14\64\uffff\1\5\17\uffff\1\5\21\uffff"
        u"\1\3\1\uffff\1\4\13\uffff\1\5\22\uffff\u009d\14\1\uffff\23\14\2"
        u"\uffff\20\14\1\10\1\6\1\2\24\14\1\uffff\12\14\2\uffff\12\14\1\11"
        u"\1\12\1\uffff\1\14\4\uffff\53\14\5\5\1\7\1\14\1\13\22\14\1\uffff"
        u"\10\14\1\uffff\10\14"),
        DFA.unpack(u"\3\16\1\15\7\16\7\uffff\13\16\23\uffff\1\16\5\uffff"
        u"\1\16\2\uffff\2\16\1\uffff\1\16\17\uffff\1\16\2\uffff\1\16\6\uffff"
        u"\1\16\1\uffff\2\16\2\uffff\1\16\7\uffff\1\16\1\uffff\4\16\10\uffff"
        u"\1\16\11\uffff\2\16\11\uffff\1\16\1\uffff\1\16\15\uffff\1\16\16"
        u"\uffff\1\16\1\uffff\u009d\16\1\uffff\23\16\2\uffff\62\16\2\uffff"
        u"\14\16\1\uffff\1\16\4\uffff\53\16\5\uffff\25\16\1\uffff\10\16\1"
        u"\uffff\10\16"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\1\15"),
        DFA.unpack(u"\3\16\1\15\7\16\7\uffff\13\16\23\uffff\1\16\5\uffff"
        u"\1\16\2\uffff\2\16\1\uffff\1\16\17\uffff\1\16\2\uffff\1\16\6\uffff"
        u"\1\16\1\uffff\2\16\2\uffff\1\16\7\uffff\1\16\1\uffff\4\16\10\uffff"
        u"\1\16\11\uffff\2\16\11\uffff\1\16\1\uffff\1\16\15\uffff\1\16\16"
        u"\uffff\1\16\1\uffff\u009d\16\1\uffff\23\16\2\uffff\62\16\2\uffff"
        u"\14\16\1\uffff\1\16\4\uffff\53\16\5\uffff\25\16\1\uffff\10\16\1"
        u"\uffff\10\16"),
        DFA.unpack(u"\4\17\31\uffff\1\20\126\uffff\1\21\1\uffff\1\22\36"
        u"\uffff\u009d\20\1\uffff\23\20\2\uffff\47\20\1\uffff\12\20\2\uffff"
        u"\14\20\1\uffff\1\20\4\uffff\53\20\5\uffff\25\20\1\uffff\10\20\1"
        u"\uffff\10\20"),
        DFA.unpack(u""),
        DFA.unpack(u"\3\24\1\23\7\24\7\uffff\13\24\23\uffff\1\24\5\uffff"
        u"\1\24\2\uffff\2\24\1\uffff\1\24\17\uffff\1\24\2\uffff\1\24\6\uffff"
        u"\1\24\1\uffff\2\24\2\uffff\1\24\7\uffff\1\24\1\uffff\4\24\10\uffff"
        u"\1\24\11\uffff\2\24\11\uffff\1\24\1\uffff\1\24\15\uffff\1\24\16"
        u"\uffff\1\24\1\uffff\u009d\24\1\uffff\23\24\2\uffff\62\24\2\uffff"
        u"\14\24\1\uffff\1\24\4\uffff\53\24\5\uffff\25\24\1\uffff\10\24\1"
        u"\uffff\10\24"),
        DFA.unpack(u"\3\24\1\23\7\24\7\uffff\13\24\23\uffff\1\24\5\uffff"
        u"\1\24\2\uffff\2\24\1\uffff\1\24\17\uffff\1\24\2\uffff\1\24\6\uffff"
        u"\1\24\1\uffff\2\24\2\uffff\1\24\7\uffff\1\24\1\uffff\4\24\10\uffff"
        u"\1\24\11\uffff\2\24\11\uffff\1\24\1\uffff\1\24\15\uffff\1\24\16"
        u"\uffff\1\24\1\uffff\u009d\24\1\uffff\23\24\2\uffff\62\24\2\uffff"
        u"\14\24\1\uffff\1\24\4\uffff\53\24\5\uffff\25\24\1\uffff\10\24\1"
        u"\uffff\10\24"),
        DFA.unpack(u"\3\24\1\23\7\24\7\uffff\13\24\23\uffff\1\24\5\uffff"
        u"\1\24\2\uffff\2\24\1\uffff\1\24\17\uffff\1\24\2\uffff\1\24\6\uffff"
        u"\1\24\1\uffff\2\24\2\uffff\1\24\7\uffff\1\24\1\uffff\4\24\10\uffff"
        u"\1\24\11\uffff\2\24\11\uffff\1\24\1\uffff\1\24\15\uffff\1\24\16"
        u"\uffff\1\24\1\uffff\u009d\24\1\uffff\23\24\2\uffff\62\24\2\uffff"
        u"\14\24\1\uffff\1\24\4\uffff\53\24\5\uffff\25\24\1\uffff\10\24\1"
        u"\uffff\10\24"),
        DFA.unpack(u"\3\24\1\23\7\24\7\uffff\13\24\23\uffff\1\24\5\uffff"
        u"\1\24\2\uffff\2\24\1\uffff\1\24\17\uffff\1\24\2\uffff\1\24\6\uffff"
        u"\1\24\1\uffff\2\24\2\uffff\1\24\7\uffff\1\24\1\uffff\4\24\10\uffff"
        u"\1\24\11\uffff\2\24\11\uffff\1\24\1\uffff\1\24\15\uffff\1\24\16"
        u"\uffff\1\24\1\uffff\u009d\24\1\uffff\23\24\2\uffff\62\24\2\uffff"
        u"\14\24\1\uffff\1\24\4\uffff\53\24\5\uffff\25\24\1\uffff\10\24\1"
        u"\uffff\10\24"),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #79

    class DFA79(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA79_11 = input.LA(1)

                 
                index79_11 = input.index()
                input.rewind()
                s = -1
                if (LA79_11 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_11)
                if s >= 0:
                    return s
            elif s == 1: 
                LA79_9 = input.LA(1)

                 
                index79_9 = input.index()
                input.rewind()
                s = -1
                if (LA79_9 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_9)
                if s >= 0:
                    return s
            elif s == 2: 
                LA79_6 = input.LA(1)

                 
                index79_6 = input.index()
                input.rewind()
                s = -1
                if (LA79_6 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_6)
                if s >= 0:
                    return s
            elif s == 3: 
                LA79_3 = input.LA(1)

                 
                index79_3 = input.index()
                input.rewind()
                s = -1
                if (LA79_3 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_3)
                if s >= 0:
                    return s
            elif s == 4: 
                LA79_10 = input.LA(1)

                 
                index79_10 = input.index()
                input.rewind()
                s = -1
                if (LA79_10 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_10)
                if s >= 0:
                    return s
            elif s == 5: 
                LA79_2 = input.LA(1)

                 
                index79_2 = input.index()
                input.rewind()
                s = -1
                if (LA79_2 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_2)
                if s >= 0:
                    return s
            elif s == 6: 
                LA79_4 = input.LA(1)

                 
                index79_4 = input.index()
                input.rewind()
                s = -1
                if (LA79_4 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_4)
                if s >= 0:
                    return s
            elif s == 7: 
                LA79_7 = input.LA(1)

                 
                index79_7 = input.index()
                input.rewind()
                s = -1
                if (LA79_7 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_7)
                if s >= 0:
                    return s
            elif s == 8: 
                LA79_8 = input.LA(1)

                 
                index79_8 = input.index()
                input.rewind()
                s = -1
                if (LA79_8 == DOT):
                    s = 13

                elif (self.synpred146_YSmart()):
                    s = 14

                elif (True):
                    s = 5

                 
                input.seek(index79_8)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 79, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #81

    DFA81_eot = DFA.unpack(
        u"\15\uffff"
        )

    DFA81_eof = DFA.unpack(
        u"\15\uffff"
        )

    DFA81_min = DFA.unpack(
        u"\1\76\4\56\1\76\1\uffff\4\56\2\uffff"
        )

    DFA81_max = DFA.unpack(
        u"\1\u0222\4\64\1\u0222\1\uffff\4\64\2\uffff"
        )

    DFA81_accept = DFA.unpack(
        u"\6\uffff\1\3\4\uffff\1\1\1\2"
        )

    DFA81_special = DFA.unpack(
        u"\15\uffff"
        )

            
    DFA81_transition = [
        DFA.unpack(u"\4\1\31\uffff\1\2\126\uffff\1\3\1\uffff\1\4\36\uffff"
        u"\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2\uffff\14\2\1"
        u"\uffff\1\2\4\uffff\53\2\5\uffff\25\2\1\uffff\10\2\1\uffff\10\2"),
        DFA.unpack(u"\1\5\5\uffff\1\6"),
        DFA.unpack(u"\1\5\5\uffff\1\6"),
        DFA.unpack(u"\1\5\5\uffff\1\6"),
        DFA.unpack(u"\1\5\5\uffff\1\6"),
        DFA.unpack(u"\4\7\31\uffff\1\10\126\uffff\1\11\1\uffff\1\12\36\uffff"
        u"\u009d\10\1\uffff\23\10\2\uffff\47\10\1\uffff\12\10\2\uffff\14"
        u"\10\1\uffff\1\10\4\uffff\53\10\5\uffff\25\10\1\uffff\10\10\1\uffff"
        u"\10\10"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\13\5\uffff\1\14"),
        DFA.unpack(u"\1\13\5\uffff\1\14"),
        DFA.unpack(u"\1\13\5\uffff\1\14"),
        DFA.unpack(u"\1\13\5\uffff\1\14"),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #81

    class DFA81(DFA):
        pass


    # lookup tables for DFA #84

    DFA84_eot = DFA.unpack(
        u"\12\uffff"
        )

    DFA84_eof = DFA.unpack(
        u"\12\uffff"
        )

    DFA84_min = DFA.unpack(
        u"\1\64\5\0\4\uffff"
        )

    DFA84_max = DFA.unpack(
        u"\1\u0222\5\0\4\uffff"
        )

    DFA84_accept = DFA.unpack(
        u"\6\uffff\1\1\1\2\1\4\1\3"
        )

    DFA84_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\4\uffff"
        )

            
    DFA84_transition = [
        DFA.unpack(u"\1\5\11\uffff\4\1\31\uffff\1\2\126\uffff\1\3\1\uffff"
        u"\1\4\36\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2"
        u"\uffff\14\2\1\uffff\1\2\4\uffff\53\2\5\uffff\25\2\1\uffff\10\2"
        u"\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #84

    class DFA84(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA84_1 = input.LA(1)

                 
                index84_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred172_YSmart()):
                    s = 6

                elif (self.synpred173_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index84_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA84_2 = input.LA(1)

                 
                index84_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred172_YSmart()):
                    s = 6

                elif (self.synpred173_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index84_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA84_3 = input.LA(1)

                 
                index84_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred172_YSmart()):
                    s = 6

                elif (self.synpred173_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index84_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA84_4 = input.LA(1)

                 
                index84_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred172_YSmart()):
                    s = 6

                elif (self.synpred173_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index84_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA84_5 = input.LA(1)

                 
                index84_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred173_YSmart()):
                    s = 7

                elif (self.synpred174_YSmart()):
                    s = 9

                elif (True):
                    s = 8

                 
                input.seek(index84_5)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 84, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #86

    DFA86_eot = DFA.unpack(
        u"\12\uffff"
        )

    DFA86_eof = DFA.unpack(
        u"\12\uffff"
        )

    DFA86_min = DFA.unpack(
        u"\1\64\5\0\4\uffff"
        )

    DFA86_max = DFA.unpack(
        u"\1\u0222\5\0\4\uffff"
        )

    DFA86_accept = DFA.unpack(
        u"\6\uffff\1\1\1\2\1\4\1\3"
        )

    DFA86_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\4\uffff"
        )

            
    DFA86_transition = [
        DFA.unpack(u"\1\5\11\uffff\4\1\31\uffff\1\2\126\uffff\1\3\1\uffff"
        u"\1\4\36\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2"
        u"\uffff\14\2\1\uffff\1\2\4\uffff\53\2\5\uffff\25\2\1\uffff\10\2"
        u"\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #86

    class DFA86(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA86_1 = input.LA(1)

                 
                index86_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred176_YSmart()):
                    s = 6

                elif (self.synpred177_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index86_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA86_2 = input.LA(1)

                 
                index86_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred176_YSmart()):
                    s = 6

                elif (self.synpred177_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index86_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA86_3 = input.LA(1)

                 
                index86_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred176_YSmart()):
                    s = 6

                elif (self.synpred177_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index86_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA86_4 = input.LA(1)

                 
                index86_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred176_YSmart()):
                    s = 6

                elif (self.synpred177_YSmart()):
                    s = 7

                elif (True):
                    s = 8

                 
                input.seek(index86_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA86_5 = input.LA(1)

                 
                index86_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred177_YSmart()):
                    s = 7

                elif (self.synpred178_YSmart()):
                    s = 9

                elif (True):
                    s = 8

                 
                input.seek(index86_5)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 86, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #89

    DFA89_eot = DFA.unpack(
        u"\27\uffff"
        )

    DFA89_eof = DFA.unpack(
        u"\1\5\26\uffff"
        )

    DFA89_min = DFA.unpack(
        u"\1\53\1\uffff\1\0\7\uffff\1\0\2\uffff\1\0\1\uffff\4\0\4\uffff"
        )

    DFA89_max = DFA.unpack(
        u"\1\u0222\1\uffff\1\0\7\uffff\1\0\2\uffff\1\0\1\uffff\4\0\4\uffff"
        )

    DFA89_accept = DFA.unpack(
        u"\1\uffff\1\1\3\uffff\1\2\21\uffff"
        )

    DFA89_special = DFA.unpack(
        u"\2\uffff\1\0\7\uffff\1\1\2\uffff\1\2\1\uffff\1\3\1\4\1\5\1\6\4"
        u"\uffff"
        )

            
    DFA89_transition = [
        DFA.unpack(u"\2\5\10\uffff\1\5\10\uffff\4\1\31\uffff\1\1\47\uffff"
        u"\2\5\37\uffff\1\5\3\uffff\1\5\11\uffff\1\1\1\uffff\1\1\34\uffff"
        u"\1\5\1\uffff\u009d\1\1\uffff\23\1\1\5\1\uffff\27\1\1\15\10\1\1"
        u"\20\3\1\1\12\2\1\1\5\5\1\1\21\4\1\2\uffff\2\1\1\17\11\1\1\uffff"
        u"\1\1\4\uffff\21\1\1\22\31\1\5\uffff\5\1\1\2\17\1\1\uffff\10\1\1"
        u"\uffff\10\1"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #89

    class DFA89(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA89_2 = input.LA(1)

                 
                index89_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_2)
                if s >= 0:
                    return s
            elif s == 1: 
                LA89_10 = input.LA(1)

                 
                index89_10 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_10)
                if s >= 0:
                    return s
            elif s == 2: 
                LA89_13 = input.LA(1)

                 
                index89_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_13)
                if s >= 0:
                    return s
            elif s == 3: 
                LA89_15 = input.LA(1)

                 
                index89_15 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_15)
                if s >= 0:
                    return s
            elif s == 4: 
                LA89_16 = input.LA(1)

                 
                index89_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_16)
                if s >= 0:
                    return s
            elif s == 5: 
                LA89_17 = input.LA(1)

                 
                index89_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_17)
                if s >= 0:
                    return s
            elif s == 6: 
                LA89_18 = input.LA(1)

                 
                index89_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred181_YSmart()):
                    s = 1

                elif (True):
                    s = 5

                 
                input.seek(index89_18)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 89, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #91

    DFA91_eot = DFA.unpack(
        u"\21\uffff"
        )

    DFA91_eof = DFA.unpack(
        u"\1\1\20\uffff"
        )

    DFA91_min = DFA.unpack(
        u"\1\53\14\uffff\1\0\3\uffff"
        )

    DFA91_max = DFA.unpack(
        u"\1\u0201\14\uffff\1\0\3\uffff"
        )

    DFA91_accept = DFA.unpack(
        u"\1\uffff\1\3\10\uffff\1\1\3\uffff\1\2\2\uffff"
        )

    DFA91_special = DFA.unpack(
        u"\15\uffff\1\0\3\uffff"
        )

            
    DFA91_transition = [
        DFA.unpack(u"\2\1\10\uffff\1\1\115\uffff\2\1\43\uffff\1\1\50\uffff"
        u"\1\1\u00cb\uffff\1\12\10\uffff\1\16\3\uffff\1\12\2\uffff\1\12\5"
        u"\uffff\1\16\10\uffff\1\15\40\uffff\1\16\43\uffff\1\1"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #91

    class DFA91(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA91_13 = input.LA(1)

                 
                index91_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred184_YSmart()):
                    s = 10

                elif (self.synpred185_YSmart()):
                    s = 14

                 
                input.seek(index91_13)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 91, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #105

    DFA105_eot = DFA.unpack(
        u"\45\uffff"
        )

    DFA105_eof = DFA.unpack(
        u"\45\uffff"
        )

    DFA105_min = DFA.unpack(
        u"\1\57\3\0\41\uffff"
        )

    DFA105_max = DFA.unpack(
        u"\1\u0222\3\0\41\uffff"
        )

    DFA105_accept = DFA.unpack(
        u"\4\uffff\1\3\36\uffff\1\1\1\2"
        )

    DFA105_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\41\uffff"
        )

            
    DFA105_transition = [
        DFA.unpack(u"\2\4\3\uffff\1\4\7\uffff\1\4\1\uffff\4\4\6\uffff\1\4"
        u"\22\uffff\1\4\15\uffff\1\4\23\uffff\1\4\22\uffff\1\4\17\uffff\1"
        u"\4\11\uffff\1\4\7\uffff\1\4\1\uffff\1\4\13\uffff\1\4\4\uffff\1"
        u"\4\15\uffff\u009d\4\1\uffff\23\4\2\uffff\30\4\1\2\10\4\1\3\5\4"
        u"\1\uffff\12\4\2\uffff\14\4\1\uffff\1\4\4\uffff\22\4\1\1\62\4\1"
        u"\uffff\10\4\1\uffff\10\4"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #105

    class DFA105(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA105_1 = input.LA(1)

                 
                index105_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred201_YSmart()):
                    s = 35

                elif (True):
                    s = 4

                 
                input.seek(index105_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA105_2 = input.LA(1)

                 
                index105_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred201_YSmart()):
                    s = 35

                elif (True):
                    s = 4

                 
                input.seek(index105_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA105_3 = input.LA(1)

                 
                index105_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred202_YSmart()):
                    s = 36

                elif (True):
                    s = 4

                 
                input.seek(index105_3)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 105, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #108

    DFA108_eot = DFA.unpack(
        u"\43\uffff"
        )

    DFA108_eof = DFA.unpack(
        u"\43\uffff"
        )

    DFA108_min = DFA.unpack(
        u"\1\57\2\0\40\uffff"
        )

    DFA108_max = DFA.unpack(
        u"\1\u0222\2\0\40\uffff"
        )

    DFA108_accept = DFA.unpack(
        u"\3\uffff\1\2\36\uffff\1\1"
        )

    DFA108_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\40\uffff"
        )

            
    DFA108_transition = [
        DFA.unpack(u"\2\3\3\uffff\1\3\7\uffff\1\3\1\uffff\4\3\6\uffff\1\3"
        u"\22\uffff\1\3\15\uffff\1\3\23\uffff\1\3\22\uffff\1\3\17\uffff\1"
        u"\3\11\uffff\1\3\7\uffff\1\3\1\uffff\1\3\13\uffff\1\3\4\uffff\1"
        u"\3\15\uffff\u009d\3\1\uffff\23\3\2\uffff\30\3\1\2\16\3\1\uffff"
        u"\12\3\2\uffff\14\3\1\uffff\1\3\4\uffff\22\3\1\1\62\3\1\uffff\10"
        u"\3\1\uffff\10\3"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #108

    class DFA108(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA108_1 = input.LA(1)

                 
                index108_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred205_YSmart()):
                    s = 34

                elif (True):
                    s = 3

                 
                input.seek(index108_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA108_2 = input.LA(1)

                 
                index108_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred205_YSmart()):
                    s = 34

                elif (True):
                    s = 3

                 
                input.seek(index108_2)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 108, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #110

    DFA110_eot = DFA.unpack(
        u"\50\uffff"
        )

    DFA110_eof = DFA.unpack(
        u"\50\uffff"
        )

    DFA110_min = DFA.unpack(
        u"\1\57\45\0\2\uffff"
        )

    DFA110_max = DFA.unpack(
        u"\1\u0222\45\0\2\uffff"
        )

    DFA110_accept = DFA.unpack(
        u"\46\uffff\1\1\1\2"
        )

    DFA110_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1"
        u"\14\1\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30"
        u"\1\31\1\32\1\33\1\34\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44\2"
        u"\uffff"
        )

            
    DFA110_transition = [
        DFA.unpack(u"\1\3\1\4\3\uffff\1\40\7\uffff\1\37\1\uffff\4\7\6\uffff"
        u"\1\36\22\uffff\1\45\6\uffff\1\42\6\uffff\1\41\22\uffff\1\2\1\15"
        u"\22\uffff\1\21\14\uffff\1\1\2\uffff\1\17\11\uffff\1\5\7\uffff\1"
        u"\11\1\uffff\1\12\13\uffff\1\20\4\uffff\1\14\15\uffff\u0099\45\1"
        u"\13\3\45\1\uffff\23\45\2\uffff\15\45\1\10\2\45\1\30\1\22\1\16\1"
        u"\6\12\45\1\43\10\45\1\uffff\12\45\2\uffff\12\45\1\32\1\33\1\uffff"
        u"\1\45\4\uffff\7\45\1\35\33\45\1\44\7\45\1\27\1\26\1\31\1\25\1\24"
        u"\1\23\1\45\1\34\22\45\1\uffff\10\45\1\uffff\10\45"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #110

    class DFA110(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA110_1 = input.LA(1)

                 
                index110_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA110_2 = input.LA(1)

                 
                index110_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA110_3 = input.LA(1)

                 
                index110_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA110_4 = input.LA(1)

                 
                index110_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA110_5 = input.LA(1)

                 
                index110_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_5)
                if s >= 0:
                    return s
            elif s == 5: 
                LA110_6 = input.LA(1)

                 
                index110_6 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_6)
                if s >= 0:
                    return s
            elif s == 6: 
                LA110_7 = input.LA(1)

                 
                index110_7 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_7)
                if s >= 0:
                    return s
            elif s == 7: 
                LA110_8 = input.LA(1)

                 
                index110_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_8)
                if s >= 0:
                    return s
            elif s == 8: 
                LA110_9 = input.LA(1)

                 
                index110_9 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_9)
                if s >= 0:
                    return s
            elif s == 9: 
                LA110_10 = input.LA(1)

                 
                index110_10 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_10)
                if s >= 0:
                    return s
            elif s == 10: 
                LA110_11 = input.LA(1)

                 
                index110_11 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_11)
                if s >= 0:
                    return s
            elif s == 11: 
                LA110_12 = input.LA(1)

                 
                index110_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_12)
                if s >= 0:
                    return s
            elif s == 12: 
                LA110_13 = input.LA(1)

                 
                index110_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_13)
                if s >= 0:
                    return s
            elif s == 13: 
                LA110_14 = input.LA(1)

                 
                index110_14 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_14)
                if s >= 0:
                    return s
            elif s == 14: 
                LA110_15 = input.LA(1)

                 
                index110_15 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_15)
                if s >= 0:
                    return s
            elif s == 15: 
                LA110_16 = input.LA(1)

                 
                index110_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_16)
                if s >= 0:
                    return s
            elif s == 16: 
                LA110_17 = input.LA(1)

                 
                index110_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_17)
                if s >= 0:
                    return s
            elif s == 17: 
                LA110_18 = input.LA(1)

                 
                index110_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_18)
                if s >= 0:
                    return s
            elif s == 18: 
                LA110_19 = input.LA(1)

                 
                index110_19 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_19)
                if s >= 0:
                    return s
            elif s == 19: 
                LA110_20 = input.LA(1)

                 
                index110_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_20)
                if s >= 0:
                    return s
            elif s == 20: 
                LA110_21 = input.LA(1)

                 
                index110_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_21)
                if s >= 0:
                    return s
            elif s == 21: 
                LA110_22 = input.LA(1)

                 
                index110_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_22)
                if s >= 0:
                    return s
            elif s == 22: 
                LA110_23 = input.LA(1)

                 
                index110_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_23)
                if s >= 0:
                    return s
            elif s == 23: 
                LA110_24 = input.LA(1)

                 
                index110_24 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_24)
                if s >= 0:
                    return s
            elif s == 24: 
                LA110_25 = input.LA(1)

                 
                index110_25 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_25)
                if s >= 0:
                    return s
            elif s == 25: 
                LA110_26 = input.LA(1)

                 
                index110_26 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_26)
                if s >= 0:
                    return s
            elif s == 26: 
                LA110_27 = input.LA(1)

                 
                index110_27 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_27)
                if s >= 0:
                    return s
            elif s == 27: 
                LA110_28 = input.LA(1)

                 
                index110_28 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_28)
                if s >= 0:
                    return s
            elif s == 28: 
                LA110_29 = input.LA(1)

                 
                index110_29 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_29)
                if s >= 0:
                    return s
            elif s == 29: 
                LA110_30 = input.LA(1)

                 
                index110_30 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_30)
                if s >= 0:
                    return s
            elif s == 30: 
                LA110_31 = input.LA(1)

                 
                index110_31 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_31)
                if s >= 0:
                    return s
            elif s == 31: 
                LA110_32 = input.LA(1)

                 
                index110_32 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_32)
                if s >= 0:
                    return s
            elif s == 32: 
                LA110_33 = input.LA(1)

                 
                index110_33 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_33)
                if s >= 0:
                    return s
            elif s == 33: 
                LA110_34 = input.LA(1)

                 
                index110_34 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_34)
                if s >= 0:
                    return s
            elif s == 34: 
                LA110_35 = input.LA(1)

                 
                index110_35 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_35)
                if s >= 0:
                    return s
            elif s == 35: 
                LA110_36 = input.LA(1)

                 
                index110_36 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_36)
                if s >= 0:
                    return s
            elif s == 36: 
                LA110_37 = input.LA(1)

                 
                index110_37 = input.index()
                input.rewind()
                s = -1
                if (self.synpred207_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index110_37)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 110, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #112

    DFA112_eot = DFA.unpack(
        u"\50\uffff"
        )

    DFA112_eof = DFA.unpack(
        u"\50\uffff"
        )

    DFA112_min = DFA.unpack(
        u"\1\57\45\0\2\uffff"
        )

    DFA112_max = DFA.unpack(
        u"\1\u0222\45\0\2\uffff"
        )

    DFA112_accept = DFA.unpack(
        u"\46\uffff\1\1\1\2"
        )

    DFA112_special = DFA.unpack(
        u"\1\uffff\1\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1"
        u"\14\1\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30"
        u"\1\31\1\32\1\33\1\34\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44\2"
        u"\uffff"
        )

            
    DFA112_transition = [
        DFA.unpack(u"\1\3\1\4\3\uffff\1\40\7\uffff\1\37\1\uffff\4\7\6\uffff"
        u"\1\36\22\uffff\1\45\6\uffff\1\42\6\uffff\1\41\22\uffff\1\2\1\15"
        u"\22\uffff\1\21\14\uffff\1\1\2\uffff\1\17\11\uffff\1\5\7\uffff\1"
        u"\11\1\uffff\1\12\13\uffff\1\20\4\uffff\1\14\15\uffff\u0099\45\1"
        u"\13\3\45\1\uffff\23\45\2\uffff\15\45\1\10\2\45\1\30\1\22\1\16\1"
        u"\6\12\45\1\43\10\45\1\uffff\12\45\2\uffff\12\45\1\32\1\33\1\uffff"
        u"\1\45\4\uffff\7\45\1\35\33\45\1\44\7\45\1\27\1\26\1\31\1\25\1\24"
        u"\1\23\1\45\1\34\22\45\1\uffff\10\45\1\uffff\10\45"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #112

    class DFA112(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA112_1 = input.LA(1)

                 
                index112_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_1)
                if s >= 0:
                    return s
            elif s == 1: 
                LA112_2 = input.LA(1)

                 
                index112_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_2)
                if s >= 0:
                    return s
            elif s == 2: 
                LA112_3 = input.LA(1)

                 
                index112_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_3)
                if s >= 0:
                    return s
            elif s == 3: 
                LA112_4 = input.LA(1)

                 
                index112_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_4)
                if s >= 0:
                    return s
            elif s == 4: 
                LA112_5 = input.LA(1)

                 
                index112_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_5)
                if s >= 0:
                    return s
            elif s == 5: 
                LA112_6 = input.LA(1)

                 
                index112_6 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_6)
                if s >= 0:
                    return s
            elif s == 6: 
                LA112_7 = input.LA(1)

                 
                index112_7 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_7)
                if s >= 0:
                    return s
            elif s == 7: 
                LA112_8 = input.LA(1)

                 
                index112_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_8)
                if s >= 0:
                    return s
            elif s == 8: 
                LA112_9 = input.LA(1)

                 
                index112_9 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_9)
                if s >= 0:
                    return s
            elif s == 9: 
                LA112_10 = input.LA(1)

                 
                index112_10 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_10)
                if s >= 0:
                    return s
            elif s == 10: 
                LA112_11 = input.LA(1)

                 
                index112_11 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_11)
                if s >= 0:
                    return s
            elif s == 11: 
                LA112_12 = input.LA(1)

                 
                index112_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_12)
                if s >= 0:
                    return s
            elif s == 12: 
                LA112_13 = input.LA(1)

                 
                index112_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_13)
                if s >= 0:
                    return s
            elif s == 13: 
                LA112_14 = input.LA(1)

                 
                index112_14 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_14)
                if s >= 0:
                    return s
            elif s == 14: 
                LA112_15 = input.LA(1)

                 
                index112_15 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_15)
                if s >= 0:
                    return s
            elif s == 15: 
                LA112_16 = input.LA(1)

                 
                index112_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_16)
                if s >= 0:
                    return s
            elif s == 16: 
                LA112_17 = input.LA(1)

                 
                index112_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_17)
                if s >= 0:
                    return s
            elif s == 17: 
                LA112_18 = input.LA(1)

                 
                index112_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_18)
                if s >= 0:
                    return s
            elif s == 18: 
                LA112_19 = input.LA(1)

                 
                index112_19 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_19)
                if s >= 0:
                    return s
            elif s == 19: 
                LA112_20 = input.LA(1)

                 
                index112_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_20)
                if s >= 0:
                    return s
            elif s == 20: 
                LA112_21 = input.LA(1)

                 
                index112_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_21)
                if s >= 0:
                    return s
            elif s == 21: 
                LA112_22 = input.LA(1)

                 
                index112_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_22)
                if s >= 0:
                    return s
            elif s == 22: 
                LA112_23 = input.LA(1)

                 
                index112_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_23)
                if s >= 0:
                    return s
            elif s == 23: 
                LA112_24 = input.LA(1)

                 
                index112_24 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_24)
                if s >= 0:
                    return s
            elif s == 24: 
                LA112_25 = input.LA(1)

                 
                index112_25 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_25)
                if s >= 0:
                    return s
            elif s == 25: 
                LA112_26 = input.LA(1)

                 
                index112_26 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_26)
                if s >= 0:
                    return s
            elif s == 26: 
                LA112_27 = input.LA(1)

                 
                index112_27 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_27)
                if s >= 0:
                    return s
            elif s == 27: 
                LA112_28 = input.LA(1)

                 
                index112_28 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_28)
                if s >= 0:
                    return s
            elif s == 28: 
                LA112_29 = input.LA(1)

                 
                index112_29 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_29)
                if s >= 0:
                    return s
            elif s == 29: 
                LA112_30 = input.LA(1)

                 
                index112_30 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_30)
                if s >= 0:
                    return s
            elif s == 30: 
                LA112_31 = input.LA(1)

                 
                index112_31 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_31)
                if s >= 0:
                    return s
            elif s == 31: 
                LA112_32 = input.LA(1)

                 
                index112_32 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_32)
                if s >= 0:
                    return s
            elif s == 32: 
                LA112_33 = input.LA(1)

                 
                index112_33 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_33)
                if s >= 0:
                    return s
            elif s == 33: 
                LA112_34 = input.LA(1)

                 
                index112_34 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_34)
                if s >= 0:
                    return s
            elif s == 34: 
                LA112_35 = input.LA(1)

                 
                index112_35 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_35)
                if s >= 0:
                    return s
            elif s == 35: 
                LA112_36 = input.LA(1)

                 
                index112_36 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_36)
                if s >= 0:
                    return s
            elif s == 36: 
                LA112_37 = input.LA(1)

                 
                index112_37 = input.index()
                input.rewind()
                s = -1
                if (self.synpred209_YSmart()):
                    s = 38

                elif (True):
                    s = 39

                 
                input.seek(index112_37)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 112, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #114

    DFA114_eot = DFA.unpack(
        u"\65\uffff"
        )

    DFA114_eof = DFA.unpack(
        u"\65\uffff"
        )

    DFA114_min = DFA.unpack(
        u"\1\57\1\uffff\37\0\1\uffff\3\0\20\uffff"
        )

    DFA114_max = DFA.unpack(
        u"\1\u0222\1\uffff\37\0\1\uffff\3\0\20\uffff"
        )

    DFA114_accept = DFA.unpack(
        u"\1\uffff\1\1\37\uffff\1\7\3\uffff\1\2\1\3\1\4\1\5\1\11\1\13\1\14"
        u"\1\15\1\6\1\10\1\12\1\17\1\16\1\22\1\20\1\21"
        )

    DFA114_special = DFA.unpack(
        u"\2\uffff\1\0\1\1\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11\1\12\1\13\1"
        u"\14\1\15\1\16\1\17\1\20\1\21\1\22\1\23\1\24\1\25\1\26\1\27\1\30"
        u"\1\31\1\32\1\33\1\34\1\35\1\36\1\uffff\1\37\1\40\1\41\20\uffff"
        )

            
    DFA114_transition = [
        DFA.unpack(u"\1\2\1\3\3\uffff\1\37\7\uffff\1\36\1\uffff\4\6\6\uffff"
        u"\1\35\22\uffff\1\44\6\uffff\1\41\6\uffff\1\40\22\uffff\1\1\1\14"
        u"\22\uffff\1\20\17\uffff\1\16\11\uffff\1\4\7\uffff\1\10\1\uffff"
        u"\1\11\13\uffff\1\17\4\uffff\1\13\15\uffff\u0099\44\1\12\3\44\1"
        u"\uffff\23\44\2\uffff\15\44\1\7\2\44\1\27\1\21\1\15\1\5\12\44\1"
        u"\42\10\44\1\uffff\12\44\2\uffff\12\44\1\31\1\32\1\uffff\1\44\4"
        u"\uffff\7\44\1\34\33\44\1\43\7\44\1\26\1\25\1\30\1\24\1\23\1\22"
        u"\1\44\1\33\22\44\1\uffff\10\44\1\uffff\10\44"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #114

    class DFA114(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA114_2 = input.LA(1)

                 
                index114_2 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_2)
                if s >= 0:
                    return s
            elif s == 1: 
                LA114_3 = input.LA(1)

                 
                index114_3 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_3)
                if s >= 0:
                    return s
            elif s == 2: 
                LA114_4 = input.LA(1)

                 
                index114_4 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_4)
                if s >= 0:
                    return s
            elif s == 3: 
                LA114_5 = input.LA(1)

                 
                index114_5 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_5)
                if s >= 0:
                    return s
            elif s == 4: 
                LA114_6 = input.LA(1)

                 
                index114_6 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_6)
                if s >= 0:
                    return s
            elif s == 5: 
                LA114_7 = input.LA(1)

                 
                index114_7 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_7)
                if s >= 0:
                    return s
            elif s == 6: 
                LA114_8 = input.LA(1)

                 
                index114_8 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_8)
                if s >= 0:
                    return s
            elif s == 7: 
                LA114_9 = input.LA(1)

                 
                index114_9 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_9)
                if s >= 0:
                    return s
            elif s == 8: 
                LA114_10 = input.LA(1)

                 
                index114_10 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_10)
                if s >= 0:
                    return s
            elif s == 9: 
                LA114_11 = input.LA(1)

                 
                index114_11 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_11)
                if s >= 0:
                    return s
            elif s == 10: 
                LA114_12 = input.LA(1)

                 
                index114_12 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_12)
                if s >= 0:
                    return s
            elif s == 11: 
                LA114_13 = input.LA(1)

                 
                index114_13 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_13)
                if s >= 0:
                    return s
            elif s == 12: 
                LA114_14 = input.LA(1)

                 
                index114_14 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_14)
                if s >= 0:
                    return s
            elif s == 13: 
                LA114_15 = input.LA(1)

                 
                index114_15 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_15)
                if s >= 0:
                    return s
            elif s == 14: 
                LA114_16 = input.LA(1)

                 
                index114_16 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_16)
                if s >= 0:
                    return s
            elif s == 15: 
                LA114_17 = input.LA(1)

                 
                index114_17 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_17)
                if s >= 0:
                    return s
            elif s == 16: 
                LA114_18 = input.LA(1)

                 
                index114_18 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_18)
                if s >= 0:
                    return s
            elif s == 17: 
                LA114_19 = input.LA(1)

                 
                index114_19 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_19)
                if s >= 0:
                    return s
            elif s == 18: 
                LA114_20 = input.LA(1)

                 
                index114_20 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_20)
                if s >= 0:
                    return s
            elif s == 19: 
                LA114_21 = input.LA(1)

                 
                index114_21 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_21)
                if s >= 0:
                    return s
            elif s == 20: 
                LA114_22 = input.LA(1)

                 
                index114_22 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_22)
                if s >= 0:
                    return s
            elif s == 21: 
                LA114_23 = input.LA(1)

                 
                index114_23 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_23)
                if s >= 0:
                    return s
            elif s == 22: 
                LA114_24 = input.LA(1)

                 
                index114_24 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_24)
                if s >= 0:
                    return s
            elif s == 23: 
                LA114_25 = input.LA(1)

                 
                index114_25 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_25)
                if s >= 0:
                    return s
            elif s == 24: 
                LA114_26 = input.LA(1)

                 
                index114_26 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_26)
                if s >= 0:
                    return s
            elif s == 25: 
                LA114_27 = input.LA(1)

                 
                index114_27 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_27)
                if s >= 0:
                    return s
            elif s == 26: 
                LA114_28 = input.LA(1)

                 
                index114_28 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred224_YSmart()):
                    s = 49

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_28)
                if s >= 0:
                    return s
            elif s == 27: 
                LA114_29 = input.LA(1)

                 
                index114_29 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_29)
                if s >= 0:
                    return s
            elif s == 28: 
                LA114_30 = input.LA(1)

                 
                index114_30 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_30)
                if s >= 0:
                    return s
            elif s == 29: 
                LA114_31 = input.LA(1)

                 
                index114_31 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (True):
                    s = 50

                 
                input.seek(index114_31)
                if s >= 0:
                    return s
            elif s == 30: 
                LA114_32 = input.LA(1)

                 
                index114_32 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                 
                input.seek(index114_32)
                if s >= 0:
                    return s
            elif s == 31: 
                LA114_34 = input.LA(1)

                 
                index114_34 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                elif (self.synpred226_YSmart()):
                    s = 51

                 
                input.seek(index114_34)
                if s >= 0:
                    return s
            elif s == 32: 
                LA114_35 = input.LA(1)

                 
                index114_35 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                elif (self.synpred227_YSmart()):
                    s = 52

                 
                input.seek(index114_35)
                if s >= 0:
                    return s
            elif s == 33: 
                LA114_36 = input.LA(1)

                 
                index114_36 = input.index()
                input.rewind()
                s = -1
                if (self.synpred212_YSmart()):
                    s = 37

                elif (self.synpred213_YSmart()):
                    s = 38

                elif (self.synpred214_YSmart()):
                    s = 39

                elif (self.synpred215_YSmart()):
                    s = 40

                elif (self.synpred216_YSmart()):
                    s = 45

                elif (self.synpred217_YSmart()):
                    s = 33

                elif (self.synpred218_YSmart()):
                    s = 46

                elif (self.synpred219_YSmart()):
                    s = 41

                elif (self.synpred220_YSmart()):
                    s = 47

                elif (self.synpred221_YSmart()):
                    s = 42

                elif (self.synpred222_YSmart()):
                    s = 43

                elif (self.synpred223_YSmart()):
                    s = 44

                elif (self.synpred225_YSmart()):
                    s = 48

                 
                input.seek(index114_36)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 114, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #124

    DFA124_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA124_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA124_min = DFA.unpack(
        u"\1\57\1\0\37\uffff"
        )

    DFA124_max = DFA.unpack(
        u"\1\u0222\1\0\37\uffff"
        )

    DFA124_accept = DFA.unpack(
        u"\2\uffff\1\2\35\uffff\1\1"
        )

    DFA124_special = DFA.unpack(
        u"\1\uffff\1\0\37\uffff"
        )

            
    DFA124_transition = [
        DFA.unpack(u"\2\2\3\uffff\1\1\7\uffff\1\2\1\uffff\4\2\6\uffff\1\2"
        u"\22\uffff\1\2\15\uffff\1\2\23\uffff\1\2\22\uffff\1\2\17\uffff\1"
        u"\2\11\uffff\1\2\7\uffff\1\2\1\uffff\1\2\13\uffff\1\2\4\uffff\1"
        u"\2\15\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2\uffff"
        u"\14\2\1\uffff\1\2\4\uffff\105\2\1\uffff\10\2\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #124

    class DFA124(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA124_1 = input.LA(1)

                 
                index124_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred234_YSmart()):
                    s = 32

                elif (True):
                    s = 2

                 
                input.seek(index124_1)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 124, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #122

    DFA122_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA122_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA122_min = DFA.unpack(
        u"\1\57\35\uffff\1\0\2\uffff"
        )

    DFA122_max = DFA.unpack(
        u"\1\u0222\35\uffff\1\0\2\uffff"
        )

    DFA122_accept = DFA.unpack(
        u"\1\uffff\1\1\36\uffff\1\2"
        )

    DFA122_special = DFA.unpack(
        u"\36\uffff\1\0\2\uffff"
        )

            
    DFA122_transition = [
        DFA.unpack(u"\2\1\3\uffff\1\36\7\uffff\1\1\1\uffff\4\1\6\uffff\1"
        u"\1\22\uffff\1\1\15\uffff\1\1\23\uffff\1\1\22\uffff\1\1\17\uffff"
        u"\1\1\11\uffff\1\1\7\uffff\1\1\1\uffff\1\1\13\uffff\1\1\4\uffff"
        u"\1\1\15\uffff\u009d\1\1\uffff\23\1\2\uffff\47\1\1\uffff\12\1\2"
        u"\uffff\14\1\1\uffff\1\1\4\uffff\105\1\1\uffff\10\1\1\uffff\10\1"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #122

    class DFA122(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA122_30 = input.LA(1)

                 
                index122_30 = input.index()
                input.rewind()
                s = -1
                if (self.synpred243_YSmart()):
                    s = 1

                elif (True):
                    s = 32

                 
                input.seek(index122_30)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 122, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #129

    DFA129_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA129_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA129_min = DFA.unpack(
        u"\1\57\1\0\37\uffff"
        )

    DFA129_max = DFA.unpack(
        u"\1\u0222\1\0\37\uffff"
        )

    DFA129_accept = DFA.unpack(
        u"\2\uffff\1\2\35\uffff\1\1"
        )

    DFA129_special = DFA.unpack(
        u"\1\uffff\1\0\37\uffff"
        )

            
    DFA129_transition = [
        DFA.unpack(u"\2\2\3\uffff\1\1\7\uffff\1\2\1\uffff\4\2\6\uffff\1\2"
        u"\22\uffff\1\2\15\uffff\1\2\23\uffff\1\2\22\uffff\1\2\17\uffff\1"
        u"\2\11\uffff\1\2\7\uffff\1\2\1\uffff\1\2\13\uffff\1\2\4\uffff\1"
        u"\2\15\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2\uffff"
        u"\14\2\1\uffff\1\2\4\uffff\105\2\1\uffff\10\2\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #129

    class DFA129(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA129_1 = input.LA(1)

                 
                index129_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred249_YSmart()):
                    s = 32

                elif (True):
                    s = 2

                 
                input.seek(index129_1)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 129, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #134

    DFA134_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA134_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA134_min = DFA.unpack(
        u"\1\57\1\0\37\uffff"
        )

    DFA134_max = DFA.unpack(
        u"\1\u0222\1\0\37\uffff"
        )

    DFA134_accept = DFA.unpack(
        u"\2\uffff\1\2\35\uffff\1\1"
        )

    DFA134_special = DFA.unpack(
        u"\1\uffff\1\0\37\uffff"
        )

            
    DFA134_transition = [
        DFA.unpack(u"\2\2\3\uffff\1\1\7\uffff\1\2\1\uffff\4\2\6\uffff\1\2"
        u"\22\uffff\1\2\15\uffff\1\2\23\uffff\1\2\22\uffff\1\2\17\uffff\1"
        u"\2\11\uffff\1\2\7\uffff\1\2\1\uffff\1\2\13\uffff\1\2\4\uffff\1"
        u"\2\15\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2\uffff"
        u"\14\2\1\uffff\1\2\4\uffff\105\2\1\uffff\10\2\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #134

    class DFA134(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA134_1 = input.LA(1)

                 
                index134_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred260_YSmart()):
                    s = 32

                elif (True):
                    s = 2

                 
                input.seek(index134_1)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 134, _s, input)
            self_.error(nvae)
            raise nvae
    # lookup tables for DFA #159

    DFA159_eot = DFA.unpack(
        u"\41\uffff"
        )

    DFA159_eof = DFA.unpack(
        u"\41\uffff"
        )

    DFA159_min = DFA.unpack(
        u"\1\57\1\0\37\uffff"
        )

    DFA159_max = DFA.unpack(
        u"\1\u0222\1\0\37\uffff"
        )

    DFA159_accept = DFA.unpack(
        u"\2\uffff\1\2\35\uffff\1\1"
        )

    DFA159_special = DFA.unpack(
        u"\1\uffff\1\0\37\uffff"
        )

            
    DFA159_transition = [
        DFA.unpack(u"\2\2\3\uffff\1\1\7\uffff\1\2\1\uffff\4\2\6\uffff\1\2"
        u"\22\uffff\1\2\15\uffff\1\2\23\uffff\1\2\22\uffff\1\2\17\uffff\1"
        u"\2\11\uffff\1\2\7\uffff\1\2\1\uffff\1\2\13\uffff\1\2\4\uffff\1"
        u"\2\15\uffff\u009d\2\1\uffff\23\2\2\uffff\47\2\1\uffff\12\2\2\uffff"
        u"\14\2\1\uffff\1\2\4\uffff\105\2\1\uffff\10\2\1\uffff\10\2"),
        DFA.unpack(u"\1\uffff"),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u""),
        DFA.unpack(u"")
    ]

    # class definition for DFA #159

    class DFA159(DFA):
        pass


        def specialStateTransition(self_, s, input):
            # convince pylint that my self_ magic is ok ;)
            # pylint: disable-msg=E0213

            # pretend we are a member of the recognizer
            # thus semantic predicates can be evaluated
            self = self_.recognizer

            _s = s

            if s == 0: 
                LA159_1 = input.LA(1)

                 
                index159_1 = input.index()
                input.rewind()
                s = -1
                if (self.synpred289_YSmart()):
                    s = 32

                elif (True):
                    s = 2

                 
                input.seek(index159_1)
                if s >= 0:
                    return s

            if self._state.backtracking >0:
                raise BacktrackingFailed
            nvae = NoViableAltException(self_.getDescription(), 159, _s, input)
            self_.error(nvae)
            raise nvae
 

    FOLLOW_select_statement_in_start_rule473 = frozenset([43])
    FOLLOW_SEMI_in_start_rule501 = frozenset([1])
    FOLLOW_k_select_in_select_statement528 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_select_list_in_select_statement530 = frozenset([129])
    FOLLOW_k_from_in_select_statement533 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_reference_list_in_select_statement535 = frozenset([1, 131, 132, 168, 209, 513])
    FOLLOW_where_clause_in_select_statement548 = frozenset([1, 131, 132, 168, 513])
    FOLLOW_group_by_clause_in_select_statement556 = frozenset([1, 132, 168, 513])
    FOLLOW_having_clause_in_select_statement564 = frozenset([1, 168, 513])
    FOLLOW_order_by_clause_in_select_statement572 = frozenset([1, 513])
    FOLLOW_limit_clause_in_select_statement580 = frozenset([1])
    FOLLOW_displayed_column_part_first_in_select_list661 = frozenset([1, 44])
    FOLLOW_displayed_column_part_next_in_select_list663 = frozenset([1, 44])
    FOLLOW_displayed_column_in_displayed_column_part_first687 = frozenset([1])
    FOLLOW_COMMA_in_displayed_column_part_next711 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_displayed_column_in_displayed_column_part_next713 = frozenset([1])
    FOLLOW_ASTERISK_in_displayed_column748 = frozenset([1, 62, 63, 64, 65, 91, 100, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_displayed_column756 = frozenset([46])
    FOLLOW_DOT_in_displayed_column758 = frozenset([45])
    FOLLOW_ASTERISK_in_displayed_column762 = frozenset([1, 62, 63, 64, 65, 91, 100, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_displayed_column768 = frozenset([1, 62, 63, 64, 65, 91, 100, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_alias_in_displayed_column780 = frozenset([1])
    FOLLOW_sql_identifier_in_displayed_column784 = frozenset([1])
    FOLLOW_expr_add_in_sql_expression839 = frozenset([1])
    FOLLOW_expr_mul_in_expr_add849 = frozenset([1, 47, 48, 49])
    FOLLOW_set_in_expr_add853 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_mul_in_expr_add867 = frozenset([1, 47, 48, 49])
    FOLLOW_expr_sign_in_expr_mul880 = frozenset([1, 45, 50])
    FOLLOW_set_in_expr_mul884 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_sign_in_expr_mul894 = frozenset([1, 45, 50])
    FOLLOW_PLUS_in_expr_sign910 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_MINUS_in_expr_sign914 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_prior_in_expr_sign918 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_connect_by_root_in_expr_sign922 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_pow_in_expr_sign927 = frozenset([1])
    FOLLOW_expr_expr_in_expr_pow937 = frozenset([1, 51])
    FOLLOW_EXPONENT_in_expr_pow941 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_expr_in_expr_pow943 = frozenset([1, 51])
    FOLLOW_datetime_expression_in_expr_expr956 = frozenset([1])
    FOLLOW_interval_expression_in_expr_expr961 = frozenset([1])
    FOLLOW_expr_paren_in_expr_expr982 = frozenset([1])
    FOLLOW_cast_expression_in_expr_expr994 = frozenset([1])
    FOLLOW_function_expression_in_expr_expr1007 = frozenset([1])
    FOLLOW_case_expression_in_expr_expr1020 = frozenset([1])
    FOLLOW_simple_expression_in_expr_expr1033 = frozenset([1])
    FOLLOW_subquery_in_expr_expr1046 = frozenset([1])
    FOLLOW_LPAREN_in_expr_paren1056 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_expr_paren1058 = frozenset([53])
    FOLLOW_RPAREN_in_expr_paren1060 = frozenset([1])
    FOLLOW_sql_expression_in_nested_expression1070 = frozenset([1])
    FOLLOW_function_name_in_function_expression1082 = frozenset([52])
    FOLLOW_LPAREN_in_function_expression1085 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_call_parameters_in_function_expression1087 = frozenset([53])
    FOLLOW_RPAREN_in_function_expression1089 = frozenset([1])
    FOLLOW_ASTERISK_in_call_parameters1100 = frozenset([1])
    FOLLOW_call_parameter_in_call_parameters1105 = frozenset([1, 44])
    FOLLOW_COMMA_in_call_parameters1109 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_call_parameter_in_call_parameters1111 = frozenset([1, 44])
    FOLLOW_parameter_name_in_call_parameter1127 = frozenset([54])
    FOLLOW_ARROW_in_call_parameter1129 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_call_parameter1134 = frozenset([1])
    FOLLOW_identifier_in_parameter_name1144 = frozenset([1])
    FOLLOW_k_case_in_case_expression1154 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_simple_case_expression_in_case_expression1158 = frozenset([122, 258])
    FOLLOW_searched_case_expression_in_case_expression1162 = frozenset([122, 258])
    FOLLOW_else_case_expression_in_case_expression1168 = frozenset([122, 258])
    FOLLOW_k_end_in_case_expression1173 = frozenset([1])
    FOLLOW_nested_expression_in_simple_case_expression1183 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_when_in_simple_case_expression1187 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_simple_case_expression1189 = frozenset([194])
    FOLLOW_k_then_in_simple_case_expression1191 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_simple_case_expression1193 = frozenset([1, 45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_when_in_searched_case_expression1208 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_searched_case_expression1210 = frozenset([194])
    FOLLOW_k_then_in_searched_case_expression1212 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_searched_case_expression1214 = frozenset([1, 45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_else_in_else_case_expression1227 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_expression_in_else_case_expression1229 = frozenset([1])
    FOLLOW_boolean_literal_in_simple_expression1240 = frozenset([1])
    FOLLOW_k_sql_in_simple_expression1245 = frozenset([55, 56, 57, 58, 59])
    FOLLOW_set_in_simple_expression1247 = frozenset([1])
    FOLLOW_column_spec_in_simple_expression1280 = frozenset([1])
    FOLLOW_quoted_string_in_simple_expression1285 = frozenset([1])
    FOLLOW_NUMBER_in_simple_expression1290 = frozenset([1])
    FOLLOW_LPAREN_in_subquery1310 = frozenset([182])
    FOLLOW_select_statement_in_subquery1312 = frozenset([53])
    FOLLOW_RPAREN_in_subquery1314 = frozenset([1])
    FOLLOW_LPAREN_in_subquery1319 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_subquery1321 = frozenset([53])
    FOLLOW_RPAREN_in_subquery1323 = frozenset([1])
    FOLLOW_function_expression_in_datetime_expression1344 = frozenset([212])
    FOLLOW_cast_expression_in_datetime_expression1348 = frozenset([212])
    FOLLOW_simple_expression_in_datetime_expression1352 = frozenset([212])
    FOLLOW_k_at_in_datetime_expression1364 = frozenset([291, 379])
    FOLLOW_k_local_in_datetime_expression1367 = frozenset([1])
    FOLLOW_k_time_in_datetime_expression1371 = frozenset([394])
    FOLLOW_k_zone_in_datetime_expression1373 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_quoted_string_in_datetime_expression1377 = frozenset([1])
    FOLLOW_k_dbtimezone_in_datetime_expression1381 = frozenset([1])
    FOLLOW_k_sessiontimezone_in_datetime_expression1385 = frozenset([1])
    FOLLOW_sql_expression_in_datetime_expression1389 = frozenset([1])
    FOLLOW_LPAREN_in_interval_expression1403 = frozenset([60, 62, 63, 64, 65, 72, 91, 125, 144, 160, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_function_expression_in_interval_expression1407 = frozenset([48])
    FOLLOW_cast_expression_in_interval_expression1411 = frozenset([48])
    FOLLOW_simple_expression_in_interval_expression1415 = frozenset([48])
    FOLLOW_MINUS_in_interval_expression1419 = frozenset([60, 62, 63, 64, 65, 72, 91, 125, 144, 160, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_function_expression_in_interval_expression1423 = frozenset([53])
    FOLLOW_cast_expression_in_interval_expression1427 = frozenset([53])
    FOLLOW_simple_expression_in_interval_expression1431 = frozenset([53])
    FOLLOW_RPAREN_in_interval_expression1435 = frozenset([247, 393])
    FOLLOW_k_day_in_interval_expression1441 = frozenset([52, 195])
    FOLLOW_LPAREN_in_interval_expression1444 = frozenset([60])
    FOLLOW_NUMBER_in_interval_expression1446 = frozenset([53])
    FOLLOW_RPAREN_in_interval_expression1448 = frozenset([52, 195])
    FOLLOW_k_to_in_interval_expression1452 = frozenset([354])
    FOLLOW_k_second_in_interval_expression1454 = frozenset([1, 52])
    FOLLOW_LPAREN_in_interval_expression1457 = frozenset([60])
    FOLLOW_NUMBER_in_interval_expression1459 = frozenset([53])
    FOLLOW_RPAREN_in_interval_expression1461 = frozenset([1])
    FOLLOW_k_year_in_interval_expression1469 = frozenset([52, 195])
    FOLLOW_LPAREN_in_interval_expression1472 = frozenset([60])
    FOLLOW_NUMBER_in_interval_expression1474 = frozenset([53])
    FOLLOW_RPAREN_in_interval_expression1476 = frozenset([52, 195])
    FOLLOW_k_to_in_interval_expression1480 = frozenset([307])
    FOLLOW_k_month_in_interval_expression1482 = frozenset([1, 52])
    FOLLOW_LPAREN_in_interval_expression1485 = frozenset([60])
    FOLLOW_NUMBER_in_interval_expression1487 = frozenset([53])
    FOLLOW_RPAREN_in_interval_expression1489 = frozenset([1])
    FOLLOW_k_cast_in_cast_expression1507 = frozenset([52])
    FOLLOW_LPAREN_in_cast_expression1509 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_cast_expression1512 = frozenset([100])
    FOLLOW_k_multiset_in_cast_expression1516 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_cast_expression1518 = frozenset([100])
    FOLLOW_k_as_in_cast_expression1521 = frozenset([62, 63, 64, 65, 91, 106, 115, 116, 127, 140, 150, 161, 173, 178, 180, 187, 205, 206, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_datatype_in_cast_expression1524 = frozenset([53])
    FOLLOW_sql_identifier_in_cast_expression1526 = frozenset([53])
    FOLLOW_RPAREN_in_cast_expression1529 = frozenset([1])
    FOLLOW_k_binary_integer_in_datatype1540 = frozenset([1])
    FOLLOW_k_binary_float_in_datatype1546 = frozenset([1])
    FOLLOW_k_binary_double_in_datatype1551 = frozenset([1])
    FOLLOW_k_natural_in_datatype1556 = frozenset([1])
    FOLLOW_k_positive_in_datatype1561 = frozenset([1])
    FOLLOW_k_number_in_datatype1568 = frozenset([1, 52])
    FOLLOW_k_numeric_in_datatype1572 = frozenset([1, 52])
    FOLLOW_k_decimal_in_datatype1576 = frozenset([1, 52])
    FOLLOW_k_dec_in_datatype1580 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1586 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1588 = frozenset([44, 53])
    FOLLOW_COMMA_in_datatype1592 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1594 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1599 = frozenset([1])
    FOLLOW_k_long_in_datatype1607 = frozenset([1, 52, 173])
    FOLLOW_k_raw_in_datatype1611 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1617 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1619 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1621 = frozenset([1])
    FOLLOW_k_raw_in_datatype1629 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1633 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1635 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1637 = frozenset([1])
    FOLLOW_k_boolean_in_datatype1645 = frozenset([1])
    FOLLOW_k_date_in_datatype1650 = frozenset([1])
    FOLLOW_k_interval_in_datatype1655 = frozenset([247])
    FOLLOW_k_day_in_datatype1657 = frozenset([52, 195])
    FOLLOW_LPAREN_in_datatype1661 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1663 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1665 = frozenset([52, 195])
    FOLLOW_k_to_in_datatype1670 = frozenset([354])
    FOLLOW_k_second_in_datatype1672 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1676 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1678 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1680 = frozenset([1])
    FOLLOW_k_interval_in_datatype1688 = frozenset([247, 393])
    FOLLOW_k_year_in_datatype1690 = frozenset([52, 195])
    FOLLOW_LPAREN_in_datatype1694 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1696 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1698 = frozenset([52, 195])
    FOLLOW_k_to_in_datatype1703 = frozenset([307])
    FOLLOW_k_month_in_datatype1705 = frozenset([1])
    FOLLOW_k_time_in_datatype1712 = frozenset([1, 52, 210])
    FOLLOW_k_timestamp_in_datatype1716 = frozenset([1, 52, 210])
    FOLLOW_LPAREN_in_datatype1722 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1724 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1726 = frozenset([1, 210])
    FOLLOW_k_with_in_datatype1733 = frozenset([291, 379])
    FOLLOW_k_local_in_datatype1737 = frozenset([291, 379])
    FOLLOW_k_time_in_datatype1742 = frozenset([394])
    FOLLOW_k_zone_in_datatype1744 = frozenset([1])
    FOLLOW_k_integer_in_datatype1752 = frozenset([1])
    FOLLOW_k_int_in_datatype1757 = frozenset([1])
    FOLLOW_k_smallint_in_datatype1762 = frozenset([1])
    FOLLOW_k_float_in_datatype1767 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1771 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1773 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1775 = frozenset([1])
    FOLLOW_k_real_in_datatype1783 = frozenset([1])
    FOLLOW_k_double_in_datatype1788 = frozenset([334])
    FOLLOW_k_precision_in_datatype1790 = frozenset([1])
    FOLLOW_k_char_in_datatype1795 = frozenset([1, 52, 231, 500])
    FOLLOW_k_varying_in_datatype1804 = frozenset([1, 52, 231])
    FOLLOW_LPAREN_in_datatype1811 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1813 = frozenset([53, 106, 402])
    FOLLOW_k_byte_in_datatype1817 = frozenset([53])
    FOLLOW_k_char_in_datatype1821 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1826 = frozenset([1, 231])
    FOLLOW_k_character_in_datatype1833 = frozenset([184])
    FOLLOW_k_set_in_datatype1835 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_identifier_in_datatype1839 = frozenset([1])
    FOLLOW_column_spec_in_datatype1843 = frozenset([61])
    FOLLOW_CHARSET_ATTR_in_datatype1845 = frozenset([1])
    FOLLOW_k_varchar_in_datatype1855 = frozenset([1, 52, 231])
    FOLLOW_LPAREN_in_datatype1876 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1878 = frozenset([53, 106, 402])
    FOLLOW_k_byte_in_datatype1882 = frozenset([53])
    FOLLOW_k_char_in_datatype1886 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1891 = frozenset([1, 231])
    FOLLOW_k_character_in_datatype1898 = frozenset([184])
    FOLLOW_k_set_in_datatype1900 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_identifier_in_datatype1904 = frozenset([1])
    FOLLOW_column_spec_in_datatype1908 = frozenset([61])
    FOLLOW_CHARSET_ATTR_in_datatype1910 = frozenset([1])
    FOLLOW_k_varchar2_in_datatype1920 = frozenset([1, 52, 231])
    FOLLOW_LPAREN_in_datatype1940 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1942 = frozenset([53, 106, 402])
    FOLLOW_k_byte_in_datatype1946 = frozenset([53])
    FOLLOW_k_char_in_datatype1950 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1955 = frozenset([1, 231])
    FOLLOW_k_character_in_datatype1962 = frozenset([184])
    FOLLOW_k_set_in_datatype1964 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_identifier_in_datatype1968 = frozenset([1])
    FOLLOW_column_spec_in_datatype1972 = frozenset([61])
    FOLLOW_CHARSET_ATTR_in_datatype1974 = frozenset([1])
    FOLLOW_k_character_in_datatype1984 = frozenset([1, 52, 500])
    FOLLOW_k_varying_in_datatype1988 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype1995 = frozenset([60])
    FOLLOW_NUMBER_in_datatype1997 = frozenset([53])
    FOLLOW_RPAREN_in_datatype1999 = frozenset([1])
    FOLLOW_k_nchar_in_datatype2007 = frozenset([1, 52, 500])
    FOLLOW_k_varying_in_datatype2015 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype2022 = frozenset([60])
    FOLLOW_NUMBER_in_datatype2024 = frozenset([53])
    FOLLOW_RPAREN_in_datatype2026 = frozenset([1])
    FOLLOW_k_nvarchar_in_datatype2034 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype2039 = frozenset([60])
    FOLLOW_NUMBER_in_datatype2041 = frozenset([53])
    FOLLOW_RPAREN_in_datatype2043 = frozenset([1])
    FOLLOW_k_nvarchar2_in_datatype2051 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype2055 = frozenset([60])
    FOLLOW_NUMBER_in_datatype2057 = frozenset([53])
    FOLLOW_RPAREN_in_datatype2059 = frozenset([1])
    FOLLOW_k_national_in_datatype2067 = frozenset([106, 231])
    FOLLOW_k_character_in_datatype2072 = frozenset([1, 52, 500])
    FOLLOW_k_char_in_datatype2076 = frozenset([1, 52, 500])
    FOLLOW_k_varying_in_datatype2082 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype2089 = frozenset([60])
    FOLLOW_NUMBER_in_datatype2091 = frozenset([53])
    FOLLOW_RPAREN_in_datatype2093 = frozenset([1])
    FOLLOW_k_mlslabel_in_datatype2101 = frozenset([1])
    FOLLOW_k_pls_integer_in_datatype2106 = frozenset([1])
    FOLLOW_k_blob_in_datatype2111 = frozenset([1])
    FOLLOW_k_clob_in_datatype2116 = frozenset([1, 231])
    FOLLOW_k_character_in_datatype2120 = frozenset([184])
    FOLLOW_k_set_in_datatype2122 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_identifier_in_datatype2126 = frozenset([1])
    FOLLOW_column_spec_in_datatype2130 = frozenset([61])
    FOLLOW_CHARSET_ATTR_in_datatype2132 = frozenset([1])
    FOLLOW_k_nclob_in_datatype2142 = frozenset([1])
    FOLLOW_k_bfile_in_datatype2147 = frozenset([1])
    FOLLOW_k_rowid_in_datatype2152 = frozenset([1])
    FOLLOW_k_urowid_in_datatype2158 = frozenset([1, 52])
    FOLLOW_LPAREN_in_datatype2162 = frozenset([60])
    FOLLOW_NUMBER_in_datatype2164 = frozenset([53])
    FOLLOW_RPAREN_in_datatype2166 = frozenset([1])
    FOLLOW_k_true_in_boolean_literal2180 = frozenset([1])
    FOLLOW_k_false_in_boolean_literal2184 = frozenset([1])
    FOLLOW_sql_identifier_in_t_alias2197 = frozenset([1])
    FOLLOW_k_as_in_c_alias2210 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_c_alias2213 = frozenset([1])
    FOLLOW_k_as_in_c_alias2220 = frozenset([1])
    FOLLOW_k_as_in_alias2231 = frozenset([1, 62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_alias2233 = frozenset([1])
    FOLLOW_sql_identifier_in_column_spec2245 = frozenset([46])
    FOLLOW_DOT_in_column_spec2247 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_column_spec2249 = frozenset([46])
    FOLLOW_DOT_in_column_spec2251 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_column_spec2253 = frozenset([1])
    FOLLOW_sql_identifier_in_column_spec2258 = frozenset([46])
    FOLLOW_DOT_in_column_spec2260 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_column_spec2262 = frozenset([1])
    FOLLOW_sql_identifier_in_column_spec2267 = frozenset([1])
    FOLLOW_pseudo_column_in_column_spec2272 = frozenset([1])
    FOLLOW_k_null_in_pseudo_column2283 = frozenset([1])
    FOLLOW_k_sysdate_in_pseudo_column2291 = frozenset([1])
    FOLLOW_k_rowid_in_pseudo_column2296 = frozenset([1])
    FOLLOW_k_rownum_in_pseudo_column2301 = frozenset([1])
    FOLLOW_k_level_in_pseudo_column2306 = frozenset([1])
    FOLLOW_k_connect_by_isleaf_in_pseudo_column2315 = frozenset([1])
    FOLLOW_k_connect_by_iscycle_in_pseudo_column2320 = frozenset([1])
    FOLLOW_k_versions_starttime_in_pseudo_column2325 = frozenset([1])
    FOLLOW_k_versions_starscn_in_pseudo_column2331 = frozenset([1])
    FOLLOW_k_versions_endtime_in_pseudo_column2336 = frozenset([1])
    FOLLOW_k_versions_endscn_in_pseudo_column2341 = frozenset([1])
    FOLLOW_k_versions_xid_in_pseudo_column2347 = frozenset([1])
    FOLLOW_k_versions_operation_in_pseudo_column2353 = frozenset([1])
    FOLLOW_k_column_value_in_pseudo_column2358 = frozenset([1])
    FOLLOW_k_object_value_in_pseudo_column2364 = frozenset([1])
    FOLLOW_k_ora_rowscn_in_pseudo_column2370 = frozenset([1])
    FOLLOW_k_xmldata_in_pseudo_column2377 = frozenset([1])
    FOLLOW_sql_identifier_in_function_name2388 = frozenset([46])
    FOLLOW_DOT_in_function_name2390 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_function_name2392 = frozenset([46])
    FOLLOW_DOT_in_function_name2394 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_function_name2396 = frozenset([1])
    FOLLOW_sql_identifier_in_function_name2401 = frozenset([46])
    FOLLOW_DOT_in_function_name2403 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_identifier_in_function_name2405 = frozenset([1])
    FOLLOW_sql_identifier_in_function_name2410 = frozenset([1])
    FOLLOW_set_in_identifier0 = frozenset([1])
    FOLLOW_identifier_in_sql_identifier2459 = frozenset([1])
    FOLLOW_keyword_in_sql_identifier2467 = frozenset([1])
    FOLLOW_k_rowid_in_sql_identifier2472 = frozenset([1])
    FOLLOW_k_rownum_in_sql_identifier2477 = frozenset([1])
    FOLLOW_table_name_in_table_reference_list2497 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_table_reference_list2499 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_kNN_join_clause_in_table_reference_list2502 = frozenset([1, 44])
    FOLLOW_join_clause_in_table_reference_list2505 = frozenset([1, 44])
    FOLLOW_LPAREN_in_table_reference_list2508 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_join_clause_in_table_reference_list2510 = frozenset([53])
    FOLLOW_RPAREN_in_table_reference_list2512 = frozenset([1, 44])
    FOLLOW_table_reference_in_table_reference_list2515 = frozenset([1, 44])
    FOLLOW_COMMA_in_table_reference_list2522 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_name_in_table_reference_list2526 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_table_reference_list2528 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_kNN_join_clause_in_table_reference_list2531 = frozenset([1, 44])
    FOLLOW_join_clause_in_table_reference_list2534 = frozenset([1, 44])
    FOLLOW_LPAREN_in_table_reference_list2537 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_join_clause_in_table_reference_list2539 = frozenset([53])
    FOLLOW_RPAREN_in_table_reference_list2541 = frozenset([1, 44])
    FOLLOW_table_reference_in_table_reference_list2544 = frozenset([1, 44])
    FOLLOW_query_table_expression_in_table_reference2573 = frozenset([1])
    FOLLOW_schema_name_in_query_table_expression2589 = frozenset([46])
    FOLLOW_DOT_in_query_table_expression2591 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_name_in_query_table_expression2595 = frozenset([1, 62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_query_table_expression2597 = frozenset([1])
    FOLLOW_subquery_in_query_table_expression2603 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_query_table_expression2605 = frozenset([1])
    FOLLOW_LPAREN_in_query_table_expression2616 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_query_table_expression2618 = frozenset([53])
    FOLLOW_RPAREN_in_query_table_expression2620 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_query_table_expression2622 = frozenset([1])
    FOLLOW_table_reference_in_join_clause2632 = frozenset([413, 422, 426, 429, 435, 444, 477])
    FOLLOW_inner_cross_join_clause_in_join_clause2635 = frozenset([1, 413, 422, 426, 429, 435, 444, 477])
    FOLLOW_outer_join_clause_in_join_clause2637 = frozenset([1, 413, 422, 426, 429, 435, 444, 477])
    FOLLOW_k_inner_in_inner_cross_join_clause2649 = frozenset([426, 429])
    FOLLOW_k_join_in_inner_cross_join_clause2652 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_reference_in_inner_cross_join_clause2654 = frozenset([164, 388])
    FOLLOW_k_on_in_inner_cross_join_clause2658 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_inner_cross_join_clause2660 = frozenset([1])
    FOLLOW_k_using_in_inner_cross_join_clause2664 = frozenset([52])
    FOLLOW_LPAREN_in_inner_cross_join_clause2666 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_specs_in_inner_cross_join_clause2668 = frozenset([53])
    FOLLOW_RPAREN_in_inner_cross_join_clause2670 = frozenset([1])
    FOLLOW_k_cross_in_inner_cross_join_clause2681 = frozenset([426, 429])
    FOLLOW_k_natural_in_inner_cross_join_clause2685 = frozenset([426, 429])
    FOLLOW_k_inner_in_inner_cross_join_clause2687 = frozenset([426, 429])
    FOLLOW_k_join_in_inner_cross_join_clause2692 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_reference_in_inner_cross_join_clause2694 = frozenset([1])
    FOLLOW_outer_join_type_in_outer_join_clause2715 = frozenset([426, 429])
    FOLLOW_k_join_in_outer_join_clause2717 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_natural_in_outer_join_clause2723 = frozenset([422, 426, 429, 435, 477])
    FOLLOW_outer_join_type_in_outer_join_clause2727 = frozenset([426, 429])
    FOLLOW_k_join_in_outer_join_clause2732 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_reference_in_outer_join_clause2740 = frozenset([1, 164, 388])
    FOLLOW_k_on_in_outer_join_clause2744 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_outer_join_clause2746 = frozenset([1])
    FOLLOW_k_using_in_outer_join_clause2750 = frozenset([52])
    FOLLOW_LPAREN_in_outer_join_clause2752 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_specs_in_outer_join_clause2754 = frozenset([53])
    FOLLOW_RPAREN_in_outer_join_clause2756 = frozenset([1])
    FOLLOW_k_full_in_outer_join_type2772 = frozenset([1, 454])
    FOLLOW_k_left_in_outer_join_type2776 = frozenset([1, 454])
    FOLLOW_k_right_in_outer_join_type2780 = frozenset([1, 454])
    FOLLOW_k_outer_in_outer_join_type2786 = frozenset([1])
    FOLLOW_LPAREN_in_outer_join_sign2808 = frozenset([47])
    FOLLOW_PLUS_in_outer_join_sign2810 = frozenset([53])
    FOLLOW_RPAREN_in_outer_join_sign2812 = frozenset([1])
    FOLLOW_kNN_join_type_in_kNN_join_clause2822 = frozenset([426, 429])
    FOLLOW_k_join_in_kNN_join_clause2824 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_reference_in_kNN_join_clause2826 = frozenset([1, 164])
    FOLLOW_k_on_in_kNN_join_clause2830 = frozenset([64])
    FOLLOW_ID_in_kNN_join_clause2832 = frozenset([66])
    FOLLOW_EQ_in_kNN_join_clause2834 = frozenset([64])
    FOLLOW_ID_in_kNN_join_clause2836 = frozenset([1])
    FOLLOW_91_in_kNN_join_type2849 = frozenset([52])
    FOLLOW_LPAREN_in_kNN_join_type2851 = frozenset([92])
    FOLLOW_92_in_kNN_join_type2853 = frozenset([60])
    FOLLOW_NUMBER_in_kNN_join_type2855 = frozenset([53])
    FOLLOW_RPAREN_in_kNN_join_type2857 = frozenset([1])
    FOLLOW_sql_identifier_in_table_name2867 = frozenset([1])
    FOLLOW_sql_identifier_in_schema_name2877 = frozenset([1])
    FOLLOW_column_spec_in_column_specs2887 = frozenset([1, 44])
    FOLLOW_COMMA_in_column_specs2891 = frozenset([62, 63, 64, 65, 91, 144, 160, 178, 180, 192, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_spec_in_column_specs2893 = frozenset([1, 44])
    FOLLOW_k_where_in_where_clause2909 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_where_clause2911 = frozenset([1])
    FOLLOW_k_having_in_having_clause2943 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_having_clause2945 = frozenset([1])
    FOLLOW_k_group_in_group_by_clause2977 = frozenset([104])
    FOLLOW_k_by_in_group_by_clause2979 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_group_by_exprs_in_group_by_clause2981 = frozenset([1])
    FOLLOW_group_by_expr_in_group_by_exprs3004 = frozenset([1, 44])
    FOLLOW_COMMA_in_group_by_exprs3008 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_group_by_expr_in_group_by_exprs3010 = frozenset([1, 44])
    FOLLOW_rollup_cube_clause_in_group_by_expr3023 = frozenset([1])
    FOLLOW_grouping_sets_clause_in_group_by_expr3028 = frozenset([1])
    FOLLOW_grouping_expression_list_in_group_by_expr3033 = frozenset([1])
    FOLLOW_k_rollup_in_rollup_cube_clause3045 = frozenset([52])
    FOLLOW_k_cube_in_rollup_cube_clause3049 = frozenset([52])
    FOLLOW_LPAREN_in_rollup_cube_clause3053 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_rollup_cube_clause3055 = frozenset([53])
    FOLLOW_RPAREN_in_rollup_cube_clause3057 = frozenset([1])
    FOLLOW_k_grouping_in_grouping_sets_clause3067 = frozenset([484])
    FOLLOW_k_sets_in_grouping_sets_clause3069 = frozenset([52])
    FOLLOW_LPAREN_in_grouping_sets_clause3071 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_grouping_sets_clause3073 = frozenset([53])
    FOLLOW_RPAREN_in_grouping_sets_clause3075 = frozenset([1])
    FOLLOW_grouping_sets_expr_in_grouping_sets_exprs3085 = frozenset([1, 44])
    FOLLOW_COMMA_in_grouping_sets_exprs3089 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_sets_expr_in_grouping_sets_exprs3091 = frozenset([1, 44])
    FOLLOW_rollup_cube_clause_in_grouping_sets_expr3104 = frozenset([1])
    FOLLOW_grouping_expression_list_in_grouping_sets_expr3108 = frozenset([1])
    FOLLOW_condition_or_in_sql_condition3118 = frozenset([1])
    FOLLOW_condition_or_part_first_in_condition_or3129 = frozenset([167])
    FOLLOW_condition_or_part_next_in_condition_or3131 = frozenset([1, 167])
    FOLLOW_condition_or_part_first_in_condition_or3153 = frozenset([1])
    FOLLOW_condition_and_in_condition_or_part_first3163 = frozenset([1])
    FOLLOW_k_or_in_condition_or_part_next3176 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_condition_and_in_condition_or_part_next3178 = frozenset([1])
    FOLLOW_condition_and_part_first_in_condition_and3205 = frozenset([97])
    FOLLOW_condition_and_part_next_in_condition_and3207 = frozenset([1, 97])
    FOLLOW_condition_and_part_first_in_condition_and3229 = frozenset([1])
    FOLLOW_condition_not_in_condition_and_part_first3240 = frozenset([1])
    FOLLOW_k_and_in_condition_and_part_next3253 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_condition_not_in_condition_and_part_next3255 = frozenset([1])
    FOLLOW_k_not_in_condition_not3279 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_condition_expr_in_condition_not3281 = frozenset([1])
    FOLLOW_condition_expr_in_condition_not3297 = frozenset([1])
    FOLLOW_condition_exists_in_condition_expr3307 = frozenset([1])
    FOLLOW_condition_is_in_condition_expr3312 = frozenset([1])
    FOLLOW_condition_comparison_in_condition_expr3317 = frozenset([1])
    FOLLOW_condition_group_comparison_in_condition_expr3322 = frozenset([1])
    FOLLOW_condition_in_in_condition_expr3327 = frozenset([1])
    FOLLOW_condition_is_a_set_in_condition_expr3332 = frozenset([1])
    FOLLOW_condition_is_any_in_condition_expr3337 = frozenset([1])
    FOLLOW_condition_is_empty_in_condition_expr3342 = frozenset([1])
    FOLLOW_condition_is_of_type_in_condition_expr3347 = frozenset([1])
    FOLLOW_condition_is_present_in_condition_expr3352 = frozenset([1])
    FOLLOW_condition_like_in_condition_expr3357 = frozenset([1])
    FOLLOW_condition_memeber_in_condition_expr3362 = frozenset([1])
    FOLLOW_condition_between_in_condition_expr3367 = frozenset([1])
    FOLLOW_condition_regexp_like_in_condition_expr3372 = frozenset([1])
    FOLLOW_condition_submultiset_in_condition_expr3377 = frozenset([1])
    FOLLOW_condition_equals_path_in_condition_expr3382 = frozenset([1])
    FOLLOW_condition_under_path_in_condition_expr3387 = frozenset([1])
    FOLLOW_condition_paren_in_condition_expr3392 = frozenset([1])
    FOLLOW_k_exists_in_condition_exists3403 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_condition_exists3405 = frozenset([1])
    FOLLOW_sql_expression_in_condition_is3415 = frozenset([143])
    FOLLOW_k_is_in_condition_is3417 = frozenset([157, 160, 425, 442])
    FOLLOW_k_not_in_condition_is3421 = frozenset([160, 425, 442])
    FOLLOW_k_nan_in_condition_is3428 = frozenset([1])
    FOLLOW_k_infinite_in_condition_is3432 = frozenset([1])
    FOLLOW_k_null_in_condition_is3436 = frozenset([1])
    FOLLOW_LPAREN_in_condition_comparison3448 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_condition_comparison3450 = frozenset([53])
    FOLLOW_RPAREN_in_condition_comparison3452 = frozenset([52, 66, 67])
    FOLLOW_outer_join_sign_in_condition_comparison3456 = frozenset([66, 67])
    FOLLOW_set_in_condition_comparison3461 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_condition_comparison3471 = frozenset([1, 52])
    FOLLOW_outer_join_sign_in_condition_comparison3475 = frozenset([1])
    FOLLOW_k_prior_in_condition_comparison3485 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_comparison3490 = frozenset([52, 66, 67, 68, 69, 70, 71])
    FOLLOW_outer_join_sign_in_condition_comparison3494 = frozenset([66, 67, 68, 69, 70, 71])
    FOLLOW_set_in_condition_comparison3499 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_prior_in_condition_comparison3527 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_comparison3534 = frozenset([1, 52])
    FOLLOW_LPAREN_in_condition_comparison3538 = frozenset([182])
    FOLLOW_select_statement_in_condition_comparison3540 = frozenset([53])
    FOLLOW_RPAREN_in_condition_comparison3542 = frozenset([1, 52])
    FOLLOW_outer_join_sign_in_condition_comparison3548 = frozenset([1])
    FOLLOW_LPAREN_in_condition_group_comparison3561 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_condition_group_comparison3563 = frozenset([53])
    FOLLOW_RPAREN_in_condition_group_comparison3565 = frozenset([66, 67])
    FOLLOW_set_in_condition_group_comparison3567 = frozenset([62, 63, 64, 65, 91, 95, 98, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_any_in_condition_group_comparison3579 = frozenset([52])
    FOLLOW_k_some_in_condition_group_comparison3583 = frozenset([52])
    FOLLOW_k_all_in_condition_group_comparison3587 = frozenset([52])
    FOLLOW_LPAREN_in_condition_group_comparison3591 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_condition_group_comparison3595 = frozenset([53])
    FOLLOW_select_statement_in_condition_group_comparison3599 = frozenset([53])
    FOLLOW_RPAREN_in_condition_group_comparison3603 = frozenset([1])
    FOLLOW_sql_expression_in_condition_group_comparison3608 = frozenset([66, 67, 68, 69, 70, 71])
    FOLLOW_set_in_condition_group_comparison3610 = frozenset([62, 63, 64, 65, 91, 95, 98, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_any_in_condition_group_comparison3638 = frozenset([52])
    FOLLOW_k_some_in_condition_group_comparison3642 = frozenset([52])
    FOLLOW_k_all_in_condition_group_comparison3646 = frozenset([52])
    FOLLOW_LPAREN_in_condition_group_comparison3650 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_condition_group_comparison3654 = frozenset([53])
    FOLLOW_select_statement_in_condition_group_comparison3658 = frozenset([53])
    FOLLOW_RPAREN_in_condition_group_comparison3662 = frozenset([1])
    FOLLOW_LPAREN_in_condition_in3672 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_condition_in3674 = frozenset([53])
    FOLLOW_RPAREN_in_condition_in3676 = frozenset([135, 157])
    FOLLOW_k_not_in_condition_in3680 = frozenset([135, 157])
    FOLLOW_k_in_in_condition_in3685 = frozenset([52])
    FOLLOW_LPAREN_in_condition_in3687 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_condition_in3691 = frozenset([53])
    FOLLOW_select_statement_in_condition_in3695 = frozenset([53])
    FOLLOW_RPAREN_in_condition_in3699 = frozenset([1])
    FOLLOW_sql_expression_in_condition_in3704 = frozenset([135, 157])
    FOLLOW_k_not_in_condition_in3708 = frozenset([135, 157])
    FOLLOW_k_in_in_condition_in3713 = frozenset([52])
    FOLLOW_LPAREN_in_condition_in3715 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expression_list_in_condition_in3719 = frozenset([53])
    FOLLOW_select_statement_in_condition_in3723 = frozenset([53])
    FOLLOW_RPAREN_in_condition_in3727 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_is_a_set3737 = frozenset([143])
    FOLLOW_k_is_in_condition_is_a_set3739 = frozenset([157, 211])
    FOLLOW_k_not_in_condition_is_a_set3743 = frozenset([157, 211])
    FOLLOW_k_a_in_condition_is_a_set3748 = frozenset([184])
    FOLLOW_k_set_in_condition_is_a_set3750 = frozenset([1])
    FOLLOW_column_name_in_condition_is_any3762 = frozenset([143])
    FOLLOW_k_is_in_condition_is_any3764 = frozenset([62, 63, 64, 65, 91, 98, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_any_in_condition_is_any3769 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_is_empty3779 = frozenset([143])
    FOLLOW_k_is_in_condition_is_empty3781 = frozenset([157, 419])
    FOLLOW_k_not_in_condition_is_empty3785 = frozenset([157, 419])
    FOLLOW_k_empty_in_condition_is_empty3790 = frozenset([1])
    FOLLOW_sql_expression_in_condition_is_of_type3800 = frozenset([143])
    FOLLOW_k_is_in_condition_is_of_type3802 = frozenset([157, 162])
    FOLLOW_k_not_in_condition_is_of_type3805 = frozenset([157, 162])
    FOLLOW_k_of_in_condition_is_of_type3809 = frozenset([52, 493])
    FOLLOW_k_type_in_condition_is_of_type3813 = frozenset([52])
    FOLLOW_LPAREN_in_condition_is_of_type3818 = frozenset([62, 63, 64, 65])
    FOLLOW_type_name_in_condition_is_of_type3820 = frozenset([53])
    FOLLOW_RPAREN_in_condition_is_of_type3822 = frozenset([1])
    FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names3832 = frozenset([1, 44])
    FOLLOW_COMMA_in_condition_is_of_type_names3836 = frozenset([62, 63, 64, 65, 324])
    FOLLOW_condition_is_of_type_name_in_condition_is_of_type_names3838 = frozenset([1, 44])
    FOLLOW_k_only_in_condition_is_of_type_name3853 = frozenset([62, 63, 64, 65])
    FOLLOW_type_name_in_condition_is_of_type_name3858 = frozenset([1])
    FOLLOW_cell_reference_in_condition_is_present3868 = frozenset([143])
    FOLLOW_k_is_in_condition_is_present3870 = frozenset([463])
    FOLLOW_k_present_in_condition_is_present3872 = frozenset([1])
    FOLLOW_sql_expression_in_condition_like3882 = frozenset([145, 146, 147, 148, 157])
    FOLLOW_k_not_in_condition_like3886 = frozenset([145, 146, 147, 148, 157])
    FOLLOW_k_like_in_condition_like3893 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_likec_in_condition_like3897 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_like2_in_condition_like3901 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_like4_in_condition_like3905 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_like3909 = frozenset([1, 259])
    FOLLOW_k_escape_in_condition_like3913 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_like3915 = frozenset([1])
    FOLLOW_sql_expression_in_condition_memeber3928 = frozenset([157, 438])
    FOLLOW_k_not_in_condition_memeber3932 = frozenset([157, 438])
    FOLLOW_k_member_in_condition_memeber3937 = frozenset([62, 63, 64, 65, 91, 157, 162, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_of_in_condition_memeber3941 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_table_column_name_in_condition_memeber3946 = frozenset([1])
    FOLLOW_sql_expression_in_condition_between3956 = frozenset([103, 157])
    FOLLOW_k_not_in_condition_between3960 = frozenset([103, 157])
    FOLLOW_k_between_in_condition_between3965 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_between3967 = frozenset([97])
    FOLLOW_k_and_in_condition_between3969 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_condition_between3971 = frozenset([1])
    FOLLOW_k_regexp_like_in_condition_regexp_like3981 = frozenset([52])
    FOLLOW_LPAREN_in_condition_regexp_like3983 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_call_parameters_in_condition_regexp_like3985 = frozenset([53])
    FOLLOW_RPAREN_in_condition_regexp_like3987 = frozenset([1])
    FOLLOW_nested_table_column_name_in_condition_submultiset3997 = frozenset([157, 489])
    FOLLOW_k_not_in_condition_submultiset4001 = frozenset([157, 489])
    FOLLOW_k_submultiset_in_condition_submultiset4006 = frozenset([62, 63, 64, 65, 91, 157, 162, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_of_in_condition_submultiset4010 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_table_column_name_in_condition_submultiset4015 = frozenset([1])
    FOLLOW_k_equals_path_in_condition_equals_path4025 = frozenset([52])
    FOLLOW_LPAREN_in_condition_equals_path4027 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_name_in_condition_equals_path4029 = frozenset([44])
    FOLLOW_COMMA_in_condition_equals_path4031 = frozenset([72])
    FOLLOW_path_string_in_condition_equals_path4033 = frozenset([44, 53])
    FOLLOW_COMMA_in_condition_equals_path4037 = frozenset([60])
    FOLLOW_correlation_integer_in_condition_equals_path4039 = frozenset([53])
    FOLLOW_RPAREN_in_condition_equals_path4044 = frozenset([1])
    FOLLOW_k_under_path_in_condition_under_path4054 = frozenset([52])
    FOLLOW_LPAREN_in_condition_under_path4056 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_name_in_condition_under_path4058 = frozenset([44])
    FOLLOW_COMMA_in_condition_under_path4062 = frozenset([60])
    FOLLOW_levels_in_condition_under_path4064 = frozenset([44])
    FOLLOW_COMMA_in_condition_under_path4069 = frozenset([72])
    FOLLOW_path_string_in_condition_under_path4071 = frozenset([44, 53])
    FOLLOW_COMMA_in_condition_under_path4075 = frozenset([60])
    FOLLOW_correlation_integer_in_condition_under_path4077 = frozenset([53])
    FOLLOW_RPAREN_in_condition_under_path4082 = frozenset([1])
    FOLLOW_integer_in_levels4092 = frozenset([1])
    FOLLOW_integer_in_correlation_integer4102 = frozenset([1])
    FOLLOW_quoted_string_in_path_string4112 = frozenset([1])
    FOLLOW_identifier_in_type_name4122 = frozenset([1, 46])
    FOLLOW_DOT_in_type_name4126 = frozenset([62, 63, 64, 65])
    FOLLOW_identifier_in_type_name4128 = frozenset([1, 46])
    FOLLOW_NUMBER_in_integer4141 = frozenset([1])
    FOLLOW_sql_identifier_in_column_name4151 = frozenset([1])
    FOLLOW_sql_identifier_in_nested_table4161 = frozenset([1])
    FOLLOW_schema_name_in_nested_table_column_name4173 = frozenset([46])
    FOLLOW_DOT_in_nested_table_column_name4175 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_table_name_in_nested_table_column_name4181 = frozenset([46])
    FOLLOW_DOT_in_nested_table_column_name4183 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_nested_table_in_nested_table_column_name4188 = frozenset([46])
    FOLLOW_DOT_in_nested_table_column_name4190 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_column_name_in_nested_table_column_name4194 = frozenset([1])
    FOLLOW_sql_expression_in_sql_expressions4204 = frozenset([1, 44])
    FOLLOW_COMMA_in_sql_expressions4208 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_sql_expressions4210 = frozenset([1, 44])
    FOLLOW_expression_list_in_grouping_expression_list4223 = frozenset([1, 44])
    FOLLOW_COMMA_in_grouping_expression_list4227 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expression_list_in_grouping_expression_list4229 = frozenset([1, 44])
    FOLLOW_LPAREN_in_expression_list4242 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_expression_list4244 = frozenset([53])
    FOLLOW_RPAREN_in_expression_list4246 = frozenset([1])
    FOLLOW_sql_expressions_in_expression_list4251 = frozenset([1])
    FOLLOW_sql_identifier_in_cell_reference4261 = frozenset([1])
    FOLLOW_LPAREN_in_condition_paren4272 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 98, 105, 124, 125, 144, 157, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_condition_in_condition_paren4274 = frozenset([53])
    FOLLOW_RPAREN_in_condition_paren4276 = frozenset([1])
    FOLLOW_k_order_in_order_by_clause4291 = frozenset([104, 522])
    FOLLOW_k_siblings_in_order_by_clause4293 = frozenset([104])
    FOLLOW_k_by_in_order_by_clause4297 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_order_by_clause_part_first_in_order_by_clause4299 = frozenset([1, 44])
    FOLLOW_order_by_clause_part_next_in_order_by_clause4301 = frozenset([1, 44])
    FOLLOW_sql_expression_in_order_by_clause_part_first4332 = frozenset([1, 101, 119, 449])
    FOLLOW_k_asc_in_order_by_clause_part_first4334 = frozenset([1, 119, 449])
    FOLLOW_k_desc_in_order_by_clause_part_first4338 = frozenset([1, 449])
    FOLLOW_k_nulls_in_order_by_clause_part_first4343 = frozenset([512])
    FOLLOW_k_first_in_order_by_clause_part_first4345 = frozenset([1, 449])
    FOLLOW_k_nulls_in_order_by_clause_part_first4350 = frozenset([432])
    FOLLOW_k_last_in_order_by_clause_part_first4352 = frozenset([1])
    FOLLOW_COMMA_in_order_by_clause_part_next4372 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_order_by_clause_part_next4374 = frozenset([1, 101, 119, 449])
    FOLLOW_k_asc_in_order_by_clause_part_next4376 = frozenset([1, 119, 449])
    FOLLOW_k_desc_in_order_by_clause_part_next4380 = frozenset([1, 449])
    FOLLOW_k_nulls_in_order_by_clause_part_next4385 = frozenset([512])
    FOLLOW_k_first_in_order_by_clause_part_next4387 = frozenset([1, 449])
    FOLLOW_k_nulls_in_order_by_clause_part_next4392 = frozenset([432])
    FOLLOW_k_last_in_order_by_clause_part_next4394 = frozenset([1])
    FOLLOW_k_limit_in_limit_clause4417 = frozenset([60])
    FOLLOW_NUMBER_in_limit_clause4419 = frozenset([1])
    FOLLOW_93_in_k_access4446 = frozenset([1])
    FOLLOW_94_in_k_add4459 = frozenset([1])
    FOLLOW_95_in_k_all4472 = frozenset([1])
    FOLLOW_96_in_k_alter4485 = frozenset([1])
    FOLLOW_97_in_k_and4498 = frozenset([1])
    FOLLOW_98_in_k_any4511 = frozenset([1])
    FOLLOW_99_in_k_arraylen4524 = frozenset([1])
    FOLLOW_100_in_k_as4537 = frozenset([1])
    FOLLOW_101_in_k_asc4550 = frozenset([1])
    FOLLOW_102_in_k_audit4563 = frozenset([1])
    FOLLOW_103_in_k_between4576 = frozenset([1])
    FOLLOW_104_in_k_by4589 = frozenset([1])
    FOLLOW_105_in_k_case4602 = frozenset([1])
    FOLLOW_106_in_k_char4616 = frozenset([1])
    FOLLOW_107_in_k_check4629 = frozenset([1])
    FOLLOW_108_in_k_cluster4642 = frozenset([1])
    FOLLOW_109_in_k_column4655 = frozenset([1])
    FOLLOW_110_in_k_comment4668 = frozenset([1])
    FOLLOW_111_in_k_compress4681 = frozenset([1])
    FOLLOW_112_in_k_connect4694 = frozenset([1])
    FOLLOW_113_in_k_create4707 = frozenset([1])
    FOLLOW_114_in_k_current4720 = frozenset([1])
    FOLLOW_115_in_k_date4733 = frozenset([1])
    FOLLOW_116_in_k_decimal4746 = frozenset([1])
    FOLLOW_117_in_k_default4759 = frozenset([1])
    FOLLOW_118_in_k_delete4772 = frozenset([1])
    FOLLOW_119_in_k_desc4785 = frozenset([1])
    FOLLOW_120_in_k_distinct4798 = frozenset([1])
    FOLLOW_121_in_k_drop4811 = frozenset([1])
    FOLLOW_122_in_k_else4824 = frozenset([1])
    FOLLOW_123_in_k_exclusive4837 = frozenset([1])
    FOLLOW_124_in_k_exists4850 = frozenset([1])
    FOLLOW_125_in_k_false4863 = frozenset([1])
    FOLLOW_126_in_k_file4877 = frozenset([1])
    FOLLOW_127_in_k_float4890 = frozenset([1])
    FOLLOW_128_in_k_for4903 = frozenset([1])
    FOLLOW_129_in_k_from4916 = frozenset([1])
    FOLLOW_130_in_k_grant4929 = frozenset([1])
    FOLLOW_131_in_k_group4942 = frozenset([1])
    FOLLOW_132_in_k_having4955 = frozenset([1])
    FOLLOW_133_in_k_identified4968 = frozenset([1])
    FOLLOW_134_in_k_immediate4981 = frozenset([1])
    FOLLOW_135_in_k_in4994 = frozenset([1])
    FOLLOW_136_in_k_increment5007 = frozenset([1])
    FOLLOW_137_in_k_index5020 = frozenset([1])
    FOLLOW_138_in_k_initial5033 = frozenset([1])
    FOLLOW_139_in_k_insert5046 = frozenset([1])
    FOLLOW_140_in_k_integer5059 = frozenset([1])
    FOLLOW_141_in_k_intersect5072 = frozenset([1])
    FOLLOW_142_in_k_into5085 = frozenset([1])
    FOLLOW_143_in_k_is5098 = frozenset([1])
    FOLLOW_144_in_k_level5111 = frozenset([1])
    FOLLOW_145_in_k_like5124 = frozenset([1])
    FOLLOW_146_in_k_like25137 = frozenset([1])
    FOLLOW_147_in_k_like45150 = frozenset([1])
    FOLLOW_148_in_k_likec5163 = frozenset([1])
    FOLLOW_149_in_k_lock5176 = frozenset([1])
    FOLLOW_150_in_k_long5189 = frozenset([1])
    FOLLOW_151_in_k_maxextents5202 = frozenset([1])
    FOLLOW_152_in_k_minus5215 = frozenset([1])
    FOLLOW_153_in_k_mode5228 = frozenset([1])
    FOLLOW_154_in_k_modify5241 = frozenset([1])
    FOLLOW_155_in_k_noaudit5254 = frozenset([1])
    FOLLOW_156_in_k_nocompress5267 = frozenset([1])
    FOLLOW_157_in_k_not5280 = frozenset([1])
    FOLLOW_158_in_k_notfound5293 = frozenset([1])
    FOLLOW_159_in_k_nowait5306 = frozenset([1])
    FOLLOW_160_in_k_null5319 = frozenset([1])
    FOLLOW_161_in_k_number5332 = frozenset([1])
    FOLLOW_162_in_k_of5345 = frozenset([1])
    FOLLOW_163_in_k_offline5358 = frozenset([1])
    FOLLOW_164_in_k_on5371 = frozenset([1])
    FOLLOW_165_in_k_online5384 = frozenset([1])
    FOLLOW_166_in_k_option5397 = frozenset([1])
    FOLLOW_167_in_k_or5410 = frozenset([1])
    FOLLOW_168_in_k_order5423 = frozenset([1])
    FOLLOW_169_in_k_pctfree5436 = frozenset([1])
    FOLLOW_170_in_k_prior5449 = frozenset([1])
    FOLLOW_171_in_k_privileges5462 = frozenset([1])
    FOLLOW_172_in_k_public5475 = frozenset([1])
    FOLLOW_173_in_k_raw5488 = frozenset([1])
    FOLLOW_174_in_k_rename5501 = frozenset([1])
    FOLLOW_175_in_k_resource5514 = frozenset([1])
    FOLLOW_176_in_k_revoke5527 = frozenset([1])
    FOLLOW_177_in_k_row5540 = frozenset([1])
    FOLLOW_178_in_k_rowid5553 = frozenset([1])
    FOLLOW_179_in_k_rowlabel5566 = frozenset([1])
    FOLLOW_180_in_k_rownum5579 = frozenset([1])
    FOLLOW_181_in_k_rows5592 = frozenset([1])
    FOLLOW_182_in_k_select5605 = frozenset([1])
    FOLLOW_183_in_k_session5618 = frozenset([1])
    FOLLOW_184_in_k_set5631 = frozenset([1])
    FOLLOW_185_in_k_share5644 = frozenset([1])
    FOLLOW_186_in_k_size5657 = frozenset([1])
    FOLLOW_187_in_k_smallint5670 = frozenset([1])
    FOLLOW_188_in_k_sqlbuf5683 = frozenset([1])
    FOLLOW_189_in_k_start5696 = frozenset([1])
    FOLLOW_190_in_k_successful5709 = frozenset([1])
    FOLLOW_191_in_k_synonym5722 = frozenset([1])
    FOLLOW_192_in_k_sysdate5735 = frozenset([1])
    FOLLOW_193_in_k_table5748 = frozenset([1])
    FOLLOW_194_in_k_then5761 = frozenset([1])
    FOLLOW_195_in_k_to5774 = frozenset([1])
    FOLLOW_196_in_k_trigger5788 = frozenset([1])
    FOLLOW_197_in_k_true5802 = frozenset([1])
    FOLLOW_198_in_k_uid5816 = frozenset([1])
    FOLLOW_199_in_k_union5829 = frozenset([1])
    FOLLOW_200_in_k_unique5842 = frozenset([1])
    FOLLOW_201_in_k_update5855 = frozenset([1])
    FOLLOW_202_in_k_user5869 = frozenset([1])
    FOLLOW_203_in_k_validate5882 = frozenset([1])
    FOLLOW_204_in_k_values5895 = frozenset([1])
    FOLLOW_205_in_k_varchar5908 = frozenset([1])
    FOLLOW_206_in_k_varchar25921 = frozenset([1])
    FOLLOW_207_in_k_view5934 = frozenset([1])
    FOLLOW_208_in_k_whenever5947 = frozenset([1])
    FOLLOW_209_in_k_where5960 = frozenset([1])
    FOLLOW_210_in_k_with5973 = frozenset([1])
    FOLLOW_set_in_reserved_word5997 = frozenset([1])
    FOLLOW_211_in_k_a6513 = frozenset([1])
    FOLLOW_212_in_k_at6527 = frozenset([1])
    FOLLOW_213_in_k_admin6540 = frozenset([1])
    FOLLOW_214_in_k_after6553 = frozenset([1])
    FOLLOW_215_in_k_allocate6566 = frozenset([1])
    FOLLOW_216_in_k_analyze6579 = frozenset([1])
    FOLLOW_217_in_k_archive6592 = frozenset([1])
    FOLLOW_218_in_k_archivelog6605 = frozenset([1])
    FOLLOW_219_in_k_authorization6618 = frozenset([1])
    FOLLOW_220_in_k_avg6632 = frozenset([1])
    FOLLOW_221_in_k_backup6645 = frozenset([1])
    FOLLOW_222_in_k_become6658 = frozenset([1])
    FOLLOW_223_in_k_before6671 = frozenset([1])
    FOLLOW_224_in_k_begin6684 = frozenset([1])
    FOLLOW_225_in_k_block6697 = frozenset([1])
    FOLLOW_226_in_k_body6711 = frozenset([1])
    FOLLOW_227_in_k_cache6724 = frozenset([1])
    FOLLOW_228_in_k_cancel6737 = frozenset([1])
    FOLLOW_229_in_k_cascade6750 = frozenset([1])
    FOLLOW_230_in_k_change6763 = frozenset([1])
    FOLLOW_231_in_k_character6776 = frozenset([1])
    FOLLOW_232_in_k_checkpoint6789 = frozenset([1])
    FOLLOW_233_in_k_close6803 = frozenset([1])
    FOLLOW_234_in_k_cobol6816 = frozenset([1])
    FOLLOW_235_in_k_commit6829 = frozenset([1])
    FOLLOW_236_in_k_compile6842 = frozenset([1])
    FOLLOW_237_in_k_constraint6855 = frozenset([1])
    FOLLOW_238_in_k_constraints6868 = frozenset([1])
    FOLLOW_239_in_k_contents6881 = frozenset([1])
    FOLLOW_240_in_k_continue6895 = frozenset([1])
    FOLLOW_241_in_k_controlfile6908 = frozenset([1])
    FOLLOW_242_in_k_count6921 = frozenset([1])
    FOLLOW_243_in_k_cursor6934 = frozenset([1])
    FOLLOW_244_in_k_cycle6948 = frozenset([1])
    FOLLOW_245_in_k_database6961 = frozenset([1])
    FOLLOW_246_in_k_datafile6974 = frozenset([1])
    FOLLOW_247_in_k_day6987 = frozenset([1])
    FOLLOW_248_in_k_dba7000 = frozenset([1])
    FOLLOW_249_in_k_dbtimezone7013 = frozenset([1])
    FOLLOW_250_in_k_dec7026 = frozenset([1])
    FOLLOW_251_in_k_declare7039 = frozenset([1])
    FOLLOW_252_in_k_disable7052 = frozenset([1])
    FOLLOW_253_in_k_dismount7065 = frozenset([1])
    FOLLOW_254_in_k_double7078 = frozenset([1])
    FOLLOW_255_in_k_dump7092 = frozenset([1])
    FOLLOW_256_in_k_each7105 = frozenset([1])
    FOLLOW_257_in_k_enable7118 = frozenset([1])
    FOLLOW_258_in_k_end7131 = frozenset([1])
    FOLLOW_259_in_k_escape7144 = frozenset([1])
    FOLLOW_260_in_k_events7157 = frozenset([1])
    FOLLOW_261_in_k_except7170 = frozenset([1])
    FOLLOW_262_in_k_exceptions7183 = frozenset([1])
    FOLLOW_263_in_k_exec7196 = frozenset([1])
    FOLLOW_264_in_k_execute7210 = frozenset([1])
    FOLLOW_265_in_k_explain7223 = frozenset([1])
    FOLLOW_266_in_k_extent7236 = frozenset([1])
    FOLLOW_267_in_k_externally7250 = frozenset([1])
    FOLLOW_268_in_k_fetch7263 = frozenset([1])
    FOLLOW_269_in_k_flush7276 = frozenset([1])
    FOLLOW_270_in_k_force7289 = frozenset([1])
    FOLLOW_271_in_k_foreign7302 = frozenset([1])
    FOLLOW_272_in_k_fortran7315 = frozenset([1])
    FOLLOW_273_in_k_found7328 = frozenset([1])
    FOLLOW_274_in_k_freelist7341 = frozenset([1])
    FOLLOW_275_in_k_freelists7354 = frozenset([1])
    FOLLOW_276_in_k_function7368 = frozenset([1])
    FOLLOW_277_in_k_go7381 = frozenset([1])
    FOLLOW_278_in_k_goto7394 = frozenset([1])
    FOLLOW_279_in_k_groups7407 = frozenset([1])
    FOLLOW_280_in_k_including7420 = frozenset([1])
    FOLLOW_281_in_k_indicator7433 = frozenset([1])
    FOLLOW_282_in_k_initrans7446 = frozenset([1])
    FOLLOW_283_in_k_instance7459 = frozenset([1])
    FOLLOW_284_in_k_int7473 = frozenset([1])
    FOLLOW_285_in_k_key7487 = frozenset([1])
    FOLLOW_286_in_k_language7500 = frozenset([1])
    FOLLOW_287_in_k_layer7513 = frozenset([1])
    FOLLOW_288_in_k_link7526 = frozenset([1])
    FOLLOW_289_in_k_lists7539 = frozenset([1])
    FOLLOW_290_in_k_logfile7553 = frozenset([1])
    FOLLOW_291_in_k_local7567 = frozenset([1])
    FOLLOW_292_in_k_locked7581 = frozenset([1])
    FOLLOW_293_in_k_manage7594 = frozenset([1])
    FOLLOW_294_in_k_manual7607 = frozenset([1])
    FOLLOW_295_in_k_max7620 = frozenset([1])
    FOLLOW_296_in_k_maxdatafiles7633 = frozenset([1])
    FOLLOW_297_in_k_maxinstances7646 = frozenset([1])
    FOLLOW_298_in_k_maxlogfiles7659 = frozenset([1])
    FOLLOW_299_in_k_maxloghistory7673 = frozenset([1])
    FOLLOW_300_in_k_maxlogmembers7686 = frozenset([1])
    FOLLOW_301_in_k_maxtrans7699 = frozenset([1])
    FOLLOW_302_in_k_maxvalue7712 = frozenset([1])
    FOLLOW_303_in_k_min7725 = frozenset([1])
    FOLLOW_304_in_k_minextents7738 = frozenset([1])
    FOLLOW_305_in_k_minvalue7751 = frozenset([1])
    FOLLOW_306_in_k_module7764 = frozenset([1])
    FOLLOW_307_in_k_month7778 = frozenset([1])
    FOLLOW_308_in_k_mount7792 = frozenset([1])
    FOLLOW_309_in_k_new7805 = frozenset([1])
    FOLLOW_310_in_k_next7818 = frozenset([1])
    FOLLOW_311_in_k_noarchivelog7831 = frozenset([1])
    FOLLOW_312_in_k_nocache7844 = frozenset([1])
    FOLLOW_313_in_k_nocycle7857 = frozenset([1])
    FOLLOW_314_in_k_nomaxvalue7870 = frozenset([1])
    FOLLOW_315_in_k_nominvalue7883 = frozenset([1])
    FOLLOW_316_in_k_none7897 = frozenset([1])
    FOLLOW_317_in_k_noorder7910 = frozenset([1])
    FOLLOW_318_in_k_noresetlogs7923 = frozenset([1])
    FOLLOW_319_in_k_normal7936 = frozenset([1])
    FOLLOW_320_in_k_nosort7949 = frozenset([1])
    FOLLOW_321_in_k_numeric7963 = frozenset([1])
    FOLLOW_322_in_k_off7976 = frozenset([1])
    FOLLOW_323_in_k_old7989 = frozenset([1])
    FOLLOW_324_in_k_only8002 = frozenset([1])
    FOLLOW_325_in_k_open8015 = frozenset([1])
    FOLLOW_326_in_k_optimal8028 = frozenset([1])
    FOLLOW_327_in_k_own8042 = frozenset([1])
    FOLLOW_328_in_k_package8055 = frozenset([1])
    FOLLOW_329_in_k_parallel8068 = frozenset([1])
    FOLLOW_330_in_k_pctincrease8081 = frozenset([1])
    FOLLOW_331_in_k_pctused8094 = frozenset([1])
    FOLLOW_332_in_k_plan8107 = frozenset([1])
    FOLLOW_333_in_k_pli8120 = frozenset([1])
    FOLLOW_334_in_k_precision8133 = frozenset([1])
    FOLLOW_335_in_k_primary8146 = frozenset([1])
    FOLLOW_336_in_k_private8159 = frozenset([1])
    FOLLOW_337_in_k_procedure8172 = frozenset([1])
    FOLLOW_338_in_k_profile8186 = frozenset([1])
    FOLLOW_339_in_k_quota8200 = frozenset([1])
    FOLLOW_340_in_k_read8213 = frozenset([1])
    FOLLOW_341_in_k_real8226 = frozenset([1])
    FOLLOW_342_in_k_recover8239 = frozenset([1])
    FOLLOW_343_in_k_references8252 = frozenset([1])
    FOLLOW_344_in_k_referencing8265 = frozenset([1])
    FOLLOW_345_in_k_resetlogs8278 = frozenset([1])
    FOLLOW_346_in_k_restricted8291 = frozenset([1])
    FOLLOW_347_in_k_reuse8305 = frozenset([1])
    FOLLOW_348_in_k_role8318 = frozenset([1])
    FOLLOW_349_in_k_roles8331 = frozenset([1])
    FOLLOW_350_in_k_rollback8345 = frozenset([1])
    FOLLOW_351_in_k_savepoint8358 = frozenset([1])
    FOLLOW_352_in_k_schema8371 = frozenset([1])
    FOLLOW_353_in_k_scn8384 = frozenset([1])
    FOLLOW_354_in_k_second8397 = frozenset([1])
    FOLLOW_355_in_k_section8410 = frozenset([1])
    FOLLOW_356_in_k_segment8423 = frozenset([1])
    FOLLOW_357_in_k_sequence8436 = frozenset([1])
    FOLLOW_358_in_k_sessiontimezone8449 = frozenset([1])
    FOLLOW_359_in_k_shared8462 = frozenset([1])
    FOLLOW_360_in_k_snapshot8476 = frozenset([1])
    FOLLOW_361_in_k_skip8489 = frozenset([1])
    FOLLOW_362_in_k_some8502 = frozenset([1])
    FOLLOW_363_in_k_sort8515 = frozenset([1])
    FOLLOW_364_in_k_sql8528 = frozenset([1])
    FOLLOW_365_in_k_sqlcode8541 = frozenset([1])
    FOLLOW_366_in_k_sqlerror8554 = frozenset([1])
    FOLLOW_367_in_k_sqlstate8567 = frozenset([1])
    FOLLOW_368_in_k_statement_ID8580 = frozenset([1])
    FOLLOW_369_in_k_statistics8593 = frozenset([1])
    FOLLOW_370_in_k_stop8606 = frozenset([1])
    FOLLOW_371_in_k_storage8619 = frozenset([1])
    FOLLOW_372_in_k_sum8632 = frozenset([1])
    FOLLOW_373_in_k_switch8645 = frozenset([1])
    FOLLOW_374_in_k_system8659 = frozenset([1])
    FOLLOW_375_in_k_tables8672 = frozenset([1])
    FOLLOW_376_in_k_tablespace8685 = frozenset([1])
    FOLLOW_377_in_k_temporary8698 = frozenset([1])
    FOLLOW_378_in_k_thread8711 = frozenset([1])
    FOLLOW_379_in_k_time8724 = frozenset([1])
    FOLLOW_380_in_k_tracing8737 = frozenset([1])
    FOLLOW_381_in_k_transaction8750 = frozenset([1])
    FOLLOW_382_in_k_triggers8764 = frozenset([1])
    FOLLOW_383_in_k_truncate8778 = frozenset([1])
    FOLLOW_384_in_k_under8791 = frozenset([1])
    FOLLOW_385_in_k_unlimited8804 = frozenset([1])
    FOLLOW_386_in_k_until8817 = frozenset([1])
    FOLLOW_387_in_k_use8830 = frozenset([1])
    FOLLOW_388_in_k_using8844 = frozenset([1])
    FOLLOW_389_in_k_wait8857 = frozenset([1])
    FOLLOW_390_in_k_when8870 = frozenset([1])
    FOLLOW_391_in_k_work8883 = frozenset([1])
    FOLLOW_392_in_k_write8897 = frozenset([1])
    FOLLOW_393_in_k_year8911 = frozenset([1])
    FOLLOW_394_in_k_zone8925 = frozenset([1])
    FOLLOW_395_in_k_automatic8939 = frozenset([1])
    FOLLOW_396_in_k_bfile8952 = frozenset([1])
    FOLLOW_397_in_k_binary_double8965 = frozenset([1])
    FOLLOW_398_in_k_binary_float8978 = frozenset([1])
    FOLLOW_399_in_k_binary_integer8991 = frozenset([1])
    FOLLOW_400_in_k_blob9004 = frozenset([1])
    FOLLOW_401_in_k_boolean9017 = frozenset([1])
    FOLLOW_402_in_k_byte9030 = frozenset([1])
    FOLLOW_403_in_k_cast9043 = frozenset([1])
    FOLLOW_404_in_k_clob9056 = frozenset([1])
    FOLLOW_405_in_k_cluster_set9069 = frozenset([1])
    FOLLOW_406_in_k_column_value9082 = frozenset([1])
    FOLLOW_407_in_k_connect_by_iscycle9095 = frozenset([1])
    FOLLOW_408_in_k_connect_by_isleaf9108 = frozenset([1])
    FOLLOW_409_in_k_connect_by_root9121 = frozenset([1])
    FOLLOW_410_in_k_corr9134 = frozenset([1])
    FOLLOW_411_in_k_covar_pop9147 = frozenset([1])
    FOLLOW_412_in_k_covar_samp9160 = frozenset([1])
    FOLLOW_413_in_k_cross9173 = frozenset([1])
    FOLLOW_414_in_k_cube9186 = frozenset([1])
    FOLLOW_415_in_k_cume_dist9199 = frozenset([1])
    FOLLOW_416_in_k_decrement9212 = frozenset([1])
    FOLLOW_417_in_k_dense_rank9225 = frozenset([1])
    FOLLOW_418_in_k_dimension9238 = frozenset([1])
    FOLLOW_419_in_k_empty9251 = frozenset([1])
    FOLLOW_420_in_k_equals_path9264 = frozenset([1])
    FOLLOW_421_in_k_first_value9277 = frozenset([1])
    FOLLOW_422_in_k_full9290 = frozenset([1])
    FOLLOW_423_in_k_grouping9303 = frozenset([1])
    FOLLOW_424_in_k_ignore9316 = frozenset([1])
    FOLLOW_425_in_k_infinite9329 = frozenset([1])
    FOLLOW_426_in_k_inner9342 = frozenset([1])
    FOLLOW_427_in_k_interval9355 = frozenset([1])
    FOLLOW_428_in_k_iterate9368 = frozenset([1])
    FOLLOW_429_in_k_join9381 = frozenset([1])
    FOLLOW_430_in_k_keep9394 = frozenset([1])
    FOLLOW_431_in_k_lag9407 = frozenset([1])
    FOLLOW_432_in_k_last9420 = frozenset([1])
    FOLLOW_433_in_k_last_value9433 = frozenset([1])
    FOLLOW_434_in_k_lead9446 = frozenset([1])
    FOLLOW_435_in_k_left9459 = frozenset([1])
    FOLLOW_436_in_k_main9472 = frozenset([1])
    FOLLOW_437_in_k_measures9485 = frozenset([1])
    FOLLOW_438_in_k_member9498 = frozenset([1])
    FOLLOW_439_in_k_mlslabel9511 = frozenset([1])
    FOLLOW_440_in_k_model9524 = frozenset([1])
    FOLLOW_441_in_k_multiset9537 = frozenset([1])
    FOLLOW_442_in_k_nan9550 = frozenset([1])
    FOLLOW_443_in_k_national9563 = frozenset([1])
    FOLLOW_444_in_k_natural9576 = frozenset([1])
    FOLLOW_445_in_k_nav9589 = frozenset([1])
    FOLLOW_446_in_k_nchar9602 = frozenset([1])
    FOLLOW_447_in_k_nclob9615 = frozenset([1])
    FOLLOW_448_in_k_ntile9628 = frozenset([1])
    FOLLOW_449_in_k_nulls9641 = frozenset([1])
    FOLLOW_450_in_k_nvarchar9654 = frozenset([1])
    FOLLOW_451_in_k_nvarchar29667 = frozenset([1])
    FOLLOW_452_in_k_object_value9680 = frozenset([1])
    FOLLOW_453_in_k_ora_rowscn9693 = frozenset([1])
    FOLLOW_454_in_k_outer9706 = frozenset([1])
    FOLLOW_455_in_k_over9719 = frozenset([1])
    FOLLOW_456_in_k_partition9732 = frozenset([1])
    FOLLOW_457_in_k_percentile_cont9745 = frozenset([1])
    FOLLOW_458_in_k_percentile_disc9758 = frozenset([1])
    FOLLOW_459_in_k_percent_rank9771 = frozenset([1])
    FOLLOW_460_in_k_pivot9784 = frozenset([1])
    FOLLOW_461_in_k_pls_integer9797 = frozenset([1])
    FOLLOW_462_in_k_positive9810 = frozenset([1])
    FOLLOW_463_in_k_present9823 = frozenset([1])
    FOLLOW_464_in_k_rank9836 = frozenset([1])
    FOLLOW_465_in_k_ratio_to_report9849 = frozenset([1])
    FOLLOW_466_in_k_reference9862 = frozenset([1])
    FOLLOW_467_in_k_regexp_like9875 = frozenset([1])
    FOLLOW_468_in_k_regr_avgx9888 = frozenset([1])
    FOLLOW_469_in_k_regr_avgy9901 = frozenset([1])
    FOLLOW_470_in_k_regr_count9914 = frozenset([1])
    FOLLOW_471_in_k_regr_intercept9927 = frozenset([1])
    FOLLOW_472_in_k_regr_r29940 = frozenset([1])
    FOLLOW_473_in_k_regr_slope9953 = frozenset([1])
    FOLLOW_474_in_k_regr_sxx9966 = frozenset([1])
    FOLLOW_475_in_k_regr_sxy9979 = frozenset([1])
    FOLLOW_476_in_k_regr_syy9992 = frozenset([1])
    FOLLOW_477_in_k_right10005 = frozenset([1])
    FOLLOW_478_in_k_rollup10018 = frozenset([1])
    FOLLOW_479_in_k_row_number10031 = frozenset([1])
    FOLLOW_480_in_k_rules10044 = frozenset([1])
    FOLLOW_481_in_k_sample10057 = frozenset([1])
    FOLLOW_482_in_k_search10070 = frozenset([1])
    FOLLOW_483_in_k_sequential10083 = frozenset([1])
    FOLLOW_484_in_k_sets10096 = frozenset([1])
    FOLLOW_485_in_k_single10109 = frozenset([1])
    FOLLOW_486_in_k_stddev10122 = frozenset([1])
    FOLLOW_487_in_k_stddev_pop10135 = frozenset([1])
    FOLLOW_488_in_k_stddev_samp10148 = frozenset([1])
    FOLLOW_489_in_k_submultiset10161 = frozenset([1])
    FOLLOW_490_in_k_subpartition10174 = frozenset([1])
    FOLLOW_491_in_k_the10187 = frozenset([1])
    FOLLOW_492_in_k_timestamp10200 = frozenset([1])
    FOLLOW_493_in_k_type10213 = frozenset([1])
    FOLLOW_494_in_k_unbounded10226 = frozenset([1])
    FOLLOW_495_in_k_under_path10239 = frozenset([1])
    FOLLOW_496_in_k_updated10252 = frozenset([1])
    FOLLOW_497_in_k_upsert10265 = frozenset([1])
    FOLLOW_498_in_k_urowid10278 = frozenset([1])
    FOLLOW_499_in_k_variance10291 = frozenset([1])
    FOLLOW_500_in_k_varying10304 = frozenset([1])
    FOLLOW_501_in_k_var_pop10317 = frozenset([1])
    FOLLOW_502_in_k_var_samp10330 = frozenset([1])
    FOLLOW_503_in_k_versions_endscn10343 = frozenset([1])
    FOLLOW_504_in_k_versions_endtime10356 = frozenset([1])
    FOLLOW_505_in_k_versions_operation10369 = frozenset([1])
    FOLLOW_506_in_k_versions_starscn10382 = frozenset([1])
    FOLLOW_507_in_k_versions_starttime10395 = frozenset([1])
    FOLLOW_508_in_k_versions_xid10408 = frozenset([1])
    FOLLOW_509_in_k_xml10421 = frozenset([1])
    FOLLOW_510_in_k_xmldata10434 = frozenset([1])
    FOLLOW_511_in_k_errors10448 = frozenset([1])
    FOLLOW_512_in_k_first10461 = frozenset([1])
    FOLLOW_513_in_k_limit10474 = frozenset([1])
    FOLLOW_514_in_k_log10487 = frozenset([1])
    FOLLOW_515_in_k_reject10500 = frozenset([1])
    FOLLOW_516_in_k_return10513 = frozenset([1])
    FOLLOW_517_in_k_returning10526 = frozenset([1])
    FOLLOW_518_in_k_merge10540 = frozenset([1])
    FOLLOW_519_in_k_matched10553 = frozenset([1])
    FOLLOW_520_in_k_following10567 = frozenset([1])
    FOLLOW_521_in_k_range10580 = frozenset([1])
    FOLLOW_522_in_k_siblings10593 = frozenset([1])
    FOLLOW_523_in_k_unpivot10606 = frozenset([1])
    FOLLOW_524_in_k_value10621 = frozenset([1])
    FOLLOW_525_in_k_breadth10635 = frozenset([1])
    FOLLOW_526_in_k_depth10648 = frozenset([1])
    FOLLOW_527_in_k_exclude10661 = frozenset([1])
    FOLLOW_528_in_k_include10674 = frozenset([1])
    FOLLOW_529_in_k_mivalue10687 = frozenset([1])
    FOLLOW_530_in_k_preceding10700 = frozenset([1])
    FOLLOW_531_in_k_respect10713 = frozenset([1])
    FOLLOW_532_in_k_seed10726 = frozenset([1])
    FOLLOW_533_in_k_versions10739 = frozenset([1])
    FOLLOW_534_in_k_distance10752 = frozenset([1])
    FOLLOW_535_in_k_video_extraction10767 = frozenset([1])
    FOLLOW_536_in_k_extraction10782 = frozenset([1])
    FOLLOW_537_in_k_video_feature_extraction10797 = frozenset([1])
    FOLLOW_538_in_k_knn_avg_distance10812 = frozenset([1])
    FOLLOW_91_in_k_knn10827 = frozenset([1])
    FOLLOW_539_in_k_outlier10842 = frozenset([1])
    FOLLOW_540_in_k_farthest10857 = frozenset([1])
    FOLLOW_541_in_k_feature_distance10872 = frozenset([1])
    FOLLOW_542_in_k_outlier_line10887 = frozenset([1])
    FOLLOW_543_in_k_outlier_score10902 = frozenset([1])
    FOLLOW_544_in_k_video_similarity10917 = frozenset([1])
    FOLLOW_set_in_keyword0 = frozenset([1])
    FOLLOW_QUOTED_STRING_in_quoted_string12476 = frozenset([1])
    FOLLOW_set_in_synpred13_YSmart853 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_mul_in_synpred13_YSmart867 = frozenset([1])
    FOLLOW_set_in_synpred15_YSmart884 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_sign_in_synpred15_YSmart894 = frozenset([1])
    FOLLOW_k_connect_by_root_in_synpred19_YSmart922 = frozenset([1])
    FOLLOW_EXPONENT_in_synpred20_YSmart941 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expr_expr_in_synpred20_YSmart943 = frozenset([1])
    FOLLOW_datetime_expression_in_synpred21_YSmart956 = frozenset([1])
    FOLLOW_interval_expression_in_synpred22_YSmart961 = frozenset([1])
    FOLLOW_expr_paren_in_synpred23_YSmart976 = frozenset([1])
    FOLLOW_cast_expression_in_synpred24_YSmart989 = frozenset([1])
    FOLLOW_function_expression_in_synpred25_YSmart1001 = frozenset([1])
    FOLLOW_case_expression_in_synpred26_YSmart1014 = frozenset([1])
    FOLLOW_simple_expression_in_synpred27_YSmart1027 = frozenset([1])
    FOLLOW_subquery_in_synpred28_YSmart1040 = frozenset([1])
    FOLLOW_simple_case_expression_in_synpred32_YSmart1158 = frozenset([1])
    FOLLOW_column_spec_in_synpred42_YSmart1274 = frozenset([1])
    FOLLOW_function_expression_in_synpred45_YSmart1344 = frozenset([1])
    FOLLOW_cast_expression_in_synpred46_YSmart1348 = frozenset([1])
    FOLLOW_quoted_string_in_synpred48_YSmart1377 = frozenset([1])
    FOLLOW_k_dbtimezone_in_synpred49_YSmart1381 = frozenset([1])
    FOLLOW_k_sessiontimezone_in_synpred50_YSmart1385 = frozenset([1])
    FOLLOW_function_expression_in_synpred51_YSmart1407 = frozenset([1])
    FOLLOW_cast_expression_in_synpred52_YSmart1411 = frozenset([1])
    FOLLOW_function_expression_in_synpred53_YSmart1423 = frozenset([1])
    FOLLOW_cast_expression_in_synpred54_YSmart1427 = frozenset([1])
    FOLLOW_datatype_in_synpred61_YSmart1524 = frozenset([1])
    FOLLOW_sql_identifier_in_synpred146_YSmart2267 = frozenset([1])
    FOLLOW_table_name_in_synpred172_YSmart2497 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_synpred172_YSmart2499 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_kNN_join_clause_in_synpred172_YSmart2502 = frozenset([1])
    FOLLOW_join_clause_in_synpred173_YSmart2505 = frozenset([1])
    FOLLOW_LPAREN_in_synpred174_YSmart2508 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_join_clause_in_synpred174_YSmart2510 = frozenset([53])
    FOLLOW_RPAREN_in_synpred174_YSmart2512 = frozenset([1])
    FOLLOW_table_name_in_synpred176_YSmart2526 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_synpred176_YSmart2528 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_kNN_join_clause_in_synpred176_YSmart2531 = frozenset([1])
    FOLLOW_join_clause_in_synpred177_YSmart2534 = frozenset([1])
    FOLLOW_LPAREN_in_synpred178_YSmart2537 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_join_clause_in_synpred178_YSmart2539 = frozenset([53])
    FOLLOW_RPAREN_in_synpred178_YSmart2541 = frozenset([1])
    FOLLOW_t_alias_in_synpred181_YSmart2597 = frozenset([1])
    FOLLOW_subquery_in_synpred183_YSmart2603 = frozenset([62, 63, 64, 65, 91, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_t_alias_in_synpred183_YSmart2605 = frozenset([1])
    FOLLOW_inner_cross_join_clause_in_synpred184_YSmart2635 = frozenset([1])
    FOLLOW_outer_join_clause_in_synpred185_YSmart2637 = frozenset([1])
    FOLLOW_rollup_cube_clause_in_synpred201_YSmart3023 = frozenset([1])
    FOLLOW_grouping_sets_clause_in_synpred202_YSmart3028 = frozenset([1])
    FOLLOW_rollup_cube_clause_in_synpred205_YSmart3104 = frozenset([1])
    FOLLOW_condition_or_part_first_in_synpred207_YSmart3129 = frozenset([167])
    FOLLOW_condition_or_part_next_in_synpred207_YSmart3131 = frozenset([1, 167])
    FOLLOW_condition_and_part_first_in_synpred209_YSmart3205 = frozenset([97])
    FOLLOW_condition_and_part_next_in_synpred209_YSmart3207 = frozenset([1, 97])
    FOLLOW_condition_is_in_synpred212_YSmart3312 = frozenset([1])
    FOLLOW_condition_comparison_in_synpred213_YSmart3317 = frozenset([1])
    FOLLOW_condition_group_comparison_in_synpred214_YSmart3322 = frozenset([1])
    FOLLOW_condition_in_in_synpred215_YSmart3327 = frozenset([1])
    FOLLOW_condition_is_a_set_in_synpred216_YSmart3332 = frozenset([1])
    FOLLOW_condition_is_any_in_synpred217_YSmart3337 = frozenset([1])
    FOLLOW_condition_is_empty_in_synpred218_YSmart3342 = frozenset([1])
    FOLLOW_condition_is_of_type_in_synpred219_YSmart3347 = frozenset([1])
    FOLLOW_condition_is_present_in_synpred220_YSmart3352 = frozenset([1])
    FOLLOW_condition_like_in_synpred221_YSmart3357 = frozenset([1])
    FOLLOW_condition_memeber_in_synpred222_YSmart3362 = frozenset([1])
    FOLLOW_condition_between_in_synpred223_YSmart3367 = frozenset([1])
    FOLLOW_condition_regexp_like_in_synpred224_YSmart3372 = frozenset([1])
    FOLLOW_condition_submultiset_in_synpred225_YSmart3377 = frozenset([1])
    FOLLOW_condition_equals_path_in_synpred226_YSmart3382 = frozenset([1])
    FOLLOW_condition_under_path_in_synpred227_YSmart3387 = frozenset([1])
    FOLLOW_LPAREN_in_synpred234_YSmart3448 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_synpred234_YSmart3450 = frozenset([53])
    FOLLOW_RPAREN_in_synpred234_YSmart3452 = frozenset([52, 66, 67])
    FOLLOW_outer_join_sign_in_synpred234_YSmart3456 = frozenset([66, 67])
    FOLLOW_set_in_synpred234_YSmart3461 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_subquery_in_synpred234_YSmart3471 = frozenset([1, 52])
    FOLLOW_outer_join_sign_in_synpred234_YSmart3475 = frozenset([1])
    FOLLOW_k_prior_in_synpred235_YSmart3485 = frozenset([1])
    FOLLOW_k_prior_in_synpred242_YSmart3527 = frozenset([1])
    FOLLOW_sql_expression_in_synpred243_YSmart3534 = frozenset([1])
    FOLLOW_LPAREN_in_synpred249_YSmart3561 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_synpred249_YSmart3563 = frozenset([53])
    FOLLOW_RPAREN_in_synpred249_YSmart3565 = frozenset([66, 67])
    FOLLOW_set_in_synpred249_YSmart3567 = frozenset([62, 63, 64, 65, 91, 95, 98, 178, 180, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_k_any_in_synpred249_YSmart3579 = frozenset([52])
    FOLLOW_k_some_in_synpred249_YSmart3583 = frozenset([52])
    FOLLOW_k_all_in_synpred249_YSmart3587 = frozenset([52])
    FOLLOW_LPAREN_in_synpred249_YSmart3591 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_synpred249_YSmart3595 = frozenset([53])
    FOLLOW_select_statement_in_synpred249_YSmart3599 = frozenset([53])
    FOLLOW_RPAREN_in_synpred249_YSmart3603 = frozenset([1])
    FOLLOW_LPAREN_in_synpred260_YSmart3672 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_synpred260_YSmart3674 = frozenset([53])
    FOLLOW_RPAREN_in_synpred260_YSmart3676 = frozenset([135, 157])
    FOLLOW_k_not_in_synpred260_YSmart3680 = frozenset([135, 157])
    FOLLOW_k_in_in_synpred260_YSmart3685 = frozenset([52])
    FOLLOW_LPAREN_in_synpred260_YSmart3687 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 182, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_grouping_expression_list_in_synpred260_YSmart3691 = frozenset([53])
    FOLLOW_select_statement_in_synpred260_YSmart3695 = frozenset([53])
    FOLLOW_RPAREN_in_synpred260_YSmart3699 = frozenset([1])
    FOLLOW_schema_name_in_synpred284_YSmart4173 = frozenset([46])
    FOLLOW_DOT_in_synpred284_YSmart4175 = frozenset([1])
    FOLLOW_table_name_in_synpred285_YSmart4181 = frozenset([46])
    FOLLOW_DOT_in_synpred285_YSmart4183 = frozenset([1])
    FOLLOW_COMMA_in_synpred287_YSmart4208 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expression_in_synpred287_YSmart4210 = frozenset([1])
    FOLLOW_COMMA_in_synpred288_YSmart4227 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_expression_list_in_synpred288_YSmart4229 = frozenset([1])
    FOLLOW_LPAREN_in_synpred289_YSmart4242 = frozenset([45, 47, 48, 52, 60, 62, 63, 64, 65, 72, 91, 105, 125, 144, 160, 170, 178, 180, 192, 197, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 455, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 530, 531, 532, 533, 534, 535, 536, 537, 539, 540, 541, 542, 543, 544, 545, 546])
    FOLLOW_sql_expressions_in_synpred289_YSmart4244 = frozenset([53])
    FOLLOW_RPAREN_in_synpred289_YSmart4246 = frozenset([1])



def main(argv, stdin=sys.stdin, stdout=sys.stdout, stderr=sys.stderr):
    from antlr3.main import ParserMain
    main = ParserMain("YSmartLexer", YSmartParser)
    main.stdin = stdin
    main.stdout = stdout
    main.stderr = stderr
    main.execute(argv)


if __name__ == '__main__':
    main(sys.argv)

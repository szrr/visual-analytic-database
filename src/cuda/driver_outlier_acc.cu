/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
#include <faiss/gpu/GpuAutoTune.h>
#include <faiss/gpu/GpuCloner.h>
#include <faiss/gpu/GpuIndexIVFPQ.h>
#include <faiss/gpu/StandardGpuResources.h>
#include <faiss/index_io.h>
#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFPQ.h>
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *, faiss::Index*);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern struct tableNode* knnJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *, faiss::Index *);
extern struct tableNode* cartesianProductJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
int searchFrameNum = 0;

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    char *index_path = "/home/szr/subquery/vector_src/init_vector/TRAIN_VIDEO0_index.faissindex";
    faiss::Index *index = faiss::read_index(index_path);
    faiss::gpu::StandardGpuResources resources;
    int dev_no = 0;
    index = faiss::gpu::index_cpu_to_gpu(&resources, dev_no, index);

    if(setPath == 1)
        chdir(path);

    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;
    clock_gettime(CLOCK_REALTIME,&start);
    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = pp.subCacheHits = 0;

    pp.annsTotalTime = 0;
    pp.loadIndex = 0;
    pp.indexCPU2GPU = 0;
    pp.trainIndex = 0;
    pp.saveIndex = 0;
    pp.indexAddData = 0;
    pp.indexSearch = 0;
    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.knnJoin_totalTime = 0;
    pp.knn_ANNs_time = 0;
    pp.cartesianJoin_totalTime = 0;
    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_materialize_res = 0;
    pp.joinProf_step41_materialize_res_left = 0;
    pp.joinProf_step42_materialize_res_right = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);

    std::unordered_map<std::string, char*> fileCache;

    // Load columns from the table TEST_VIDEO
    struct tableNode *test_videoTable;
    test_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *_test_video_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from TEST_VIDEO0
        outFd = open("TEST_VIDEO0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _test_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _test_video_table->totalAttr = 3;
            _test_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 3);

            _test_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
            _test_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

            // Load column 0, type: INTEGER
            _test_video_table->attrSize[0] = sizeof(int);
            _test_video_table->attrIndex[0] = 0;
            _test_video_table->attrType[0] = INT;
            _test_video_table->attrName[0] = "TEST_VIDEO0";
            _test_video_table->dataPos[0] = GPU;
            outFd = open("TEST_VIDEO0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _test_video_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _test_video_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _test_video_table->content[0] = (char *)memalign(256, outSize);
            // memcpy(_test_video_table->content[0], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_test_video_table->content[0]), outSize);
                cudaMemcpy(_test_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                fileCache["TEST_VIDEO0"] = _test_video_table->content[0];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: INTEGER
            _test_video_table->attrSize[1] = sizeof(int);
            _test_video_table->attrIndex[1] = 1;
            _test_video_table->attrType[1] = INT;
            _test_video_table->attrName[1] = "TEST_VIDEO1";
            _test_video_table->dataPos[1] = GPU;
            outFd = open("TEST_VIDEO1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _test_video_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _test_video_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _test_video_table->content[1] = (char *)memalign(256, outSize);
            // memcpy(_test_video_table->content[1], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_test_video_table->content[1]), outSize);
                cudaMemcpy(_test_video_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                fileCache["TEST_VIDEO1"] = _test_video_table->content[1];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: VECTOR
            _test_video_table->attrSize[2] = 76;
            _test_video_table->attrIndex[2] = 2;
            _test_video_table->attrType[2] = VECTOR;
            _test_video_table->attrName[2] = "TEST_VIDEO2";
            _test_video_table->dataPos[2] = GPU;
            outFd = open("TEST_VIDEO2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 76;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _test_video_table->dataFormat[2] = header.format;
            outSize = header.tupleNum * 76;
            _test_video_table->attrTotalSize[2] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _test_video_table->content[2] = (char *)memalign(256, outSize);
            // memcpy(_test_video_table->content[2], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_test_video_table->content[2]), outSize);
                cudaMemcpy(_test_video_table->content[2], content, outSize, cudaMemcpyHostToDevice);
                fileCache["TEST_VIDEO2"] = _test_video_table->content[2];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _test_video_table->tupleSize = 0 + sizeof(int) + sizeof(int) + 76;
            _test_video_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(test_videoTable,_test_video_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_test_video_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                test_videoTable = _test_video_table;
            }
            tupleOffset += header.tupleNum;
        }
        test_videoTable->colIdxNum = 0;
        _test_video_table->keepInGpuIdx = 1;
    }

    // Load columns from the table TRAIN_VIDEO
    struct tableNode *train_videoTable;
    train_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *_train_video_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from TRAIN_VIDEO0
        outFd = open("TRAIN_VIDEO0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _train_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _train_video_table->totalAttr = 1;
            _train_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 1);

            _train_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 1);
            _train_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 1);

            // Load column 0, type: VECTOR
            _train_video_table->attrSize[0] = 76;
            _train_video_table->attrIndex[0] = 0;
            _train_video_table->attrType[0] = VECTOR;
            _train_video_table->attrName[0] = "TRAIN_VIDEO0";
            _train_video_table->dataPos[0] = GPU;
            outFd = open("TRAIN_VIDEO0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 76;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _train_video_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * 76;
            _train_video_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _train_video_table->content[0] = (char *)memalign(256, outSize);
            // memcpy(_train_video_table->content[0], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_train_video_table->content[0]), outSize);
                cudaMemcpy(_train_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                fileCache["TRAIN_VIDEO0"] = _train_video_table->content[0];

                cudaMalloc((void**)&(_train_video_table->content[1]), outSize);
                cudaMemcpy(_train_video_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                fileCache["TRAIN_VIDEO0_"] = _train_video_table->content[1];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _train_video_table->tupleSize = 0 + 76;
            _train_video_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(train_videoTable,_train_video_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_train_video_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                train_videoTable = _train_video_table;
            }
            tupleOffset += header.tupleNum;
        }
        train_videoTable->colIdxNum = 0;
        _train_video_table->keepInGpuIdx = 1;
    }

    transferTableColumnToGPU(train_videoTable, 0);

    struct timespec exe_s, exe_e;
    double execution_time = 0.0;

    clock_gettime(CLOCK_REALTIME,&exe_s);

    struct tableNode *result;
    char * subqRes0;

    // Process the TableNode for TEST_VIDEO
    struct tableNode *te0;
    te0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *test_videoTablePartial;
        test_videoTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        test_videoTablePartial->totalAttr = 3;
        test_videoTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 3);

        test_videoTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
        test_videoTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 3);
        int tuple_size = 0;
        test_videoTablePartial->attrSize[0] = test_videoTable->attrSize[0];
        test_videoTablePartial->attrIndex[0] = test_videoTable->attrIndex[0];
        test_videoTablePartial->attrType[0] = test_videoTable->attrType[0];
        test_videoTablePartial->attrName[0] = "test_videoTablePartial0";
        test_videoTablePartial->dataPos[0] = test_videoTable->dataPos[0];
        test_videoTablePartial->dataFormat[0] = test_videoTable->dataFormat[0];
        test_videoTablePartial->attrTotalSize[0] = test_videoTable->attrTotalSize[0];
        test_videoTablePartial->content[0] = test_videoTable->content[0];
        tuple_size += test_videoTablePartial->attrSize[0];

        test_videoTablePartial->attrSize[1] = test_videoTable->attrSize[1];
        test_videoTablePartial->attrIndex[1] = test_videoTable->attrIndex[1];
        test_videoTablePartial->attrType[1] = test_videoTable->attrType[1];
        test_videoTablePartial->attrName[1] = "test_videoTablePartial1";
        test_videoTablePartial->dataPos[1] = test_videoTable->dataPos[1];
        test_videoTablePartial->dataFormat[1] = test_videoTable->dataFormat[1];
        test_videoTablePartial->attrTotalSize[1] = test_videoTable->attrTotalSize[1];
        test_videoTablePartial->content[1] = test_videoTable->content[1];
        tuple_size += test_videoTablePartial->attrSize[1];

        test_videoTablePartial->attrSize[2] = test_videoTable->attrSize[2];
        test_videoTablePartial->attrIndex[2] = test_videoTable->attrIndex[2];
        test_videoTablePartial->attrType[2] = test_videoTable->attrType[2];
        test_videoTablePartial->attrName[2] = "test_videoTablePartial2";
        test_videoTablePartial->dataPos[2] = test_videoTable->dataPos[2];
        test_videoTablePartial->dataFormat[2] = test_videoTable->dataFormat[2];
        test_videoTablePartial->attrTotalSize[2] = test_videoTable->attrTotalSize[2];
        test_videoTablePartial->content[2] = test_videoTable->content[2];
        tuple_size += test_videoTablePartial->attrSize[2];

        test_videoTablePartial->tupleSize = tuple_size;
        test_videoTablePartial->tupleNum = test_videoTable->tupleNum;

        test_videoTablePartial->colIdxNum = 0;
        test_videoTablePartial->keepInGpuIdx = 1;
        // Load columns from the table TEST_VIDEO
        struct tableNode *test_videoTable;
        test_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *_test_video_table;
            int outFd;
            long outSize;
            char *outTable;
            long offset, tupleOffset;
            int blockTotal;
            char* content;
            struct columnHeader header;

            // Retrieve the block number from TEST_VIDEO0
            outFd = open("TEST_VIDEO0", O_RDONLY);
            read(outFd, &header, sizeof(struct columnHeader));
            blockTotal = header.blockTotal;
            close(outFd);
            offset = 0;
            tupleOffset = 0;
            for(int i = 0; i < blockTotal; i++){

                // Table initialization
                _test_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                _test_video_table->totalAttr = 3;
                _test_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 3);

                _test_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 3);
                _test_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 3);

                // Load column 0, type: INTEGER
                _test_video_table->attrSize[0] = sizeof(int);
                _test_video_table->attrIndex[0] = 0;
                _test_video_table->attrType[0] = INT;
                _test_video_table->attrName[0] = "TEST_VIDEO0";
                _test_video_table->dataPos[0] = GPU;
                outFd = open("TEST_VIDEO0", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _test_video_table->dataFormat[0] = header.format;
                outSize = header.tupleNum * sizeof(int);
                _test_video_table->attrTotalSize[0] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("TEST_VIDEO0") != fileCache.end()) {
                    content = fileCache["TEST_VIDEO0"];
                }
                memcpy(&(_test_video_table->content[0]), &content, sizeof(char*));
                // _test_video_table->content[0] = (char *)memalign(256, outSize);
                // memcpy(_test_video_table->content[0], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                // Load column 1, type: INTEGER
                _test_video_table->attrSize[1] = sizeof(int);
                _test_video_table->attrIndex[1] = 1;
                _test_video_table->attrType[1] = INT;
                _test_video_table->attrName[1] = "TEST_VIDEO1";
                _test_video_table->dataPos[1] = GPU;
                outFd = open("TEST_VIDEO1", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _test_video_table->dataFormat[1] = header.format;
                outSize = header.tupleNum * sizeof(int);
                _test_video_table->attrTotalSize[1] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("TEST_VIDEO1") != fileCache.end()) {
                    content = fileCache["TEST_VIDEO1"];
                }
                memcpy(&(_test_video_table->content[1]), &content, sizeof(char*));
                // _test_video_table->content[1] = (char *)memalign(256, outSize);
                // memcpy(_test_video_table->content[1], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                // Load column 2, type: VECTOR
                _test_video_table->attrSize[2] = 76;
                _test_video_table->attrIndex[2] = 2;
                _test_video_table->attrType[2] = VECTOR;
                _test_video_table->attrName[2] = "TEST_VIDEO2";
                _test_video_table->dataPos[2] = GPU;
                outFd = open("TEST_VIDEO2", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * 76;
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _test_video_table->dataFormat[2] = header.format;
                outSize = header.tupleNum * 76;
                _test_video_table->attrTotalSize[2] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("TEST_VIDEO2") != fileCache.end()) {
                    content = fileCache["TEST_VIDEO2"];
                }
                memcpy(&(_test_video_table->content[2]), &content, sizeof(char*));
                // _test_video_table->content[2] = (char *)memalign(256, outSize);
                // memcpy(_test_video_table->content[2], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                _test_video_table->tupleSize = 0 + sizeof(int) + sizeof(int) + 76;
                _test_video_table->tupleNum = header.tupleNum;

                if(blockTotal != 1){
                    mergeIntoTable(test_videoTable,_test_video_table, &pp);
                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    freeTable(_test_video_table);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                }else{
                    test_videoTable = _test_video_table;
                }
                tupleOffset += header.tupleNum;
            }
            test_videoTable->colIdxNum = 0;
            _test_video_table->keepInGpuIdx = 1;
        }

        te0 = test_videoTable;
        te0->colIdxNum = 0;
    }

    // Process the TableNode for TRAIN_VIDEO
    struct tableNode *tr0;
    tr0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *train_videoTablePartial;
        train_videoTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        train_videoTablePartial->totalAttr = 1;
        train_videoTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 1);

        train_videoTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 1);
        train_videoTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 1);
        int tuple_size = 0;
        train_videoTablePartial->attrSize[0] = train_videoTable->attrSize[0];
        train_videoTablePartial->attrIndex[0] = train_videoTable->attrIndex[0];
        train_videoTablePartial->attrType[0] = train_videoTable->attrType[0];
        train_videoTablePartial->attrName[0] = "train_videoTablePartial0";
        train_videoTablePartial->dataPos[0] = train_videoTable->dataPos[0];
        train_videoTablePartial->dataFormat[0] = train_videoTable->dataFormat[0];
        train_videoTablePartial->attrTotalSize[0] = train_videoTable->attrTotalSize[0];
        train_videoTablePartial->content[0] = train_videoTable->content[0];
        tuple_size += train_videoTablePartial->attrSize[0];

        train_videoTablePartial->tupleSize = tuple_size;
        train_videoTablePartial->tupleNum = train_videoTable->tupleNum;

        train_videoTablePartial->colIdxNum = 0;
        train_videoTablePartial->keepInGpuIdx = 1;
        // Load columns from the table TRAIN_VIDEO
        struct tableNode *train_videoTable;
        train_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *_train_video_table;
            int outFd;
            long outSize;
            char *outTable;
            long offset, tupleOffset;
            int blockTotal;
            char* content;
            struct columnHeader header;

            // Retrieve the block number from TRAIN_VIDEO0
            outFd = open("TRAIN_VIDEO0", O_RDONLY);
            read(outFd, &header, sizeof(struct columnHeader));
            blockTotal = header.blockTotal;
            close(outFd);
            offset = 0;
            tupleOffset = 0;
            for(int i = 0; i < blockTotal; i++){

                // Table initialization
                _train_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                _train_video_table->totalAttr = 1;
                _train_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 1);

                _train_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 1);
                _train_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 1);

                // Load column 0, type: VECTOR
                _train_video_table->attrSize[0] = 76;
                _train_video_table->attrIndex[0] = 0;
                _train_video_table->attrType[0] = VECTOR;
                _train_video_table->attrName[0] = "TRAIN_VIDEO0";
                _train_video_table->dataPos[0] = GPU;
                outFd = open("TRAIN_VIDEO0", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * 76;
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _train_video_table->dataFormat[0] = header.format;
                outSize = header.tupleNum * 76;
                _train_video_table->attrTotalSize[0] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("TRAIN_VIDEO0") != fileCache.end()) {
                    content = fileCache["TRAIN_VIDEO0"];
                }
                memcpy(&(_train_video_table->content[0]), &content, sizeof(char*));
                // _train_video_table->content[0] = (char *)memalign(256, outSize);
                // memcpy(_train_video_table->content[0], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                _train_video_table->tupleSize = 0 + 76;
                _train_video_table->tupleNum = header.tupleNum;

                if(blockTotal != 1){
                    mergeIntoTable(train_videoTable,_train_video_table, &pp);
                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    freeTable(_train_video_table);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                }else{
                    train_videoTable = _train_video_table;
                }
                tupleOffset += header.tupleNum;
            }
            train_videoTable->colIdxNum = 0;
            _train_video_table->keepInGpuIdx = 1;
        }

        tr0 = train_videoTable;
        tr0->colIdxNum = 0;
    }

    // Join two tables: te0, tr0
    struct tableNode *te0_tr0;

    {

        struct joinNode jNode;
        jNode.leftTable = te0;
        jNode.rightTable = tr0;
        jNode.totalAttr = 4;
        jNode.keepInGpu = (int *)host_mempool.alloc(sizeof(int) * 4);
        for(int k=0; k<4; k++)
            jNode.keepInGpu[k] = 1;
        jNode.leftOutputAttrNum = 3;
        jNode.rightOutputAttrNum = 1;
        jNode.leftOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.leftOutputIndex = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.leftPos = (int *)host_mempool.alloc(sizeof(int)*3);
        jNode.tupleSize = 0;
        jNode.leftOutputIndex[0] = 0;
        jNode.leftOutputAttrType[0] = INT;
        jNode.leftPos[0] = 0;
        jNode.tupleSize += te0->attrSize[0];
        jNode.leftOutputIndex[1] = 1;
        jNode.leftOutputAttrType[1] = INT;
        jNode.leftPos[1] = 1;
        jNode.tupleSize += te0->attrSize[1];
        jNode.leftOutputIndex[2] = 2;
        jNode.leftOutputAttrType[2] = VECTOR;
        jNode.leftPos[2] = 2;
        jNode.tupleSize += te0->attrSize[2];
        jNode.rightOutputAttrType = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightPos = (int *)host_mempool.alloc(sizeof(int)*1);
        jNode.rightOutputIndex[0] = 0;
        jNode.rightOutputAttrType[0] = VECTOR;
        jNode.rightPos[0] = 3;
        jNode.tupleSize += tr0->attrSize[0];
        jNode.leftKeyIndex = 2;
        jNode.rightKeyIndex = 0;
        struct tableNode *joinRes;
        int dev_memsize = hashJoinGPUMemSize(&jNode, false);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_join = gpu_inner_mp.freepos();
        jNode.nearestk = 10;
        joinRes = knnJoin(&jNode, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, index);
        gpu_inner_mp.freeto(origin_pos_join);

        struct scanNode joinRel;
        joinRel.tn = joinRes;
        joinRel.hasWhere = 0;
        joinRel.whereAttrNum = 0;
        joinRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 0);
        joinRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 4);
        joinRel.outputNum = 4;
        joinRel.outputIndex[0] = 0;
        joinRel.outputIndex[1] = 1;
        joinRel.outputIndex[2] = 2;
        joinRel.outputIndex[3] = 3;
        joinRel.keepInGpu = 1;
        joinRel.project = (struct projectFunction *)host_mempool.alloc(sizeof(struct projectFunction));
        joinRel.projectNum =1;
        (joinRel.project)->projectNum =1;
        (joinRel.project)->exp = (struct projectExp*)host_mempool.alloc(sizeof(struct projectExp) *1);
        (joinRel.project)->exp[0].index    = 2;
        (joinRel.project)->exp[0].secondIndex    = 3;
        (joinRel.project)->exp[0].func     = DISTANCE;
        (joinRel.project)->exp[0].funcType = 2;
        joinRel.projectPart = 1;
        joinRel.projectIndex = (int *)host_mempool.alloc(sizeof(int) * 3);
        joinRel.projectNum = 1;
        joinRel.projectIndex[0] = 0;
        joinRel.projectIndex[1] = 1;
        joinRel.projectIndex[2] = 100;
        dev_memsize = tableScanGPUMemSize(&joinRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        joinRes = tableScan(&joinRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        freeScan(&joinRel, false);

        te0_tr0 = joinRes;
    }

    struct tableNode * gb_te0_tr0;
    {

        struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
        gbNode->table = te0_tr0;
        gbNode->groupByColNum = 2;
        gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 2);
        gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 2);
        gbNode->groupByIndex[0] = 0;
        gbNode->groupByType[0] = gbNode->table->attrType[0];
        gbNode->groupBySize[0] = gbNode->table->attrSize[0];
        gbNode->groupByIndex[1] = 1;
        gbNode->groupByType[1] = gbNode->table->attrType[1];
        gbNode->groupBySize[1] = gbNode->table->attrSize[1];
        gbNode->outputAttrNum = 3;
        gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *3);
        gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *3);
        gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 3);
        gbNode->tupleSize = 0;
        gbNode->attrType[0] = gbNode->table->attrType[0];
        gbNode->attrSize[0] = gbNode->table->attrSize[0];
        gbNode->tupleSize += gbNode->table->attrSize[0];
        gbNode->gbExp[0].func = NOOP;
        gbNode->gbExp[0].exp.op = NOOP;
        gbNode->gbExp[0].exp.exp = 0;
        gbNode->gbExp[0].exp.opNum = 1;
        gbNode->gbExp[0].exp.opType = COLUMN;
        gbNode->gbExp[0].exp.opValue = 0;
        gbNode->tupleSize += sizeof(float);
        gbNode->attrType[1] = FLOAT;
        gbNode->attrSize[1] = sizeof(float);
        gbNode->gbExp[1].func = SUM;
        gbNode->gbExp[1].index = 2;
        gbNode->gbExp[1].exp.op = NOOP;
        gbNode->gbExp[1].exp.opNum = 1;
        gbNode->gbExp[1].exp.exp = 0;
        gbNode->gbExp[1].exp.opType = COLUMN_DECIMAL;
        gbNode->gbExp[1].exp.opValue = 2;
        gbNode->attrType[2] = gbNode->table->attrType[1];
        gbNode->attrSize[2] = gbNode->table->attrSize[1];
        gbNode->tupleSize += gbNode->table->attrSize[1];
        gbNode->gbExp[2].func = NOOP;
        gbNode->gbExp[2].exp.op = NOOP;
        gbNode->gbExp[2].exp.exp = 0;
        gbNode->gbExp[2].exp.opNum = 1;
        gbNode->gbExp[2].exp.opType = COLUMN;
        gbNode->gbExp[2].exp.opValue = 1;
        int dev_memsize = groupByGPUMemSize(gbNode);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_groupby = gpu_inner_mp.freepos();
        gb_te0_tr0 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
        gpu_inner_mp.freeto(origin_pos_groupby);

        freeGroupByNode(gbNode, false);

    }

    

    struct tableNode *sp_gb_te0_tr0;

    {

        struct scanNode selectProjectRel;
        selectProjectRel.tn = gb_te0_tr0;
        // Where conditions: GTH(TEST_OBJECTS.2,SUBQ(0))
        selectProjectRel.hasWhere = 1;
        selectProjectRel.whereAttrNum = 1;
        selectProjectRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        selectProjectRel.whereIndex[0] = 1;
        selectProjectRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (selectProjectRel.filter)->nested = 0;
        (selectProjectRel.filter)->expNum = 1;
        (selectProjectRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (selectProjectRel.filter)->andOr = EXP;
        (selectProjectRel.filter)->exp[0].index    = 0;
        (selectProjectRel.filter)->exp[0].relation = GTH;
        (selectProjectRel.filter)->exp[0].dataPos  = MEM;

        // Process the subquery
        subqRes0 = (char *)malloc(sizeof(float));
        CHECK_POINTER(subqRes0);

        transferTableColumnToGPU(train_videoTable, 0);
        char *free_pos = host_mempool.freepos();
        char *free_gpu_pos = gpu_inter_mp.freepos();
        for(int tupleid = 0; tupleid < 1; tupleid++){
            {
                struct tableNode *result;
                char * subqRes1;

                // Process the TableNode for TRAIN_VIDEO
                struct tableNode *tr1;
                tr1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                {
                    struct tableNode *train_videoTablePartial;
                    train_videoTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    train_videoTablePartial->totalAttr = 1;
                    train_videoTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 1);

                    train_videoTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 1);
                    train_videoTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 1);
                    int tuple_size = 0;
                    train_videoTablePartial->attrSize[0] = train_videoTable->attrSize[0];
                    train_videoTablePartial->attrIndex[0] = train_videoTable->attrIndex[0];
                    train_videoTablePartial->attrType[0] = train_videoTable->attrType[0];
                    train_videoTablePartial->attrName[0] = "train_videoTablePartial0";
                    train_videoTablePartial->dataPos[0] = train_videoTable->dataPos[0];
                    train_videoTablePartial->dataFormat[0] = train_videoTable->dataFormat[0];
                    train_videoTablePartial->attrTotalSize[0] = train_videoTable->attrTotalSize[0];
                    train_videoTablePartial->content[0] = train_videoTable->content[0];
                    tuple_size += train_videoTablePartial->attrSize[0];

                    train_videoTablePartial->tupleSize = tuple_size;
                    train_videoTablePartial->tupleNum = train_videoTable->tupleNum;

                    train_videoTablePartial->colIdxNum = 0;
                    train_videoTablePartial->keepInGpuIdx = 1;
                    // Load columns from the table TRAIN_VIDEO
                    struct tableNode *train_videoTable;
                    train_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    {
                        struct tableNode *_train_video_table;
                        int outFd;
                        long outSize;
                        char *outTable;
                        long offset, tupleOffset;
                        int blockTotal;
                        char *content;
                        struct columnHeader header;

                        // Retrieve the block number from TRAIN_VIDEO0
                        outFd = open("TRAIN_VIDEO0", O_RDONLY);
                        read(outFd, &header, sizeof(struct columnHeader));
                        blockTotal = header.blockTotal;
                        close(outFd);
                        offset = 0;
                        tupleOffset = 0;
                        for(int i = 0; i < blockTotal; i++){

                            // Table initialization
                            _train_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                            _train_video_table->totalAttr = 1;
                            _train_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 1);

                            _train_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 1);
                            _train_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 1);

                            // Load column 0, type: VECTOR
                            _train_video_table->attrSize[0] = 76;
                            _train_video_table->attrIndex[0] = 0;
                            _train_video_table->attrType[0] = VECTOR;
                            _train_video_table->attrName[0] = "TRAIN_VIDEO0";
                            _train_video_table->dataPos[0] = GPU;
                            outFd = open("TRAIN_VIDEO0", O_RDONLY);
                            offset = i * sizeof(struct columnHeader) + tupleOffset * 76;
                            lseek(outFd, offset, SEEK_SET);
                            read(outFd, &header, sizeof(struct columnHeader));
                            offset += sizeof(struct columnHeader);
                            _train_video_table->dataFormat[0] = header.format;
                            outSize = header.tupleNum * 76;
                            _train_video_table->attrTotalSize[0] = outSize;

                            clock_gettime(CLOCK_REALTIME,&diskStart);
                            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                            if (fileCache.find("TRAIN_VIDEO0_") != fileCache.end()) {
                                content = fileCache["TRAIN_VIDEO0_"];
                            }
                            memcpy(&(_train_video_table->content[0]), &content, sizeof(char*));
                            // _train_video_table->content[0] = (char *)memalign(256, outSize);
                            // memcpy(_train_video_table->content[0], outTable, outSize);
                            // munmap(outTable, outSize);
                            clock_gettime(CLOCK_REALTIME, &diskEnd);
                            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                            close(outFd);

                            _train_video_table->tupleSize = 0 + 76;
                            _train_video_table->tupleNum = header.tupleNum;

                            if(blockTotal != 1){
                                mergeIntoTable(train_videoTable,_train_video_table, &pp);
                                clock_gettime(CLOCK_REALTIME, &diskStart);
                                freeTable(_train_video_table);
                                clock_gettime(CLOCK_REALTIME, &diskEnd);
                                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                            }else{
                                train_videoTable = _train_video_table;
                            }
                            tupleOffset += header.tupleNum;
                        }
                        train_videoTable->colIdxNum = 0;
                        _train_video_table->keepInGpuIdx = 1;
                    }

                    tr1 = train_videoTable;
                    tr1->colIdxNum = 0;
                }


                struct tableNode * gb_tr1;
                {

                    struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
                    gbNode->table = tr1;
                    gbNode->groupByColNum = 1;
                    gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
                    gbNode->groupByIndex[0] = -1;
                    gbNode->groupByType[0] = INT;
                    gbNode->groupBySize[0] = sizeof(int);
                    gbNode->outputAttrNum = 1;
                    gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *1);
                    gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *1);
                    gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 1);
                    gbNode->tupleSize = 0;
                    gbNode->tupleSize += sizeof(float);
                    gbNode->attrType[0] = FLOAT;
                    gbNode->attrSize[0] = sizeof(float);
                    gbNode->gbExp[0].func = OUTLIER_LINE;
                    gbNode->gbExp[0].index = 0;
                    int dev_memsize = groupByGPUMemSize(gbNode);
                    if(gpu_inner_mp.freesize() < dev_memsize)
                        gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
                    char *origin_pos_groupby = gpu_inner_mp.freepos();
                    gb_tr1 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
                    gpu_inner_mp.freeto(origin_pos_groupby);

                    freeGroupByNode(gbNode, false);

                }

                result = gb_tr1;
                struct materializeNode mn;
                mn.table = result;
                char *final = materializeCol(&mn, &pp);
                
                mempcpy(subqRes0 + tupleid * sizeof(float), final, sizeof(float));
                host_mempool.freeto(free_pos);
                gpu_inter_mp.freeto(free_gpu_pos);
                pp.outerTableSize = sizeof(float);
                pp.resultTableSize = mn.table->tupleNum;
            }
        }

        memcpy((selectProjectRel.filter)->exp[0].content, subqRes0, sizeof(void *));
        selectProjectRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        selectProjectRel.outputNum = 2;
        selectProjectRel.outputIndex[0] = 0;
        selectProjectRel.outputIndex[1] = 1;
        selectProjectRel.keepInGpu = 1;
        int dev_memsize = tableScanGPUMemSize(&selectProjectRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        sp_gb_te0_tr0 = tableScan(&selectProjectRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        freeScan(&selectProjectRel, false);

        sp_gb_te0_tr0->colIdxNum = 0;
    }

    struct tableNode * gb_sp_gb_te0_tr0;
    {

        struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
        gbNode->table = sp_gb_te0_tr0;
        gbNode->groupByColNum = 1;
        gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByIndex[0] = 0;
        gbNode->groupByType[0] = gbNode->table->attrType[0];
        gbNode->groupBySize[0] = gbNode->table->attrSize[0];
        gbNode->outputAttrNum = 2;
        gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 2);
        gbNode->tupleSize = 0;
        gbNode->attrType[0] = gbNode->table->attrType[0];
        gbNode->attrSize[0] = gbNode->table->attrSize[0];
        gbNode->tupleSize += gbNode->table->attrSize[0];
        gbNode->gbExp[0].func = NOOP;
        gbNode->gbExp[0].exp.op = NOOP;
        gbNode->gbExp[0].exp.exp = 0;
        gbNode->gbExp[0].exp.opNum = 1;
        gbNode->gbExp[0].exp.opType = COLUMN;
        gbNode->gbExp[0].exp.opValue = 0;
        gbNode->tupleSize += sizeof(float);
        gbNode->attrType[1] = FLOAT;
        gbNode->attrSize[1] = sizeof(float);
        gbNode->gbExp[1].func = OUTLIER_SCORE;
        gbNode->gbExp[1].index = 1;
        int dev_memsize = groupByGPUMemSize(gbNode);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_groupby = gpu_inner_mp.freepos();
        gb_sp_gb_te0_tr0 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
        gpu_inner_mp.freeto(origin_pos_groupby);

        freeGroupByNode(gbNode, false);

    }

    result = gb_sp_gb_te0_tr0;
    struct materializeNode mn;
    mn.table = result;
    char *final = materializeCol(&mn, &pp);

    clock_gettime(CLOCK_REALTIME,&exe_e);
    execution_time = (exe_e.tv_sec -  exe_s.tv_sec)* BILLION + exe_e.tv_nsec - exe_s.tv_nsec;
    printf("[execution time] %lf\n", execution_time/(1000*1000));

    FILE *file = fopen("../../benchmark/outlier_pred.txt", "w");
    if (!file) {
        perror("Error opening file");
        return 1;
    }
    for (int i = 0; i < result->tupleNum; ++i) {
        int32_t int_part;
        float float_part;
        memcpy(&int_part, &final[i * 8], sizeof(int32_t));
        memcpy(&float_part, &final[i * 8 + 4], sizeof(float));

        fprintf(file, "%d %f\n", int_part, float_part);  // intfloat
    }

    clock_gettime(CLOCK_REALTIME, &end);
    double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
    printf("<--Disk Load Time-->           : %lf\n", diskTotal/(1000*1000));
    printf("\n");
    printf("<--Build index time-->         : %lf\n", pp.buildIndexTotal/(1000*1000));

    printf("\n");
    printf("<--ANNs total time-->          : %lf\n", pp.annsTotalTime/(1000*1000));

    printf("Load anns index                : %lf\n", pp.loadIndex/(1000*1000));

    printf("Load index from CPU to GPU     : %lf\n", pp.indexCPU2GPU/(1000*1000));

    printf("Train anns index               : %lf\n", pp.trainIndex/(1000*1000));

    printf("Save anns index                : %lf\n", pp.saveIndex/(1000*1000));

    printf("Add data to anns index         : %lf\n", pp.indexAddData/(1000*1000));

    printf("Search anns index              : %lf\n", pp.indexSearch/(1000*1000));

    printf("<---SUB()--->\n");
    printf("Outer table size           : %d\n", pp.outerTableSize);

    printf("Sub Cache hits             : %d\n", pp.subCacheHits);

    printf("Result table size          : %d\n", pp.resultTableSize);

    printf("<----------------->");
    printf("\n");
    printf("<---TableScan()--->\n");
    printf("Total time      : %lf\n", pp.tableScanTotal/(1000*1000));
    printf("Calls           : %d\n", pp.tableScanCount);

    printf("Step 1 - memCopy where clause                 : %lf\n", pp.whereMemCopy_s1/(1000*1000));
    printf("Step 2 - memCopy predicate col                : %lf\n", pp.dataMemCopy_s2/(1000*1000));
    printf("Step 3 - Scan                                 : %lf\n", pp.scanTotal_s3/(1000*1000));
    printf("Idx Step 3.1 - Get index position             : %lf\n", pp.getIndexPos_idxS1/(1000*1000));
    printf("Idx Step 3.2 - Get range                      : %lf\n", pp.getRange_idxS2/(1000*1000));
    printf("Idx Step 3.3 - Convert addrs to elements      : %lf\n", pp.convertMemToElement_idxS3/(1000*1000));
    printf("Idx Step 3.4 - Get mapping position           : %lf\n", pp.getMapping_idxS4/(1000*1000));
    printf("Idx Step 3.5 - Set bitmap to zero             : %lf\n", pp.setBitmapZeros_idxS5/(1000*1000));
    printf("Idx Step 3.6 - Build bitmap                   : %lf\n", pp.buildBitmap_idxS6/(1000*1000));
    printf("Step 4 - CountRes(PreScan)                    : %lf\n", pp.preScanTotal_s4/(1000*1000));
    printf("PreScan Step 4.1 - Count selected rows kernel : %lf\n", pp.countScanKernel_countS1/(1000*1000));
    printf("PreScan Step 4.2 - scanImpl time              : %lf\n", pp.scanImpl_countS2/(1000*1000));
    printf("scanImpl Step 4.2.1 - preallocBlockSums time  : %lf\n", pp.preallocBlockSums_scanImpl_S1/(1000*1000));
    printf("scanImpl Step 4.2.2 - prescanArray time       : %lf\n", pp.prescanArray_scanImpl_S2/(1000*1000));
    printf("scanImpl Step 4.2.3 - deallocBlockSums time   : %lf\n", pp.deallocBlockSums_scanImpl_S3/(1000*1000));
    printf("prescan Step 4.2.3.1 - set variables time     : %lf\n", pp.setVar_prescan_S1/(1000*1000));
    printf("prescan Step 4.2.3.2 - prescan Kernel time    : %lf\n", pp.preScanKernel_prescan_S2/(1000*1000));
    printf("prescan Step 4.2.3.3 - uniformAdd Kernel time : %lf\n", pp.uniformAddKernel_prescan_S3/(1000*1000));
    printf("Step 5 - memReturn countRes                   : %lf\n", pp.preScanResultMemCopy_s5/(1000*1000));
    printf("Step 6 - Copy rest of columns                 : %lf\n", pp.dataMemCopyOther_s6/(1000*1000));
    printf("Step 7 - Materialize result                   : %lf\n", pp.materializeResult_s7/(1000*1000));
    printf("Step 8 - Copy final result                    : %lf\n", pp.finalResultMemCopy_s8/(1000*1000));
    printf("Other 1 - Create tableNode                    : %lf\n", pp.create_tableNode_S01/(1000*1000));
    printf("Other 2 - Malloc res                          : %lf\n", pp.mallocRes_S02/(1000*1000));
    printf("Other 3 - Deallocate buffers                  : %lf\n", pp.deallocateBuffs_S03/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("<---Join--->\n");
    printf("Calls                     : %d\n", pp.join_callTimes);

    printf("<---knnJoin()--->\n");
    printf("Total time                : %lf\n", pp.knnJoin_totalTime/(1000*1000));
    printf("Total ANNs time           : %lf\n", pp.knn_ANNs_time/(1000*1000));
    printf("<---cartesianJoin()--->\n");
    printf("Total time                : %lf\n", pp.cartesianJoin_totalTime/(1000*1000));
    printf("<---HashJoin()--->\n");
    printf("Total time                : %lf\n", pp.join_totalTime/(1000*1000));
    printf("Left table Size           : %d\n", pp.join_leftTableSize);

    printf("Right table Size          : %d\n", pp.join_rightTableSize);

    printf("Step 1 - Allocate memory for intermediate results : %lf\n", pp.joinProf_step1_allocateMem/(1000*1000));
    printf("Step 2 - Build hashTable                          : %lf\n", pp.joinProf_step2_buildHash/(1000*1000));
    printf("Step 2.1 - Allocate memory                        : %lf\n", pp.joinProf_step21_allocateMem/(1000*1000));
    printf("Step 2.2 - Count_hash_num                         : %lf\n", pp.joinProf_step22_Count_hash_num/(1000*1000));
    printf("Step 2.3 - scanImpl                               : %lf\n", pp.joinProf_step23_scanImpl/(1000*1000));
    printf("Step 2.4 - build_hash_table (+ memCopy op)        : %lf\n", pp.joinProf_step24_buildhash_kernel_memcopy/(1000*1000));
    printf("Step 3 - Join                                     : %lf\n", pp.joinProf_step3_join/(1000*1000));
    printf("Step 3.1 - Allocate memory                        : %lf\n", pp.joinProf_step31_allocateMem/(1000*1000));
    printf("Step 3.2 - Exclusive scan                         : %lf\n", pp.joinProf_step32_exclusiveScan/(1000*1000));
    printf("Step 3.3 - Prob and memcpy ops                    : %lf\n", pp.joinProf_step33_prob/(1000*1000));
    printf("Step 4 - Materialize result                       : %lf\n", pp.joinProf_step4_materialize_res/(1000*1000));
    printf("Step 4.1 - Materialize left part (joinFact)       : %lf\n", pp.joinProf_step41_materialize_res_left/(1000*1000));
    printf("Step 4.2 - Materialize right part (joinDim)       : %lf\n", pp.joinProf_step42_materialize_res_right/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("<---GroupBy()--->\n");
    printf("Total time      : %lf\n", pp.groupby_totalTime/(1000*1000));
    printf("Calls           : %d\n", pp.groupby_callTimes);

    printf("Step 1 - Allocate memory for intermediate results : %lf\n", pp.groupby_step1_allocMem/(1000*1000));
    printf("Step 2 - Copy data to GPU                         : %lf\n", pp.groupby_step2_copyToDevice/(1000*1000));
    printf("Step 3 - Build Group By Key                       : %lf\n", pp.groupby_step3_buildGroupByKey/(1000*1000));
    printf("Step 4 - Count number of groups                   : %lf\n", pp.groupby_step4_groupCount/(1000*1000));
    printf("Step 5 - Allocate memory for result               : %lf\n", pp.groupby_step5_AllocRes/(1000*1000));
    printf("Step 6 - Copy columns to device                   : %lf\n", pp.groupby_step6_copyDataCols/(1000*1000));
    printf("Step 7 - Calculate aggregate values               : %lf\n", pp.groupby_step7_computeAgg/(1000*1000));
    printf("Step 8 - De-allocate memory                       : %lf\n", pp.groupby_step8_deallocate/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("Total Time: %lf\n", timeE/(1000*1000));
}


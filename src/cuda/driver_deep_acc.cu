/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include <unordered_map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
#include <faiss/gpu/GpuAutoTune.h>
#include <faiss/gpu/GpuCloner.h>
#include <faiss/gpu/GpuIndexIVFPQ.h>
#include <faiss/gpu/StandardGpuResources.h>
#include <faiss/index_io.h>
#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFPQ.h>
#include <numeric>
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *, faiss::Index*);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern struct tableNode* knnJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *, faiss::Index*);
extern struct tableNode* cartesianProductJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
int searchFrameNum = 0;

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    double timeElapsed;
    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;

    std::unordered_map<std::string, char*> fileCache;
    struct tableNode *_deep_table;
    {
        // struct tableNode *_deep_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from DEEP0
        outFd = open("DEEP0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _deep_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            _deep_table->totalAttr = 2;
            _deep_table->attrType = (int *)malloc(sizeof(int) * 2);
            _deep_table->attrSize = (int *)malloc(sizeof(int) * 2);
            _deep_table->attrName = (char **)malloc(sizeof(char *) * 2);

            _deep_table->attrIndex = (int *)malloc(sizeof(int) * 2);
            _deep_table->attrTotalSize = (int *)malloc(sizeof(int) * 2);
            _deep_table->dataPos = (int *)malloc(sizeof(int) * 2);
            _deep_table->dataFormat = (int *)malloc(sizeof(int) * 2);
            _deep_table->content = (char **)malloc(sizeof(char *) * 2);

            // Load column 0, type: INTEGER
            _deep_table->attrSize[0] = sizeof(int);
            _deep_table->attrIndex[0] = 0;
            _deep_table->attrType[0] = INT;
            _deep_table->attrName[0] = "DEEP0";
            _deep_table->dataPos[0] = GPU;
            outFd = open("DEEP0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _deep_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _deep_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_deep_table->content[0]), outSize);
                cudaMemcpy(_deep_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DEEP0"] = _deep_table->content[0];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            //diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: VECTOR
            _deep_table->attrSize[1] = 384;
            _deep_table->attrIndex[1] = 1;
            _deep_table->attrType[1] = VECTOR;
            _deep_table->attrName[1] = "DEEP1";
            _deep_table->dataPos[1] = GPU;
            outFd = open("DEEP1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 384;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _deep_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 384;
            _deep_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_deep_table->content[1]), outSize);
                cudaMemcpy(_deep_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DEEP1"] = _deep_table->content[1];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            // diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _deep_table->tupleSize = 0 + sizeof(int) + 384;
            _deep_table->tupleNum = header.tupleNum;
        }
    }
    char *index_path = "/home/szr/subquery/vector_src/init_vector/DEEP0_index.faissindex";
    faiss::Index *index = faiss::read_index(index_path);
    faiss::gpu::StandardGpuResources resources;
    int dev_no = 0;
    index = faiss::gpu::index_cpu_to_gpu(&resources, dev_no, index);

    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = pp.subCacheHits = 0;

    pp.annsTotalTime = 0;
    pp.loadIndex = 0;
    pp.indexCPU2GPU = 0;
    pp.trainIndex = 0;
    pp.saveIndex = 0;
    pp.indexAddData = 0;
    pp.indexSearch = 0;
    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.knnJoin_totalTime = 0;
    pp.knn_ANNs_time = 0;
    pp.cartesianJoin_totalTime = 0;
    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_materialize_res = 0;
    pp.joinProf_step41_materialize_res_left = 0;
    pp.joinProf_step42_materialize_res_right = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);


    std::vector<double> times;
    for(int i = 0; i < 100; i++){

        std::string command = "python3 init_deep_search_vector.py " + std::to_string(i);
        int res = std::system(command.c_str());

        clock_gettime(CLOCK_REALTIME,&start);

        
        struct tableNode *deepTable;
            deepTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            {
                struct tableNode *_deep_table;
                int outFd;
                long outSize;
                char *outTable;
                long offset, tupleOffset;
                int blockTotal;
                struct columnHeader header;

                // Retrieve the block number from DEEP0
                outFd = open("DEEP0", O_RDONLY);
                read(outFd, &header, sizeof(struct columnHeader));
                blockTotal = header.blockTotal;
                close(outFd);
                offset = 0;
                tupleOffset = 0;
                char* content;
                for(int i = 0; i < blockTotal; i++){
                    
                    // Table initialization
                    _deep_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    _deep_table->totalAttr = 2;
                    _deep_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    _deep_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    // Load column 0, type: INTEGER
                    _deep_table->attrSize[0] = sizeof(int);
                    _deep_table->attrIndex[0] = 0;
                    _deep_table->attrType[0] = INT;
                    _deep_table->attrName[0] = "DEEP0";
                    _deep_table->dataPos[0] = GPU;
                    outFd = open("DEEP0", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _deep_table->dataFormat[0] = header.format;
                    outSize = header.tupleNum * sizeof(int);
                    _deep_table->attrTotalSize[0] = outSize;

                    clock_gettime(CLOCK_REALTIME,&diskStart);
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    
                    if (fileCache.find("DEEP0") != fileCache.end()) {
                        content = fileCache["DEEP0"];
                    }
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    // Load column 1, type: VECTOR
                    _deep_table->attrSize[1] = 384;
                    _deep_table->attrIndex[1] = 1;
                    _deep_table->attrType[1] = VECTOR;
                    _deep_table->attrName[1] = "DEEP1";
                    _deep_table->dataPos[1] = GPU;
                    outFd = open("DEEP1", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * 384;
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _deep_table->dataFormat[1] = header.format;
                    outSize = header.tupleNum * 384;
                    _deep_table->attrTotalSize[1] = outSize;

                    clock_gettime(CLOCK_REALTIME,&diskStart);
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    
                    if (fileCache.find("DEEP1") != fileCache.end()) {
                        content = fileCache["DEEP1"];
                    }
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    _deep_table->tupleSize = 0 + sizeof(int) + 384;
                    _deep_table->tupleNum = header.tupleNum;

                    if(blockTotal != 1){
                        mergeIntoTable(deepTable,_deep_table, &pp);
                        clock_gettime(CLOCK_REALTIME, &diskStart);
                        freeTable(_deep_table);
                        clock_gettime(CLOCK_REALTIME, &diskEnd);
                        diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    }else{
                        deepTable = _deep_table;
                    }
                    tupleOffset += header.tupleNum;
                }
                deepTable->colIdxNum = 0;
                _deep_table->keepInGpuIdx = 1;
            }



        struct tableNode *result;
        char * subqRes0;

        // Process the TableNode for DEEP
        struct tableNode *de0;
        de0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *deepTablePartial;
            deepTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            deepTablePartial->totalAttr = 2;
            deepTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

            deepTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
            int tuple_size = 0;
            deepTablePartial->attrSize[0] = deepTable->attrSize[0];
            deepTablePartial->attrIndex[0] = deepTable->attrIndex[0];
            deepTablePartial->attrType[0] = deepTable->attrType[0];
            deepTablePartial->attrName[0] = "deepTablePartial0";
            deepTablePartial->dataPos[0] = deepTable->dataPos[0];
            deepTablePartial->dataFormat[0] = deepTable->dataFormat[0];
            deepTablePartial->attrTotalSize[0] = deepTable->attrTotalSize[0];
            deepTablePartial->content[0] = deepTable->content[0];
            tuple_size += deepTablePartial->attrSize[0];

            deepTablePartial->attrSize[1] = deepTable->attrSize[1];
            deepTablePartial->attrIndex[1] = deepTable->attrIndex[1];
            deepTablePartial->attrType[1] = deepTable->attrType[1];
            deepTablePartial->attrName[1] = "deepTablePartial1";
            deepTablePartial->dataPos[1] = deepTable->dataPos[1];
            deepTablePartial->dataFormat[1] = deepTable->dataFormat[1];
            deepTablePartial->attrTotalSize[1] = deepTable->attrTotalSize[1];
            deepTablePartial->content[1] = deepTable->content[1];
            tuple_size += deepTablePartial->attrSize[1];

            deepTablePartial->tupleSize = tuple_size;
            deepTablePartial->tupleNum = deepTable->tupleNum;

            deepTablePartial->colIdxNum = 0;
            deepTablePartial->keepInGpuIdx = 1;
            // Load columns from the table DEEP
            struct tableNode *deepTable;
            deepTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            {
                struct tableNode *_deep_table;
                int outFd;
                long outSize;
                char *outTable;
                long offset, tupleOffset;
                int blockTotal;
                char* content;
                struct columnHeader header;

                // Retrieve the block number from DEEP0
                outFd = open("DEEP0", O_RDONLY);
                read(outFd, &header, sizeof(struct columnHeader));
                blockTotal = header.blockTotal;
                close(outFd);
                offset = 0;
                tupleOffset = 0;
                for(int i = 0; i < blockTotal; i++){
                    struct timespec start, end;
                    // Table initialization
                    _deep_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    _deep_table->totalAttr = 2;
                    _deep_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    _deep_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _deep_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    // Load column 0, type: INTEGER
                    _deep_table->attrSize[0] = sizeof(int);
                    _deep_table->attrIndex[0] = 0;
                    _deep_table->attrType[0] = INT;
                    _deep_table->attrName[0] = "DEEP0";
                    _deep_table->dataPos[0] = GPU;
                    outFd = open("DEEP0", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _deep_table->dataFormat[0] = header.format;
                    outSize = header.tupleNum * sizeof(int);
                    _deep_table->attrTotalSize[0] = outSize;

                    clock_gettime(CLOCK_REALTIME,&diskStart);
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    if (fileCache.find("DEEP0") != fileCache.end()) {
                        content = fileCache["DEEP0"];
                    }
                    memcpy(&(_deep_table->content[0]), &content, sizeof(char*));
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    // Load column 1, type: VECTOR
                    _deep_table->attrSize[1] = 384;
                    _deep_table->attrIndex[1] = 1;
                    _deep_table->attrType[1] = VECTOR;
                    _deep_table->attrName[1] = "DEEP1";
                    _deep_table->dataPos[1] = GPU;
                    outFd = open("DEEP1", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * 384;
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _deep_table->dataFormat[1] = header.format;
                    outSize = header.tupleNum * 384;
                    _deep_table->attrTotalSize[1] = outSize;

                    clock_gettime(CLOCK_REALTIME,&diskStart);
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    if (fileCache.find("DEEP1") != fileCache.end()) {
                        content = fileCache["DEEP1"];
                    }
                    memcpy(&(_deep_table->content[1]), &content, sizeof(char*));
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    _deep_table->tupleSize = 0 + sizeof(int) + 384;
                    _deep_table->tupleNum = header.tupleNum;

                    if(blockTotal != 1){
                        mergeIntoTable(deepTable,_deep_table, &pp);
                        clock_gettime(CLOCK_REALTIME, &diskStart);
                        freeTable(_deep_table);
                        clock_gettime(CLOCK_REALTIME, &diskEnd);
                        diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    }else{
                        deepTable = _deep_table;
                    }
                    tupleOffset += header.tupleNum;
                }
                deepTable->colIdxNum = 0;
                _deep_table->keepInGpuIdx = 1;
            }

            struct scanNode deepRel;
            deepRel.project = (struct projectFunction *)host_mempool.alloc(sizeof(struct projectFunction));
            deepRel.projectNum = 1;
            (deepRel.project)->exp = (struct projectExp*)host_mempool.alloc(sizeof(struct projectExp) *1);
            (deepRel.project)->exp[0].index    = 1;
            (deepRel.project)->exp[0].func     = DISTANCE;
            (deepRel.project)->exp[0].funcType = 1;
            strcpy((deepRel.project)->exp[0].vecPath, "/home/szr/subquery/benchmark/deepsearchvec");
            (deepRel.project)->exp[0].limit     = 100;
            deepRel.hasWhere = 0;
            deepRel.tn = deepTable;
            deepRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            deepRel.outputNum = 2;
            deepRel.outputIndex[0] = 0;
            deepRel.outputIndex[1] = 1;
            deepRel.keepInGpu = 1;
            int dev_memsize = tableScanGPUMemSize(&deepRel);
            if(gpu_inner_mp.freesize() < dev_memsize)
                gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
            char *origin_pos = gpu_inner_mp.freepos();
            de0 = tableScan(&deepRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL, index);
            gpu_inner_mp.freeto(origin_pos);

            clock_gettime(CLOCK_REALTIME, &diskStart);
            deepTable->content[0] = NULL;
            deepTable->content[1] = NULL;
            freeScan(&deepRel, false);

            de0->colIdxNum = 0;
        }

        struct tableNode * ob_de0;
        {

            struct orderByNode * odNode = (struct orderByNode *)host_mempool.alloc(sizeof(struct orderByNode));
            odNode->table = de0;
            odNode->orderByNum = 1;
            odNode->orderBySeq = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
            odNode->orderByIndex = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
            odNode->orderBySeq[0] = ASC;
            odNode->orderByIndex[0] = 1;
            ob_de0 = orderBy(odNode, &pp);
            freeOrderByNode(odNode, false);

        }

        result = ob_de0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);

        clock_gettime(CLOCK_REALTIME, &end);
        double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
        times.push_back(timeE);

        FILE *file = fopen("../../benchmark/output.txt", "w");
        for(int j = 0; j < 100; j++){
            fprintf(file, "%d\n", ((int*)final)[2*j] - 1);
        }
        fclose(file);

        command = "python3 deep_acc.py " + std::to_string(i);
        res = std::system(command.c_str());

    }
    double sum = std::accumulate(times.begin(), times.end(), 0.0);

    double average = sum / times.size();

    printf("avg time: %lf\n\n", average/(1000*1000));

    std::string command = "python3 deep_avg_acc.py";
    int res = std::system(command.c_str());
}




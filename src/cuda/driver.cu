/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include <unordered_map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
#include <faiss/gpu/GpuAutoTune.h>
#include <faiss/gpu/GpuCloner.h>
#include <faiss/gpu/GpuIndexIVFPQ.h>
#include <faiss/gpu/StandardGpuResources.h>
#include <faiss/index_io.h>
#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFPQ.h>
#include <numeric>
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *, faiss::Index*);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern struct tableNode* knnJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *, faiss::Index*);
extern struct tableNode* cartesianProductJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
int searchFrameNum = 0;

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    double timeElapsed;
    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;

    std::unordered_map<std::string, char*> fileCache;
    struct tableNode *_sift_table;
    {
        // struct tableNode *_sift_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from SIFT0
        outFd = open("SIFT0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _sift_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            _sift_table->totalAttr = 2;
            _sift_table->attrType = (int *)malloc(sizeof(int) * 2);
            _sift_table->attrSize = (int *)malloc(sizeof(int) * 2);
            _sift_table->attrName = (char **)malloc(sizeof(char *) * 2);

            _sift_table->attrIndex = (int *)malloc(sizeof(int) * 2);
            _sift_table->attrTotalSize = (int *)malloc(sizeof(int) * 2);
            _sift_table->dataPos = (int *)malloc(sizeof(int) * 2);
            _sift_table->dataFormat = (int *)malloc(sizeof(int) * 2);
            _sift_table->content = (char **)malloc(sizeof(char *) * 2);

            // Load column 0, type: INTEGER
            _sift_table->attrSize[0] = sizeof(int);
            _sift_table->attrIndex[0] = 0;
            _sift_table->attrType[0] = INT;
            _sift_table->attrName[0] = "SIFT0";
            _sift_table->dataPos[0] = GPU;
            outFd = open("SIFT0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _sift_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * sizeof(int);
            _sift_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_sift_table->content[0]), outSize);
                cudaMemcpy(_sift_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                fileCache["SIFT0"] = _sift_table->content[0];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            // diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 1, type: VECTOR
            _sift_table->attrSize[1] = 512;
            _sift_table->attrIndex[1] = 1;
            _sift_table->attrType[1] = VECTOR;
            _sift_table->attrName[1] = "SIFT1";
            _sift_table->dataPos[1] = GPU;
            outFd = open("SIFT1", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _sift_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 512;
            _sift_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_sift_table->content[1]), outSize);
                cudaMemcpy(_sift_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                fileCache["SIFT1"] = _sift_table->content[1];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            // diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _sift_table->tupleSize = 0 + sizeof(int) + 512;
            _sift_table->tupleNum = header.tupleNum;
        }
    }

    char *index_path = "/home/szr/subquery/vector_src/init_vector/SIFT0_index.faissindex";
    faiss::Index *index = faiss::read_index(index_path);
    faiss::gpu::StandardGpuResources resources;
    int dev_no = 0;
    index = faiss::gpu::index_cpu_to_gpu(&resources, dev_no, index);

    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = pp.subCacheHits = 0;

    pp.annsTotalTime = 0;
    pp.loadIndex = 0;
    pp.indexCPU2GPU = 0;
    pp.trainIndex = 0;
    pp.saveIndex = 0;
    pp.indexAddData = 0;
    pp.indexSearch = 0;
    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.knnJoin_totalTime = 0;
    pp.knn_ANNs_time = 0;
    pp.cartesianJoin_totalTime = 0;
    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_materialize_res = 0;
    pp.joinProf_step41_materialize_res_left = 0;
    pp.joinProf_step42_materialize_res_right = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);


    std::vector<double> times;
    for(int i = 0; i < 100; i++){

        std::string command = "python3 init_sift_search_vector.py " + std::to_string(i);
        int res = std::system(command.c_str());

        clock_gettime(CLOCK_REALTIME,&start);

        // Load columns from the table SIFT
        struct tableNode *siftTable;
        siftTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *_sift_table;
            int outFd;
            long outSize;
            char *outTable;
            long offset, tupleOffset;
            int blockTotal;
            struct columnHeader header;

            // Retrieve the block number from SIFT0
            outFd = open("SIFT0", O_RDONLY);
            read(outFd, &header, sizeof(struct columnHeader));
            blockTotal = header.blockTotal;
            close(outFd);
            offset = 0;
            tupleOffset = 0;
            char* content;
            for(int i = 0; i < blockTotal; i++){

                // Table initialization
                _sift_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                _sift_table->totalAttr = 2;
                _sift_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                _sift_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                _sift_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                // Load column 0, type: INTEGER
                _sift_table->attrSize[0] = sizeof(int);
                _sift_table->attrIndex[0] = 0;
                _sift_table->attrType[0] = INT;
                _sift_table->attrName[0] = "SIFT0";
                _sift_table->dataPos[0] = GPU;
                outFd = open("SIFT0", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _sift_table->dataFormat[0] = header.format;
                outSize = header.tupleNum * sizeof(int);
                _sift_table->attrTotalSize[0] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                
                if (fileCache.find("SIFT0") != fileCache.end()) {
                    content = fileCache["SIFT0"];
                }
                // cudaMalloc((void**)&(_sift_table->content[0]), outSize);
                // cudaMemcpy(_sift_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                // Load column 1, type: VECTOR
                _sift_table->attrSize[1] = 512;
                _sift_table->attrIndex[1] = 1;
                _sift_table->attrType[1] = VECTOR;
                _sift_table->attrName[1] = "SIFT1";
                _sift_table->dataPos[1] = GPU;
                outFd = open("SIFT1", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _sift_table->dataFormat[1] = header.format;
                outSize = header.tupleNum * 512;
                _sift_table->attrTotalSize[1] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                
                if (fileCache.find("SIFT1") != fileCache.end()) {
                    content = fileCache["SIFT1"];
                }
                // cudaMalloc((void**)&(_sift_table->content[1]), outSize);
                // cudaMemcpy(_sift_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                _sift_table->tupleSize = 0 + sizeof(int) + 512;
                _sift_table->tupleNum = header.tupleNum;

                if(blockTotal != 1){
                    mergeIntoTable(siftTable,_sift_table, &pp);
                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    freeTable(_sift_table);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                }else{
                    siftTable = _sift_table;
                }
                tupleOffset += header.tupleNum;
            }
            siftTable->colIdxNum = 0;
            _sift_table->keepInGpuIdx = 1;
        }



        struct tableNode *result;
        char * subqRes0;

        struct timespec ts, te;
        double tt;
        CUDA_SAFE_CALL(cudaDeviceSynchronize()); //need to wait to ensure correct timing
        clock_gettime(CLOCK_REALTIME,&ts);

        // Process the TableNode for SIFT
        struct tableNode *si0;
        si0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *siftTablePartial;
            siftTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            siftTablePartial->totalAttr = 2;
            siftTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

            siftTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
            int tuple_size = 0;
            siftTablePartial->attrSize[0] = siftTable->attrSize[0];
            siftTablePartial->attrIndex[0] = siftTable->attrIndex[0];
            siftTablePartial->attrType[0] = siftTable->attrType[0];
            siftTablePartial->attrName[0] = "siftTablePartial0";
            siftTablePartial->dataPos[0] = siftTable->dataPos[0];
            siftTablePartial->dataFormat[0] = siftTable->dataFormat[0];
            siftTablePartial->attrTotalSize[0] = siftTable->attrTotalSize[0];
            siftTablePartial->content[0] = siftTable->content[0];
            tuple_size += siftTablePartial->attrSize[0];

            siftTablePartial->attrSize[1] = siftTable->attrSize[1];
            siftTablePartial->attrIndex[1] = siftTable->attrIndex[1];
            siftTablePartial->attrType[1] = siftTable->attrType[1];
            siftTablePartial->attrName[1] = "siftTablePartial1";
            siftTablePartial->dataPos[1] = siftTable->dataPos[1];
            siftTablePartial->dataFormat[1] = siftTable->dataFormat[1];
            siftTablePartial->attrTotalSize[1] = siftTable->attrTotalSize[1];
            siftTablePartial->content[1] = siftTable->content[1];
            tuple_size += siftTablePartial->attrSize[1];

            siftTablePartial->tupleSize = tuple_size;
            siftTablePartial->tupleNum = siftTable->tupleNum;

            siftTablePartial->colIdxNum = 0;
            siftTablePartial->keepInGpuIdx = 1;
            // Load columns from the table SIFT
            struct tableNode *siftTable;
            siftTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            {
                struct tableNode *_sift_table;
                int outFd;
                long outSize;
                char *outTable;
                long offset, tupleOffset;
                int blockTotal;
                char* content;
                struct columnHeader header;

                // Retrieve the block number from SIFT0
                outFd = open("SIFT0", O_RDONLY);
                read(outFd, &header, sizeof(struct columnHeader));
                blockTotal = header.blockTotal;
                close(outFd);
                offset = 0;
                tupleOffset = 0;
                for(int i = 0; i < blockTotal; i++){
                    struct timespec start, end;
                    // Table initialization
                    _sift_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    _sift_table->totalAttr = 2;
                    _sift_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    _sift_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                    _sift_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    // Load column 0, type: INTEGER
                    _sift_table->attrSize[0] = sizeof(int);
                    _sift_table->attrIndex[0] = 0;
                    _sift_table->attrType[0] = INT;
                    _sift_table->attrName[0] = "SIFT0";
                    _sift_table->dataPos[0] = GPU;
                    
                    outFd = open("SIFT0", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * sizeof(int);
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _sift_table->dataFormat[0] = header.format;
                    outSize = header.tupleNum * sizeof(int);
                    _sift_table->attrTotalSize[0] = outSize;

                    
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    if (fileCache.find("SIFT0") != fileCache.end()) {
                        content = fileCache["SIFT0"];
                    }
                    memcpy(&(_sift_table->content[0]), &content, sizeof(char*));
                    // cudaMalloc((void**)&(_sift_table->content[0]), outSize);
                    // cudaMemcpy(_sift_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    // Load column 1, type: VECTOR
                    _sift_table->attrSize[1] = 512;
                    _sift_table->attrIndex[1] = 1;
                    _sift_table->attrType[1] = VECTOR;
                    _sift_table->attrName[1] = "SIFT1";
                    _sift_table->dataPos[1] = GPU;
                    
                    outFd = open("SIFT1", O_RDONLY);
                    offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
                    lseek(outFd, offset, SEEK_SET);
                    read(outFd, &header, sizeof(struct columnHeader));
                    offset += sizeof(struct columnHeader);
                    _sift_table->dataFormat[1] = header.format;
                    outSize = header.tupleNum * 512;
                    _sift_table->attrTotalSize[1] = outSize;

                    
                    outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                    if (fileCache.find("SIFT1") != fileCache.end()) {
                        content = fileCache["SIFT1"];
                    }
                    memcpy(&(_sift_table->content[1]), &content, sizeof(char*));
                    // cudaMalloc((void**)&(_sift_table->content[1]), outSize);
                    // cudaMemcpy(_sift_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    close(outFd);

                    _sift_table->tupleSize = 0 + sizeof(int) + 512;
                    _sift_table->tupleNum = header.tupleNum;

                    if(blockTotal != 1){
                        mergeIntoTable(siftTable,_sift_table, &pp);
                        clock_gettime(CLOCK_REALTIME, &diskStart);
                        freeTable(_sift_table);
                        clock_gettime(CLOCK_REALTIME, &diskEnd);
                        diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                    }else{
                        siftTable = _sift_table;
                    }
                    tupleOffset += header.tupleNum;
                }
                siftTable->colIdxNum = 0;
                _sift_table->keepInGpuIdx = 1;
            }

            struct scanNode siftRel;
            siftRel.project = (struct projectFunction *)host_mempool.alloc(sizeof(struct projectFunction));
            siftRel.projectNum = 1;
            (siftRel.project)->exp = (struct projectExp*)host_mempool.alloc(sizeof(struct projectExp) *1);
            (siftRel.project)->exp[0].index    = 1;
            (siftRel.project)->exp[0].func     = DISTANCE;
            (siftRel.project)->exp[0].funcType = 1;
            strcpy((siftRel.project)->exp[0].vecPath, "/home/szr/subquery/benchmark/siftsearchvec");
            (siftRel.project)->exp[0].limit     = 100;
            siftRel.hasWhere = 0;
            siftRel.tn = siftTable;
            siftRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            siftRel.outputNum = 2;
            siftRel.outputIndex[0] = 0;
            siftRel.outputIndex[1] = 1;
            siftRel.keepInGpu = 1;
            int dev_memsize = tableScanGPUMemSize(&siftRel);
            if(gpu_inner_mp.freesize() < dev_memsize)
                gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
            char *origin_pos = gpu_inner_mp.freepos();
            si0 = tableScan(&siftRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL, index);
            gpu_inner_mp.freeto(origin_pos);

            clock_gettime(CLOCK_REALTIME, &diskStart);
            siftTable->content[0] = NULL;
            siftTable->content[1] = NULL;
            freeScan(&siftRel, false);

            si0->colIdxNum = 0;
        }

        CUDA_SAFE_CALL(cudaDeviceSynchronize()); //need to wait to ensure correct timing
        clock_gettime(CLOCK_REALTIME,&te);
        tt = (te.tv_sec - ts.tv_sec)* BILLION + te.tv_nsec - ts.tv_nsec;
        printf("tableScan time = %f\n", tt/(1000*1000));

        clock_gettime(CLOCK_REALTIME,&ts);
        struct tableNode * ob_si0;
        {

            struct orderByNode * odNode = (struct orderByNode *)host_mempool.alloc(sizeof(struct orderByNode));
            odNode->table = si0;
            odNode->orderByNum = 1;
            odNode->orderBySeq = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
            odNode->orderByIndex = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
            odNode->orderBySeq[0] = ASC;
            odNode->orderByIndex[0] = 1;
            ob_si0 = orderBy(odNode, &pp);
            freeOrderByNode(odNode, false);

        }
        CUDA_SAFE_CALL(cudaDeviceSynchronize()); //need to wait to ensure correct timing
        clock_gettime(CLOCK_REALTIME,&te);
        tt = (te.tv_sec - ts.tv_sec)* BILLION + te.tv_nsec - ts.tv_nsec;
        printf("orderby time = %f\n", tt/(1000*1000));

        clock_gettime(CLOCK_REALTIME,&ts);
        result = ob_si0;
        struct materializeNode mn;
        mn.table = result;
        char *final = materializeCol(&mn, &pp);
        CUDA_SAFE_CALL(cudaDeviceSynchronize()); //need to wait to ensure correct timing
        clock_gettime(CLOCK_REALTIME,&te);
        tt = (te.tv_sec - ts.tv_sec)* BILLION + te.tv_nsec - ts.tv_nsec;
        printf("materialize time = %f\n", tt/(1000*1000));

        clock_gettime(CLOCK_REALTIME, &end);
        double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
        times.push_back(timeE);

        FILE *file = fopen("../../benchmark/output.txt", "w");
        for(int j = 0; j < 100; j++){
            fprintf(file, "%d\n", ((int*)final)[2*j] - 1);
        }
        fclose(file);

        command = "python3 sift_acc.py " + std::to_string(i);
        res = std::system(command.c_str());

    }
    double sum = std::accumulate(times.begin(), times.end(), 0.0);

    double average = sum / times.size();

    printf("avg time: %lf\n\n", average/(1000*1000));

    std::string command = "python3 sift_avg_acc.py";
    int res = std::system(command.c_str());
}




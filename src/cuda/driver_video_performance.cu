/* This file is generated by code_gen.py */
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>
#include <unistd.h>
#include <malloc.h>
#include <time.h>
#include <getopt.h>
#include <linux/limits.h>
#include "../include/common.h"
#include "../include/hashJoin.h"
#include "../include/schema.h"
#include "../include/Mempool.h"
#include <map>
#include "../include/cpuCudaLib.h"
#include "../include/gpuCudaLib.h"
#include <faiss/gpu/GpuAutoTune.h>
#include <faiss/gpu/GpuCloner.h>
#include <faiss/gpu/GpuIndexIVFPQ.h>
#include <faiss/gpu/StandardGpuResources.h>
#include <faiss/index_io.h>
#include <faiss/IndexFlat.h>
#include <faiss/IndexIVFPQ.h>
extern struct tableNode* tableScan(struct scanNode *,struct statistic *, Mempool *, Mempool *, Mempool *, int *, int *, int *, faiss::Index*);
extern void createIndex (struct tableNode *, int, int, struct statistic *);
extern struct tableNode* hashJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern struct tableNode* knnJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *, faiss::Index*);
extern struct tableNode* cartesianProductJoin(struct joinNode *, struct statistic *, Mempool *, Mempool *, Mempool *, int *);
extern int *buildColumnHash(struct tableNode *, int, struct statistic *);
extern struct tableNode* groupBy(struct groupByNode *,struct statistic *, Mempool *, Mempool *);
extern struct tableNode* orderBy(struct orderByNode *, struct statistic *);
extern char* materializeCol(struct materializeNode * mn, struct statistic *);
int searchFrameNum = 0;

#define CHECK_POINTER(p) do {\
    if(p == NULL){   \
        perror("Failed to allocate host memory");    \
        exit(-1);      \
    }} while(0)

int main(int argc, char ** argv){

    /* For initializing CUDA device */
    int * cudaTmp;
    cudaMalloc((void**)&cudaTmp,sizeof(int));
    cudaFree(cudaTmp);

    int table;
    int long_index;
    char path[PATH_MAX];
    int setPath = 0;
    struct option long_options[] = {
        {"datadir",required_argument,0,'0'}
    };

    while((table=getopt_long(argc,argv,"",long_options,&long_index))!=-1){
        switch(table){
            case '0':
                setPath = 1;
                strcpy(path,optarg);
                break;
        }
    }

    if(setPath == 1)
        chdir(path);

    struct timespec start, end;
    struct timespec diskStart, diskEnd;
    double diskTotal = 0;
    
    std::unordered_map<std::string, char*> fileCache;
    struct tableNode *_dataset_video_table;
    {
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from DATASET_VIDEO0
        outFd = open("DATASET_VIDEO0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _dataset_video_table = (struct tableNode *)malloc(sizeof(struct tableNode));
            _dataset_video_table->totalAttr = 2;
            _dataset_video_table->attrType = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->attrSize = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->attrName = (char **)malloc(sizeof(char *) * 2);

            _dataset_video_table->attrIndex = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->attrTotalSize = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->dataPos = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->dataFormat = (int *)malloc(sizeof(int) * 2);
            _dataset_video_table->content = (char **)malloc(sizeof(char *) * 4);

            // Load column 0, type: TEXT
            _dataset_video_table->attrSize[0] = 23;
            _dataset_video_table->attrIndex[0] = 0;
            _dataset_video_table->attrType[0] = STRING;
            _dataset_video_table->attrName[0] = "DATASET_VIDEO0";
            _dataset_video_table->dataPos[0] = GPU;
            outFd = open("DATASET_VIDEO0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 23;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _dataset_video_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * 23;
            _dataset_video_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _dataset_video_table->content[0] = (char *)memalign(256, outSize);
            // memcpy(_dataset_video_table->content[0], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_dataset_video_table->content[0]), outSize);
                cudaMemcpy(_dataset_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DATASET_VIDEO0"] = _dataset_video_table->content[0];

                cudaMalloc((void**)&(_dataset_video_table->content[1]), outSize);
                cudaMemcpy(_dataset_video_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DATASET_VIDEO0_"] = _dataset_video_table->content[1];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            // diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: VECTOR
            _dataset_video_table->attrSize[1] = 512;
            _dataset_video_table->attrIndex[1] = 2;
            _dataset_video_table->attrType[1] = VECTOR;
            _dataset_video_table->attrName[1] = "DATASET_VIDEO2";
            _dataset_video_table->dataPos[1] = GPU;
            outFd = open("DATASET_VIDEO2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _dataset_video_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 512;
            _dataset_video_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            // _dataset_video_table->content[1] = (char *)memalign(256, outSize);
            // memcpy(_dataset_video_table->content[1], outTable, outSize);
            // munmap(outTable, outSize);
            {
                char* content = (char *)memalign(256, outSize);
                memcpy(content, outTable, outSize);
                munmap(outTable, outSize);

                cudaMalloc((void**)&(_dataset_video_table->content[2]), outSize);
                cudaMemcpy(_dataset_video_table->content[2], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DATASET_VIDEO2"] = _dataset_video_table->content[2];

                cudaMalloc((void**)&(_dataset_video_table->content[3]), outSize);
                cudaMemcpy(_dataset_video_table->content[3], content, outSize, cudaMemcpyHostToDevice);
                fileCache["DATASET_VIDEO2_"] = _dataset_video_table->content[3];
            }
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            // diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _dataset_video_table->tupleSize = 0 + 23 + 512;
            _dataset_video_table->tupleNum = header.tupleNum;
        }
    }

    char *index_path = "/home/szr/subquery/vector_src/init_vector/DATASET_VIDEO2_index.faissindex";
    faiss::Index *index = faiss::read_index(index_path);
    faiss::gpu::StandardGpuResources resources;
    int dev_no = 0;
    index = faiss::gpu::index_cpu_to_gpu(&resources, dev_no, index);

    struct statistic pp;
    pp.total = pp.kernel = pp.pcie = 0;

    pp.outerTableSize = pp.resultTableSize = pp.subCacheHits = 0;

    pp.annsTotalTime = 0;
    pp.loadIndex = 0;
    pp.indexCPU2GPU = 0;
    pp.trainIndex = 0;
    pp.saveIndex = 0;
    pp.indexAddData = 0;
    pp.indexSearch = 0;
    pp.buildIndexTotal = 0;
    pp.tableScanTotal = 0;
    pp.tableScanCount = 0;
    pp.whereMemCopy_s1 = 0;
    pp.dataMemCopy_s2 = 0;
    pp.scanTotal_s3 = 0;
    pp.preScanTotal_s4 = 0;
    pp.preScanCount_s4 = 0;
    pp.preScanResultMemCopy_s5 = 0;
    pp.dataMemCopyOther_s6 = 0;
    pp.materializeResult_s7 = 0;
    pp.finalResultMemCopy_s8 = 0;
    pp.create_tableNode_S01 = 0;
    pp.mallocRes_S02 = 0;
    pp.deallocateBuffs_S03 = 0;
    pp.getIndexPos_idxS1 = 0;
    pp.getRange_idxS2 = 0;
    pp.convertMemToElement_idxS3 = 0;
    pp.getMapping_idxS4 = 0;
    pp.setBitmapZeros_idxS5 = 0;
    pp.buildBitmap_idxS6 = 0;
    pp.countScanKernel_countS1 = 0;
    pp.scanImpl_countS2 = 0;
    pp.preallocBlockSums_scanImpl_S1 = 0;
    pp.prescanArray_scanImpl_S2 = 0;
    pp.deallocBlockSums_scanImpl_S3 = 0;
    pp.setVar_prescan_S1 = 0;
    pp.preScanKernel_prescan_S2 = 0;
    pp.uniformAddKernel_prescan_S3 = 0;

    pp.knnJoin_totalTime = 0;
    pp.knn_ANNs_time = 0;
    pp.cartesianJoin_totalTime = 0;
    pp.join_totalTime = 0;
    pp.join_callTimes = 0;
    pp.join_leftTableSize = 0;
    pp.join_rightTableSize = 0;
    pp.joinProf_step1_allocateMem = 0;
    pp.joinProf_step2_buildHash = 0;
    pp.joinProf_step21_allocateMem = 0;
    pp.joinProf_step22_Count_hash_num = 0;
    pp.joinProf_step23_scanImpl = 0;
    pp.joinProf_step24_buildhash_kernel_memcopy = 0;
    pp.joinProf_step3_join = 0;
    pp.joinProf_step31_allocateMem = 0;
    pp.joinProf_step32_exclusiveScan = 0;
    pp.joinProf_step33_prob = 0;
    pp.joinProf_step4_materialize_res = 0;
    pp.joinProf_step41_materialize_res_left = 0;
    pp.joinProf_step42_materialize_res_right = 0;

    pp.groupby_totalTime = 0;
    pp.groupby_callTimes = 0;
    pp.groupby_step1_allocMem = 0;
    pp.groupby_step2_copyToDevice = 0;
    pp.groupby_step3_buildGroupByKey = 0;
    pp.groupby_step4_groupCount = 0;
    pp.groupby_step5_AllocRes = 0;
    pp.groupby_step6_copyDataCols = 0;
    pp.groupby_step7_computeAgg = 0;
    pp.groupby_step8_deallocate = 0;

    Mempool host_mempool(MEM);
    Mempool gpu_inner_mp(GPU);
    Mempool gpu_inter_mp(GPU);

    clock_gettime(CLOCK_REALTIME,&start);

    // Load columns from the table DATASET_VIDEO
    struct tableNode *dataset_videoTable;
    dataset_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *_dataset_video_table;
        int outFd;
        long outSize;
        char *outTable;
        long offset, tupleOffset;
        int blockTotal;
        struct columnHeader header;

        // Retrieve the block number from DATASET_VIDEO0
        outFd = open("DATASET_VIDEO0", O_RDONLY);
        read(outFd, &header, sizeof(struct columnHeader));
        blockTotal = header.blockTotal;
        close(outFd);
        offset = 0;
        tupleOffset = 0;
        char* content;
        for(int i = 0; i < blockTotal; i++){

            // Table initialization
            _dataset_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
            _dataset_video_table->totalAttr = 2;
            _dataset_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

            _dataset_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
            _dataset_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

            // Load column 0, type: TEXT
            _dataset_video_table->attrSize[0] = 23;
            _dataset_video_table->attrIndex[0] = 0;
            _dataset_video_table->attrType[0] = STRING;
            _dataset_video_table->attrName[0] = "DATASET_VIDEO0";
            _dataset_video_table->dataPos[0] = GPU;
            outFd = open("DATASET_VIDEO0", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 23;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _dataset_video_table->dataFormat[0] = header.format;
            outSize = header.tupleNum * 23;
            _dataset_video_table->attrTotalSize[0] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            if (fileCache.find("DATASET_VIDEO0") != fileCache.end()) {
                content = fileCache["DATASET_VIDEO0"];
            }
            memcpy(&(_dataset_video_table->content[0]), &content, sizeof(char*));
            // cudaMalloc((void**)&(_dataset_video_table->content[0]), outSize);
            // cudaMemcpy(_dataset_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
            // _dataset_video_table->content[0] = (char *)memalign(256, outSize);
            // memcpy(_dataset_video_table->content[0], outTable, outSize);
            // munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            // Load column 2, type: VECTOR
            _dataset_video_table->attrSize[1] = 512;
            _dataset_video_table->attrIndex[1] = 2;
            _dataset_video_table->attrType[1] = VECTOR;
            _dataset_video_table->attrName[1] = "DATASET_VIDEO2";
            _dataset_video_table->dataPos[1] = GPU;
            outFd = open("DATASET_VIDEO2", O_RDONLY);
            offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
            lseek(outFd, offset, SEEK_SET);
            read(outFd, &header, sizeof(struct columnHeader));
            offset += sizeof(struct columnHeader);
            _dataset_video_table->dataFormat[1] = header.format;
            outSize = header.tupleNum * 512;
            _dataset_video_table->attrTotalSize[1] = outSize;

            clock_gettime(CLOCK_REALTIME,&diskStart);
            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
            
            if (fileCache.find("DATASET_VIDEO2") != fileCache.end()) {
                content = fileCache["DATASET_VIDEO2"];
            }
            memcpy(&(_dataset_video_table->content[1]), &content, sizeof(char*));
            // cudaMalloc((void**)&(_dataset_video_table->content[1]), outSize);
            // cudaMemcpy(_dataset_video_table->content[1], content, outSize, cudaMemcpyHostToDevice);
            // _dataset_video_table->content[1] = (char *)memalign(256, outSize);
            // memcpy(_dataset_video_table->content[1], outTable, outSize);
            // munmap(outTable, outSize);
            clock_gettime(CLOCK_REALTIME, &diskEnd);
            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            close(outFd);

            _dataset_video_table->tupleSize = 0 + 23 + 512;
            _dataset_video_table->tupleNum = header.tupleNum;

            if(blockTotal != 1){
                mergeIntoTable(dataset_videoTable,_dataset_video_table, &pp);
                clock_gettime(CLOCK_REALTIME, &diskStart);
                freeTable(_dataset_video_table);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
            }else{
                dataset_videoTable = _dataset_video_table;
            }
            tupleOffset += header.tupleNum;
        }
        dataset_videoTable->colIdxNum = 0;
        _dataset_video_table->keepInGpuIdx = 1;
    }

    transferTableColumnToGPU(dataset_videoTable, 0);
    transferTableColumnToGPU(dataset_videoTable, 1);


    struct tableNode *result;
    char * subqRes0;

    // Process the TableNode for DATASET_VIDEO
    struct tableNode *da0;
    da0 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
    {
        struct tableNode *dataset_videoTablePartial;
        dataset_videoTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        dataset_videoTablePartial->totalAttr = 2;
        dataset_videoTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

        dataset_videoTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
        int tuple_size = 0;
        dataset_videoTablePartial->attrSize[0] = dataset_videoTable->attrSize[0];
        dataset_videoTablePartial->attrIndex[0] = dataset_videoTable->attrIndex[0];
        dataset_videoTablePartial->attrType[0] = dataset_videoTable->attrType[0];
        dataset_videoTablePartial->attrName[0] = "dataset_videoTablePartial0";
        dataset_videoTablePartial->dataPos[0] = dataset_videoTable->dataPos[0];
        dataset_videoTablePartial->dataFormat[0] = dataset_videoTable->dataFormat[0];
        dataset_videoTablePartial->attrTotalSize[0] = dataset_videoTable->attrTotalSize[0];
        dataset_videoTablePartial->content[0] = dataset_videoTable->content[0];
        tuple_size += dataset_videoTablePartial->attrSize[0];

        dataset_videoTablePartial->attrSize[1] = dataset_videoTable->attrSize[1];
        dataset_videoTablePartial->attrIndex[1] = dataset_videoTable->attrIndex[1];
        dataset_videoTablePartial->attrType[1] = dataset_videoTable->attrType[1];
        dataset_videoTablePartial->attrName[1] = "dataset_videoTablePartial1";
        dataset_videoTablePartial->dataPos[1] = dataset_videoTable->dataPos[1];
        dataset_videoTablePartial->dataFormat[1] = dataset_videoTable->dataFormat[1];
        dataset_videoTablePartial->attrTotalSize[1] = dataset_videoTable->attrTotalSize[1];
        dataset_videoTablePartial->content[1] = dataset_videoTable->content[1];
        tuple_size += dataset_videoTablePartial->attrSize[1];

        dataset_videoTablePartial->tupleSize = tuple_size;
        dataset_videoTablePartial->tupleNum = dataset_videoTable->tupleNum;

        dataset_videoTablePartial->colIdxNum = 0;
        dataset_videoTablePartial->keepInGpuIdx = 1;
        // Load columns from the table DATASET_VIDEO
        struct tableNode *dataset_videoTable;
        dataset_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
        {
            struct tableNode *_dataset_video_table;
            int outFd;
            long outSize;
            char *outTable;
            long offset, tupleOffset;
            int blockTotal;
            char *content;
            struct columnHeader header;

            // Retrieve the block number from DATASET_VIDEO0
            outFd = open("DATASET_VIDEO0", O_RDONLY);
            read(outFd, &header, sizeof(struct columnHeader));
            blockTotal = header.blockTotal;
            close(outFd);
            offset = 0;
            tupleOffset = 0;
            for(int i = 0; i < blockTotal; i++){

                // Table initialization
                _dataset_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                _dataset_video_table->totalAttr = 2;
                _dataset_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                _dataset_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                _dataset_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                // Load column 0, type: TEXT
                _dataset_video_table->attrSize[0] = 23;
                _dataset_video_table->attrIndex[0] = 0;
                _dataset_video_table->attrType[0] = STRING;
                _dataset_video_table->attrName[0] = "DATASET_VIDEO0";
                _dataset_video_table->dataPos[0] = GPU;
                outFd = open("DATASET_VIDEO0", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * 23;
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _dataset_video_table->dataFormat[0] = header.format;
                outSize = header.tupleNum * 23;
                _dataset_video_table->attrTotalSize[0] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("DATASET_VIDEO0") != fileCache.end()) {
                    content = fileCache["DATASET_VIDEO0"];
                }
                memcpy(&(_dataset_video_table->content[0]), &content, sizeof(char*));
                // cudaMalloc((void**)&(_dataset_video_table->content[0]), outSize);
                // cudaMemcpy(_dataset_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                // _dataset_video_table->content[0] = (char *)memalign(256, outSize);
                // memcpy(_dataset_video_table->content[0], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                // Load column 2, type: VECTOR
                _dataset_video_table->attrSize[1] = 512;
                _dataset_video_table->attrIndex[1] = 2;
                _dataset_video_table->attrType[1] = VECTOR;
                _dataset_video_table->attrName[1] = "DATASET_VIDEO2";
                _dataset_video_table->dataPos[1] = GPU;
                outFd = open("DATASET_VIDEO2", O_RDONLY);
                offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
                lseek(outFd, offset, SEEK_SET);
                read(outFd, &header, sizeof(struct columnHeader));
                offset += sizeof(struct columnHeader);
                _dataset_video_table->dataFormat[1] = header.format;
                outSize = header.tupleNum * 512;
                _dataset_video_table->attrTotalSize[1] = outSize;

                clock_gettime(CLOCK_REALTIME,&diskStart);
                outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                if (fileCache.find("DATASET_VIDEO2") != fileCache.end()) {
                    content = fileCache["DATASET_VIDEO2"];
                }
                memcpy(&(_dataset_video_table->content[1]), &content, sizeof(char*));
                // cudaMalloc((void**)&(_dataset_video_table->content[1]), outSize);
                // cudaMemcpy(_dataset_video_table->content[1], content, outSize, cudaMemcpyHostToDevice);
                // _dataset_video_table->content[1] = (char *)memalign(256, outSize);
                // memcpy(_dataset_video_table->content[1], outTable, outSize);
                // munmap(outTable, outSize);
                clock_gettime(CLOCK_REALTIME, &diskEnd);
                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                close(outFd);

                _dataset_video_table->tupleSize = 0 + 23 + 512;
                _dataset_video_table->tupleNum = header.tupleNum;

                if(blockTotal != 1){
                    mergeIntoTable(dataset_videoTable,_dataset_video_table, &pp);
                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    freeTable(_dataset_video_table);
                    clock_gettime(CLOCK_REALTIME, &diskEnd);
                    diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                }else{
                    dataset_videoTable = _dataset_video_table;
                }
                tupleOffset += header.tupleNum;
            }
            dataset_videoTable->colIdxNum = 0;
            _dataset_video_table->keepInGpuIdx = 1;
        }

        struct scanNode dataset_videoRel;
        // Where conditions: IN(DATASET_VIDEO.0,SUBQ(0))
        dataset_videoRel.hasWhere = 1;
        dataset_videoRel.whereAttrNum = 1;
        dataset_videoRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        dataset_videoRel.whereIndex[0] = 0;
        dataset_videoRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
        (dataset_videoRel.filter)->nested = 0;
        (dataset_videoRel.filter)->expNum = 1;
        (dataset_videoRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
        (dataset_videoRel.filter)->andOr = EXP;
        (dataset_videoRel.filter)->exp[0].index    = 0;
        (dataset_videoRel.filter)->exp[0].relation = IN_VEC;
        (dataset_videoRel.filter)->exp[0].dataPos  = MEM;

        // Process the subquery
        subqRes0 = (char *)malloc(sizeof(char *) * dataset_videoTable->tupleNum);
        CHECK_POINTER(subqRes0);

        transferTableColumnToGPU(dataset_videoTable, 0);
        transferTableColumnToGPU(dataset_videoTable, 1);
        char *free_pos = host_mempool.freepos();
        char *free_gpu_pos = gpu_inter_mp.freepos();
        {
                struct tableNode *result;
                char * subqRes1;

                // Process the TableNode for DATASET_VIDEO
                struct tableNode *da1;
                da1 = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                {
                    struct tableNode *dataset_videoTablePartial;
                    dataset_videoTablePartial = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    dataset_videoTablePartial->totalAttr = 2;
                    dataset_videoTablePartial->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                    dataset_videoTablePartial->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                    dataset_videoTablePartial->content = (char **)host_mempool.alloc(sizeof(char *) * 2);
                    int tuple_size = 0;
                    dataset_videoTablePartial->attrSize[0] = dataset_videoTable->attrSize[0];
                    dataset_videoTablePartial->attrIndex[0] = dataset_videoTable->attrIndex[0];
                    dataset_videoTablePartial->attrType[0] = dataset_videoTable->attrType[0];
                    dataset_videoTablePartial->attrName[0] = "dataset_videoTablePartial0";
                    dataset_videoTablePartial->dataPos[0] = dataset_videoTable->dataPos[0];
                    dataset_videoTablePartial->dataFormat[0] = dataset_videoTable->dataFormat[0];
                    dataset_videoTablePartial->attrTotalSize[0] = dataset_videoTable->attrTotalSize[0];
                    dataset_videoTablePartial->content[0] = dataset_videoTable->content[0];
                    tuple_size += dataset_videoTablePartial->attrSize[0];

                    dataset_videoTablePartial->attrSize[1] = dataset_videoTable->attrSize[1];
                    dataset_videoTablePartial->attrIndex[1] = dataset_videoTable->attrIndex[1];
                    dataset_videoTablePartial->attrType[1] = dataset_videoTable->attrType[1];
                    dataset_videoTablePartial->attrName[1] = "dataset_videoTablePartial1";
                    dataset_videoTablePartial->dataPos[1] = dataset_videoTable->dataPos[1];
                    dataset_videoTablePartial->dataFormat[1] = dataset_videoTable->dataFormat[1];
                    dataset_videoTablePartial->attrTotalSize[1] = dataset_videoTable->attrTotalSize[1];
                    dataset_videoTablePartial->content[1] = dataset_videoTable->content[1];
                    tuple_size += dataset_videoTablePartial->attrSize[1];

                    dataset_videoTablePartial->tupleSize = tuple_size;
                    dataset_videoTablePartial->tupleNum = dataset_videoTable->tupleNum;

                    dataset_videoTablePartial->colIdxNum = 0;
                    dataset_videoTablePartial->keepInGpuIdx = 1;
                    // Load columns from the table DATASET_VIDEO
                    struct tableNode *dataset_videoTable;
                    dataset_videoTable = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                    {
                        struct tableNode *_dataset_video_table;
                        int outFd;
                        long outSize;
                        char *outTable;
                        long offset, tupleOffset;
                        int blockTotal;
                        char *content;
                        struct columnHeader header;

                        // Retrieve the block number from DATASET_VIDEO0
                        outFd = open("DATASET_VIDEO0", O_RDONLY);
                        read(outFd, &header, sizeof(struct columnHeader));
                        blockTotal = header.blockTotal;
                        close(outFd);
                        offset = 0;
                        tupleOffset = 0;
                        for(int i = 0; i < blockTotal; i++){

                            // Table initialization
                            _dataset_video_table = (struct tableNode *)host_mempool.alloc(sizeof(struct tableNode));
                            _dataset_video_table->totalAttr = 2;
                            _dataset_video_table->attrType = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->attrSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->attrName = (char **)host_mempool.alloc(sizeof(char *) * 2);

                            _dataset_video_table->attrIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->attrTotalSize = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->dataPos = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->dataFormat = (int *)host_mempool.alloc(sizeof(int) * 2);
                            _dataset_video_table->content = (char **)host_mempool.alloc(sizeof(char *) * 2);

                            // Load column 0, type: TEXT
                            _dataset_video_table->attrSize[0] = 23;
                            _dataset_video_table->attrIndex[0] = 0;
                            _dataset_video_table->attrType[0] = STRING;
                            _dataset_video_table->attrName[0] = "DATASET_VIDEO0";
                            _dataset_video_table->dataPos[0] = GPU;
                            outFd = open("DATASET_VIDEO0", O_RDONLY);
                            offset = i * sizeof(struct columnHeader) + tupleOffset * 23;
                            lseek(outFd, offset, SEEK_SET);
                            read(outFd, &header, sizeof(struct columnHeader));
                            offset += sizeof(struct columnHeader);
                            _dataset_video_table->dataFormat[0] = header.format;
                            outSize = header.tupleNum * 23;
                            _dataset_video_table->attrTotalSize[0] = outSize;

                            clock_gettime(CLOCK_REALTIME,&diskStart);
                            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                            if (fileCache.find("DATASET_VIDEO0_") != fileCache.end()) {
                                content = fileCache["DATASET_VIDEO0_"];
                            }
                            memcpy(&(_dataset_video_table->content[0]), &content, sizeof(char*));
                            // cudaMalloc((void**)&(_dataset_video_table->content[0]), outSize);
                            // cudaMemcpy(_dataset_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                            // _dataset_video_table->content[0] = (char *)memalign(256, outSize);
                            // memcpy(_dataset_video_table->content[0], outTable, outSize);
                            // munmap(outTable, outSize);
                            clock_gettime(CLOCK_REALTIME, &diskEnd);
                            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                            close(outFd);

                            // Load column 2, type: VECTOR
                            _dataset_video_table->attrSize[1] = 512;
                            _dataset_video_table->attrIndex[1] = 2;
                            _dataset_video_table->attrType[1] = VECTOR;
                            _dataset_video_table->attrName[1] = "DATASET_VIDEO2";
                            _dataset_video_table->dataPos[1] = GPU;
                            outFd = open("DATASET_VIDEO2", O_RDONLY);
                            offset = i * sizeof(struct columnHeader) + tupleOffset * 512;
                            lseek(outFd, offset, SEEK_SET);
                            read(outFd, &header, sizeof(struct columnHeader));
                            offset += sizeof(struct columnHeader);
                            _dataset_video_table->dataFormat[1] = header.format;
                            outSize = header.tupleNum * 512;
                            _dataset_video_table->attrTotalSize[1] = outSize;

                            clock_gettime(CLOCK_REALTIME,&diskStart);
                            outTable =(char *)mmap(0, outSize, PROT_READ, MAP_SHARED, outFd, offset);
                            if (fileCache.find("DATASET_VIDEO2_") != fileCache.end()) {
                                content = fileCache["DATASET_VIDEO2_"];
                            }
                            memcpy(&(_dataset_video_table->content[1]), &content, sizeof(char*));
                            // cudaMalloc((void**)&(_dataset_video_table->content[0]), outSize);
                            // cudaMemcpy(_dataset_video_table->content[0], content, outSize, cudaMemcpyHostToDevice);
                            // _dataset_video_table->content[0] = (char *)memalign(256, outSize);
                            // memcpy(_dataset_video_table->content[0], outTable, outSize);
                            // munmap(outTable, outSize);
                            clock_gettime(CLOCK_REALTIME, &diskEnd);
                            diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                            close(outFd);

                            _dataset_video_table->tupleSize = 0 + 23 + 512;
                            _dataset_video_table->tupleNum = header.tupleNum;

                            if(blockTotal != 1){
                                mergeIntoTable(dataset_videoTable,_dataset_video_table, &pp);
                                clock_gettime(CLOCK_REALTIME, &diskStart);
                                freeTable(_dataset_video_table);
                                clock_gettime(CLOCK_REALTIME, &diskEnd);
                                diskTotal += (diskEnd.tv_sec -  diskStart.tv_sec)* BILLION + diskEnd.tv_nsec - diskStart.tv_nsec;
                            }else{
                                dataset_videoTable = _dataset_video_table;
                            }
                            tupleOffset += header.tupleNum;
                        }
                        dataset_videoTable->colIdxNum = 0;
                        _dataset_video_table->keepInGpuIdx = 1;
                    }

                    struct scanNode dataset_videoRel;
                    // Where conditions: LEQ(KNN(VIDEO_EXTRACTION(/home/szr/subquery/gtvideos/6547319806729653518.mp4),DATASET_VIDEO.2),100)
                    dataset_videoRel.hasWhere = 1;
                    dataset_videoRel.whereAttrNum = 1;
                    dataset_videoRel.whereIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    dataset_videoRel.whereIndex[0] = 1;
                    dataset_videoRel.filter = (struct whereCondition *)host_mempool.alloc(sizeof(struct whereCondition));
                    (dataset_videoRel.filter)->nested = 0;
                    (dataset_videoRel.filter)->expNum = 1;
                    (dataset_videoRel.filter)->exp = (struct whereExp*)host_mempool.alloc(sizeof(struct whereExp) *1);
                    (dataset_videoRel.filter)->andOr = EXP;
                    (dataset_videoRel.filter)->exp[0].index    = 0;
                    (dataset_videoRel.filter)->exp[0].relation = KNN;
                    (dataset_videoRel.filter)->exp[0].dataPos  = MEM;
                    {
                        int tmp = 100;
                        memcpy((dataset_videoRel.filter)->exp[0].content, &tmp, sizeof(int));
                    }
                    {
                        char *tmp = "../../vector_src/init_vector/videoFeatures";
                        strcpy((dataset_videoRel.filter)->exp[0].videoFeaturePath, tmp);
                    }
                    dataset_videoRel.tn = dataset_videoTable;
                    dataset_videoRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
                    dataset_videoRel.outputNum = 1;
                    dataset_videoRel.outputIndex[0] = 0;
                    dataset_videoRel.keepInGpu = 1;
                    int dev_memsize = tableScanGPUMemSize(&dataset_videoRel);
                    if(gpu_inner_mp.freesize() < dev_memsize)
                        gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
                    char *origin_pos = gpu_inner_mp.freepos();
                    da1 = tableScan(&dataset_videoRel, &pp, &host_mempool, &gpu_inner_mp, &gpu_inter_mp, NULL, NULL, NULL, index);
                    gpu_inner_mp.freeto(origin_pos);

                    clock_gettime(CLOCK_REALTIME, &diskStart);
                    dataset_videoTable->content[0] = NULL;
                    dataset_videoTable->content[1] = NULL;
                    freeScan(&dataset_videoRel, false);

                    da1->colIdxNum = 0;
                }

                result = da1;
                struct materializeNode mn;
                mn.table = result;
                char *final = materializeCol(&mn, &pp);
            
            ((char **)subqRes0)[0] = (char *)malloc(sizeof(int) + 23 * mn.table->tupleNum);
            CHECK_POINTER( ((char **)subqRes0)[0] );
            *(int *)(((char **)subqRes0)[0]) = mn.table->tupleNum;
            mempcpy(((char **)subqRes0)[0] + sizeof(int), final, 23 * mn.table->tupleNum);
            host_mempool.freeto(free_pos);
            gpu_inter_mp.freeto(free_gpu_pos);
            pp.outerTableSize = dataset_videoTable->tupleNum;
            pp.resultTableSize = mn.table->tupleNum;
        }

        memcpy((dataset_videoRel.filter)->exp[0].content, &subqRes0, sizeof(void *));
        dataset_videoRel.tn = dataset_videoTable;
        dataset_videoRel.outputIndex = (int *)host_mempool.alloc(sizeof(int) * 2);
        dataset_videoRel.outputNum = 2;
        dataset_videoRel.outputIndex[0] = 0;
        dataset_videoRel.outputIndex[1] = 1;
        dataset_videoRel.keepInGpu = 1;
        int dev_memsize = tableScanGPUMemSize(&dataset_videoRel);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos = gpu_inner_mp.freepos();
        da0 = tableScan(&dataset_videoRel, &pp, &host_mempool, &gpu_inner_mp, NULL, NULL, NULL, NULL, NULL);
        gpu_inner_mp.freeto(origin_pos);

        clock_gettime(CLOCK_REALTIME, &diskStart);
        dataset_videoTable->content[0] = NULL;
        dataset_videoTable->content[1] = NULL;
        freeScan(&dataset_videoRel, false);

        da0->colIdxNum = 0;
    }

    struct tableNode * gb_da0;
    {

        struct groupByNode * gbNode = (struct groupByNode *)host_mempool.alloc(sizeof(struct groupByNode));
        gbNode->table = da0;
        gbNode->groupByColNum = 1;
        gbNode->groupByIndex = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByType = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupBySize = (int *)host_mempool.alloc(sizeof(int) * 1);
        gbNode->groupByIndex[0] = 0;
        gbNode->groupByType[0] = gbNode->table->attrType[0];
        gbNode->groupBySize[0] = gbNode->table->attrSize[0];
        gbNode->outputAttrNum = 2;
        gbNode->attrType = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->attrSize = (int *)host_mempool.alloc(sizeof(int) *2);
        gbNode->gbExp = (struct groupByExp *)host_mempool.alloc(sizeof(struct groupByExp) * 2);
        gbNode->tupleSize = 0;
        gbNode->attrType[0] = gbNode->table->attrType[0];
        gbNode->attrSize[0] = gbNode->table->attrSize[0];
        gbNode->tupleSize += gbNode->table->attrSize[0];
        gbNode->gbExp[0].func = NOOP;
        gbNode->gbExp[0].exp.op = NOOP;
        gbNode->gbExp[0].exp.exp = 0;
        gbNode->gbExp[0].exp.opNum = 1;
        gbNode->gbExp[0].exp.opType = COLUMN;
        gbNode->gbExp[0].exp.opValue = 0;
        {
            char *tmp = "../../vector_src/init_vector/videoFeatures";
            strcpy(gbNode->gbExp[1].videoFeaturePath, tmp);
        }
        gbNode->tupleSize += sizeof(float);
        gbNode->attrType[1] = FLOAT;
        gbNode->attrSize[1] = sizeof(float);
        gbNode->gbExp[1].func = VIDEO_SIMILARITY;
        gbNode->gbExp[1].index = 1;
        gbNode->gbExp[1].type = 0;
        int dev_memsize = groupByGPUMemSize(gbNode);
        if(gpu_inner_mp.freesize() < dev_memsize)
            gpu_inner_mp.resize(gpu_inner_mp.usedsize() + dev_memsize);
        char *origin_pos_groupby = gpu_inner_mp.freepos();
        gb_da0 = groupBy(gbNode, &pp, &host_mempool, &gpu_inner_mp);
        gpu_inner_mp.freeto(origin_pos_groupby);

        freeGroupByNode(gbNode, false);

    }

    // struct tableNode * ob_gb_da0;
    // {

    //     struct orderByNode * odNode = (struct orderByNode *)host_mempool.alloc(sizeof(struct orderByNode));
    //     odNode->table = gb_da0;
    //     odNode->orderByNum = 1;
    //     odNode->orderBySeq = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
    //     odNode->orderByIndex = (int *)host_mempool.alloc(sizeof(int) * odNode->orderByNum);
    //     odNode->orderBySeq[0] = ASC;
    //     odNode->orderByIndex[0] = 1;
    //     ob_gb_da0 = orderBy(odNode, &pp);
    //     freeOrderByNode(odNode, false);

    // }

    result = gb_da0;
    struct materializeNode mn;
    mn.table = result;
    char *final = materializeCol(&mn, &pp);
    size_t size = 27 * result->tupleNum;
    FILE *file = fopen("../../benchmark/video_pred.bin", "wb");
    if (!file) {
        perror("Failed to open file");
        exit(1);
    }
    fwrite(final, 1, size, file);
    fclose(file);


    clock_gettime(CLOCK_REALTIME, &end);
    double timeE = (end.tv_sec -  start.tv_sec)* BILLION + end.tv_nsec - start.tv_nsec;
    printf("<--Disk Load Time-->           : %lf\n", diskTotal/(1000*1000));
    printf("\n");
    printf("<--Build index time-->         : %lf\n", pp.buildIndexTotal/(1000*1000));

    printf("\n");
    printf("<--ANNs total time-->          : %lf\n", pp.annsTotalTime/(1000*1000));

    printf("Load anns index                : %lf\n", pp.loadIndex/(1000*1000));

    printf("Load index from CPU to GPU     : %lf\n", pp.indexCPU2GPU/(1000*1000));

    printf("Train anns index               : %lf\n", pp.trainIndex/(1000*1000));

    printf("Save anns index                : %lf\n", pp.saveIndex/(1000*1000));

    printf("Add data to anns index         : %lf\n", pp.indexAddData/(1000*1000));

    printf("Search anns index              : %lf\n", pp.indexSearch/(1000*1000));

    printf("<---SUB()--->\n");
    printf("Outer table size           : %d\n", pp.outerTableSize);

    printf("Sub Cache hits             : %d\n", pp.subCacheHits);

    printf("Result table size          : %d\n", pp.resultTableSize);

    printf("<----------------->");
    printf("\n");
    printf("<---TableScan()--->\n");
    printf("Total time      : %lf\n", pp.tableScanTotal/(1000*1000));
    printf("Calls           : %d\n", pp.tableScanCount);

    printf("Step 1 - memCopy where clause                 : %lf\n", pp.whereMemCopy_s1/(1000*1000));
    printf("Step 2 - memCopy predicate col                : %lf\n", pp.dataMemCopy_s2/(1000*1000));
    printf("Step 3 - Scan                                 : %lf\n", pp.scanTotal_s3/(1000*1000));
    printf("Idx Step 3.1 - Get index position             : %lf\n", pp.getIndexPos_idxS1/(1000*1000));
    printf("Idx Step 3.2 - Get range                      : %lf\n", pp.getRange_idxS2/(1000*1000));
    printf("Idx Step 3.3 - Convert addrs to elements      : %lf\n", pp.convertMemToElement_idxS3/(1000*1000));
    printf("Idx Step 3.4 - Get mapping position           : %lf\n", pp.getMapping_idxS4/(1000*1000));
    printf("Idx Step 3.5 - Set bitmap to zero             : %lf\n", pp.setBitmapZeros_idxS5/(1000*1000));
    printf("Idx Step 3.6 - Build bitmap                   : %lf\n", pp.buildBitmap_idxS6/(1000*1000));
    printf("Step 4 - CountRes(PreScan)                    : %lf\n", pp.preScanTotal_s4/(1000*1000));
    printf("PreScan Step 4.1 - Count selected rows kernel : %lf\n", pp.countScanKernel_countS1/(1000*1000));
    printf("PreScan Step 4.2 - scanImpl time              : %lf\n", pp.scanImpl_countS2/(1000*1000));
    printf("scanImpl Step 4.2.1 - preallocBlockSums time  : %lf\n", pp.preallocBlockSums_scanImpl_S1/(1000*1000));
    printf("scanImpl Step 4.2.2 - prescanArray time       : %lf\n", pp.prescanArray_scanImpl_S2/(1000*1000));
    printf("scanImpl Step 4.2.3 - deallocBlockSums time   : %lf\n", pp.deallocBlockSums_scanImpl_S3/(1000*1000));
    printf("prescan Step 4.2.3.1 - set variables time     : %lf\n", pp.setVar_prescan_S1/(1000*1000));
    printf("prescan Step 4.2.3.2 - prescan Kernel time    : %lf\n", pp.preScanKernel_prescan_S2/(1000*1000));
    printf("prescan Step 4.2.3.3 - uniformAdd Kernel time : %lf\n", pp.uniformAddKernel_prescan_S3/(1000*1000));
    printf("Step 5 - memReturn countRes                   : %lf\n", pp.preScanResultMemCopy_s5/(1000*1000));
    printf("Step 6 - Copy rest of columns                 : %lf\n", pp.dataMemCopyOther_s6/(1000*1000));
    printf("Step 7 - Materialize result                   : %lf\n", pp.materializeResult_s7/(1000*1000));
    printf("Step 8 - Copy final result                    : %lf\n", pp.finalResultMemCopy_s8/(1000*1000));
    printf("Other 1 - Create tableNode                    : %lf\n", pp.create_tableNode_S01/(1000*1000));
    printf("Other 2 - Malloc res                          : %lf\n", pp.mallocRes_S02/(1000*1000));
    printf("Other 3 - Deallocate buffers                  : %lf\n", pp.deallocateBuffs_S03/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("<---Join--->\n");
    printf("Calls                     : %d\n", pp.join_callTimes);

    printf("<---knnJoin()--->\n");
    printf("Total time                : %lf\n", pp.knnJoin_totalTime/(1000*1000));
    printf("Total ANNs time           : %lf\n", pp.knn_ANNs_time/(1000*1000));
    printf("<---cartesianJoin()--->\n");
    printf("Total time                : %lf\n", pp.cartesianJoin_totalTime/(1000*1000));
    printf("<---HashJoin()--->\n");
    printf("Total time                : %lf\n", pp.join_totalTime/(1000*1000));
    printf("Left table Size           : %d\n", pp.join_leftTableSize);

    printf("Right table Size          : %d\n", pp.join_rightTableSize);

    printf("Step 1 - Allocate memory for intermediate results : %lf\n", pp.joinProf_step1_allocateMem/(1000*1000));
    printf("Step 2 - Build hashTable                          : %lf\n", pp.joinProf_step2_buildHash/(1000*1000));
    printf("Step 2.1 - Allocate memory                        : %lf\n", pp.joinProf_step21_allocateMem/(1000*1000));
    printf("Step 2.2 - Count_hash_num                         : %lf\n", pp.joinProf_step22_Count_hash_num/(1000*1000));
    printf("Step 2.3 - scanImpl                               : %lf\n", pp.joinProf_step23_scanImpl/(1000*1000));
    printf("Step 2.4 - build_hash_table (+ memCopy op)        : %lf\n", pp.joinProf_step24_buildhash_kernel_memcopy/(1000*1000));
    printf("Step 3 - Join                                     : %lf\n", pp.joinProf_step3_join/(1000*1000));
    printf("Step 3.1 - Allocate memory                        : %lf\n", pp.joinProf_step31_allocateMem/(1000*1000));
    printf("Step 3.2 - Exclusive scan                         : %lf\n", pp.joinProf_step32_exclusiveScan/(1000*1000));
    printf("Step 3.3 - Prob and memcpy ops                    : %lf\n", pp.joinProf_step33_prob/(1000*1000));
    printf("Step 4 - Materialize result                       : %lf\n", pp.joinProf_step4_materialize_res/(1000*1000));
    printf("Step 4.1 - Materialize left part (joinFact)       : %lf\n", pp.joinProf_step41_materialize_res_left/(1000*1000));
    printf("Step 4.2 - Materialize right part (joinDim)       : %lf\n", pp.joinProf_step42_materialize_res_right/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("<---GroupBy()--->\n");
    printf("Total time      : %lf\n", pp.groupby_totalTime/(1000*1000));
    printf("Calls           : %d\n", pp.groupby_callTimes);

    printf("Step 1 - Allocate memory for intermediate results : %lf\n", pp.groupby_step1_allocMem/(1000*1000));
    printf("Step 2 - Copy data to GPU                         : %lf\n", pp.groupby_step2_copyToDevice/(1000*1000));
    printf("Step 3 - Build Group By Key                       : %lf\n", pp.groupby_step3_buildGroupByKey/(1000*1000));
    printf("Step 4 - Count number of groups                   : %lf\n", pp.groupby_step4_groupCount/(1000*1000));
    printf("Step 5 - Allocate memory for result               : %lf\n", pp.groupby_step5_AllocRes/(1000*1000));
    printf("Step 6 - Copy columns to device                   : %lf\n", pp.groupby_step6_copyDataCols/(1000*1000));
    printf("Step 7 - Calculate aggregate values               : %lf\n", pp.groupby_step7_computeAgg/(1000*1000));
    printf("Step 8 - De-allocate memory                       : %lf\n", pp.groupby_step8_deallocate/(1000*1000));
    printf("<----------------->");
    printf("\n");
    printf("Total Time: %lf\n", timeE/(1000*1000));
}
